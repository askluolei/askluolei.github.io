---
title: jvm-自动内存管理
tags:
  - java
  - jvm
categories:
  - 技术笔记
date: 2019-11-23 17:32:11
---


`深入理解 Java 虚拟机` 读书笔记 

## 运行时数据区域划分
1. 方法区（元空间） 
  线程共享区域，主要存储已被虚拟机加载的类信息，常量，静态变量，即时编译后的产物，也叫非堆（Non Heap）
  运行时常量池。
2. 虚拟机栈
  线程私有的，生命周期和线程相同，每个方法执行的同时都会创建一个栈帧（Stack Frame），用来存局部变量表，操作数栈，动态链接，方法出口等信息，
  局部变量表存放编译期可知的各种基本数据类型，每个局部变量空间（slot）为 32 位，64 为长度的类型占用两个 slot
3. 本地方法栈
  为 native 方法服务的
4. 堆
  最大的一块内存区域，也是线程共享的内存区域，几乎所有的对象都在这里分配内存。  
  这里也是垃圾回收的主要区域，因为分代搜集算法，所以堆还可细分为 新生代 和 老年代，新生代再细致一点有 eden，from survivor， to survivor，
5. 程序计数器
  可以看作是当前线程所执行的字节码行号指示器，线程私有的
6. 直接内存
  DirectByteBuffer 引用一块堆外内存


## 对象创建
普通对象创建（不包含数组，`Class` 对象）  

1. 类加载过程
  在常量池中是否定位一个类的符号引用
  类是否已被加载，解析，初始化
2. 新生对象分配内存
  对象所需的内存大小在类加载完成后就已经确定？
  分配内存的方式
    * 指针碰撞： 假设内存规整，由于对象所需内存大小已知，只需要记录边界指针，移动响应的大小就行类
    * 空闲列表： 内存不规整，那么就需要记录哪些空间是可用的，需要维护一个列表
  内存是否规整由采用的垃圾回收器决定。 Serial ， ParNew 等垃圾搜集完毕，会整理内存，因此是 指针碰撞   
  CMS 基于标记-清除，没有内存整理，因此是空闲列表     
  创建对象是非常频繁的操作，直接指针修改位置，是非线程安全的，有两种解决方式
   * CAS 失败重试，并发常用的模式
   * TLAB 本地线程分配缓冲，每个线程先预分配一小块内存，用完了，才需要同步锁定
  内存分配完毕后，会初始化零值，应该可以理解为所有位全部置 0
3. 对象设置
  例如，这个对象是哪个类的实例。如何找到类的元数据，对象哈希码，对象的 GC 分代年龄。这些信息放对象头中
4. init 方法
  从虚拟机角度，上面3个步骤后，对象就已经创建完了，但是还没执行 init 方法，也就是构造方法，当然，字段的初值也是在 init 方法里面执行

## 对象的内存布局
可以分为 3 个区域：对象头，实例数据，对齐填充 

*对象头*
包含两部分数据
1. 对象自身运行时数据：哈希码，GC 分代年龄，锁状态标志，线程持有的锁，偏向线程id，偏向时间戳等，在 64 为虚拟机中占 64 位，也就是常说的 Mark Word
2. 类型指针：指向类的元数据指针，并不是所有虚拟机实现都必须在对象上保留类型指针
3. 如果是数组，那么还有数组长度

32位 对象头内存布局  
{% asset_img JVM32-obj-header.png JVM 32位对象头内存布局 %}

64位 对象头内存布局
{% asset_img JVM32-obj-header.png JVM 64位对象头内存布局 %}

*实例数据*
各种类型的字段内容，包括父类继承的和自己的

*填充**
对象内存起始地址必须是 8 字节的整数倍，如果没对齐，就有对齐填充了

## 对象访问定位
Java 程序需要使用栈上的 reference 数据来操作具体的堆上的具体对象。  
reference 指向一个的对象的引用，有两种访问方式
1. 句柄：堆中单独划分一块内存，用来存句柄池，reference 指向句柄地址，句柄包含对象实例数据，类型数据的具体地址
2. 直接指针: reference 直接指向对象地址

句柄的好处是 referenc 存储稳定，对象移动（GC 影响）只修改 句柄到对象的指向。  
直接指针的好处就是速度快。  
`Hotspot` 采用的是 直接指针


## 内存溢出问题 OutOfMemoryError

*堆内存溢出*
堆内存大小设置以及内存溢出时候 dump，这几个 JVM 参数是常用的
```
设置最小堆内存
-Xms20m
设置最大堆内存
-Xmx20m
发生内存溢出的时候 dump，通常 JVM 用 -XX:+/- 来代表 true/false
-XX:+HeapDumpOnOutOfMemoryError
```

有来 dump 文件，可以使用 MAT 进行分析。查看哪个对象占用空间大，也可以查看泄露对象到 GC root 的引用链，分析为什么没有释放内存  


*虚拟机栈和本地方法栈*
栈空间大小设置
```
-Xss
-Xsx
```

栈空间，如果请求深度过大，会是 `StackOverflowError` , 也是栈溢出，通常在递归调用的时候容易出现
当虚拟机在扩展栈空间的时候，无法申请到足够的内存空间，则抛出 `OutOfMemoryError` 

*方法区/元空间*
这里导致溢出，通常是动态代理，或者字节码技术生成 class 过多导致的

*本机直接内存溢出**
由于 nio 可以申请使用堆外内存。 
堆外内存限制可以使用参 `-XX: MaxDirectMemorySize` 指定
由直接内存导致的内存溢出，一个明显的特征是 Heap Dump 文件中看不到明显的异常，Dump 文件也很小
