---
title: jvm 学习笔记
date: 2019-10-26 12:38:37
tags: [java,jvm]
categories: 技术笔记
---

`深入理解 java 虚拟机`  这本书看了也有几遍了，说实话，每次都是面试前看的（我也没面几次试) 
虽然每次看，感觉都可以多理解一点东西，但还是很虚。。先做个笔记，以后面试看笔记就行  

## 内存区域 
这个是面试但时候常问的，也是比较好理解的  
运行时数据区域分为  
1. 程序计数器  
  可以看作当前线程执行字节码的行号指示器，字节码在jvm内部是解释执行的（没 jit 之前）
2. java 虚拟机栈 
  也是线程私有的，每个方法创建一个栈帧，用于存储 局部变量表，操作数栈，动态链接，方法出口
  局部变量表存放编译器可知的各种基本数据类型，对象引用，变量表的空间按 slot 分配，一个 slot 4个字节
  当线程请求的栈深度大于虚拟机所允许的深度抛 StackOverflowError 栈溢出异常，如果是动态扩展栈空间的时候内存不足，则是 OOM 异常
3. 本地方法栈
  native 方法栈
4. java 堆
  这个是最需要关系的区域
  也是共享的一块内存区域，存放对象实例，也是 垃圾回收的主要区域
  堆还可以细分为 新生代 老年代，注意是为了方便 gc 可以通过 -Xmx -Xms 控制，这个两个是常用的控制最大最小堆内存空间的jvm参数
5. 方法区，也是元空间
  通常用于存储已经被虚拟机加载的 类信息，常量信息，静态变量，即使编译器后的代码，也叫 非堆 NonHeap ，也被称为永久代，通常这部分内容很难被回收掉，要回收的条件也比较严格
6. 直接内存
  也是对外内存，nio 的时候会用到


## 垃圾回收
垃圾回收其实可以分为两部分看，一个是怎么判断一个对象已经失效了，另一个才是实际回收内存操作  

**对象已死吗**
1. 引用计数 
  就算对象每被引用一次，就 + 1，释放就 -1 到0 到 0 到时候代表没用了 
  这是一个思路，jvm 内部不使用这种策略，在 netty 中，只用 pooled** 到内存池的时候使用的就是引用计数来判断的
2. 可达性分析
  这个是主流的方法，根据 GC Root 对象为起点，往下搜索，走过的路径代表引用链，不在引用链上的对象可以认为死对象
  那么哪些对象是在 GC Root 呢
  * 虚拟机栈中引用的对象
  * 方法区中类静态属性引用的变量
  * 方法区中常量引用的对象
  * 本地方法栈中 JNI 引用的对象
  这里面其实可以看到后期的一个优化，栈上分配，当方法执行完成后，对象就失效了，因此在方法内部分配的对象，生命周期是短暂的

**引用**
java 内部将引用分为4种
1. 强引用
  这也是最常见的，通常 new 出来的都是这种，只要强引用还在，垃圾回收器永远不会回收
2. 软引用
  提供 SoftReference 来实现软引用，在将要内存溢出的情况下，才去回收这块内存
3. 弱引用
  提供 WeakReference 来实现弱引用，下次 gc 的时候，就会回收这块内容
4. 虚引用
  PhantomReference 基本就只是在回收的时候获得一个通知 

**回收方法区**
由于在 jdk8 中，字符串常量池已经从方法区（元空间）移到堆了，这里说下类被回收（卸载）  
满足3个条件
1. 类的所有实例已经被回收
2. 类的 classloader 已经被回收
3. 类 class 对象没有被引用

就可以被回收了，注意是 可以，并不一定 

## 垃圾搜集算法
1. 标记清除
跟名字已有，分为两个过程，标记阶段，标记需要回收的对象，然后统一清除被标记的对象  
有两个问题，1. 标记和清除的效率不高 2. 会产生很多内存碎片

2. 复制算法
将内存分为2块相同的区域，先用一块，用完的时候，将还存活的对象复制到另一半，然后将之前使用过的内存区域一次性清除。 
问题也很大，内存缩小为原来的一半了

3. 标记整理
与标记清除类似，不过后续步骤不是清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界外的内存

4. 分代算法
就是将内存划分为几块区域，一般分为新生代和老年代，针对不同区域使用不同的垃圾回收算法

**枚举根节点**
GC Root 的节点主要在全局性的引用和执行上下文中。  
当在进行可达性分析的时候，需要 GC 停顿，不可以在分析过程中对象关系引用还在不断变化中。  

**安全点**
虚拟机将在特定位置记录协助 GC Root 枚举信息，这些位置称为 Sofapoint 安全点  

**安全区域**
安全区域是指在一段代码片段中国，引用关系不会发生变化

## 垃圾搜集器
新生代：Serial，ParNew，Parallel Scavenge
老年代：CMS，Serial Old，Parallel Old
全部：G1

**Serial**
这是一个单线程的搜集器，在进行垃圾搜集的时候需要进行暂停所有的工作线程。  
这是在 Client 模式下默认的垃圾搜集器    
能与老年代的 CMS，Serial Old 共用 

**ParNew**
其实就是 Serial 的多线程版本

**Parallel Scavenge**
目标是达到一个可控制的吞吐量，也就是 cpu 运行用户代码与 cpu 总消耗时间的比值  
停顿时间越短适合需要与用户交互的程序，高吞吐量则是高效率的利用 cpu 时间 

**Serial Old**
单线程搜集器，使用标记整理算法，也是给 client 模式的虚拟机用的

**Parallel Old**
多线程加标记整理算法

**CMS**
是一种以获取最短回收停顿时间为目标的搜集器  
使用标记清除算法。整个过程分为4个步骤：
1. 初始标记
2. 并发标记
3. 重新标记
4. 并发清除 
初始标记和重新标记需要 stop the world 
整个初始标记时间很短  
整个过程耗时最长的并发标记和并发清除过程，gc 线程可以和用户线程同时工作 
问题：
1. cpu 资源敏感，gc 会占用 cpu 资源
2. 无法清除浮动垃圾，也就是在并发清理过程中产生的垃圾要在下次 gc 清除
3. 标记清除，没做整理，可以设置参数

**G1**  
这个垃圾回收器与之前的都不一样内存划分不同，将堆划分为一个个 Region,默认 512k
在逻辑上连续，物理上不连续，同时每个 Regin 被标记为 E，S，O，H，分别表示 Eden，survivor，old，Humongous（大对象）
大于等于 region 一半大小的对象为 大对象，分配在老年代 

eden 出生的对象， 经过一次 Minor GC 还存活，如果 Survivor 还能容纳，就进入 Survivor，年龄设置为 1 
每在 Suvivor 熬过一次 Minor GC，年龄 +1，增加到一定程度 默认 15 晋升老年代。  

## 类加载过程
1. 加载
2. 链接
 * 验证
 * 准备
 * 解析
3. 初始化
## 加载
1. 取得类的二进制流
2. 转为方法区（元空间）的数据结构
3. 生成 class 对象
## 链接
### 验证
1. 文件格式正确
  * 是否已 0xCAFEBABE 开头
  * 版本号是否合理
  * 。。。
2. 元数据验证
  * 是否有父类
  * 继承了 final 类？
  * 非抽象实现了所有的抽象方法
  * 。。
3. 字节码验证（很复杂）
  * 运行检查
  * 栈数据类型和操作码数据参数吻合
  * 跳转指令到合理位置
  * 。。
4. 符号引用验证
  * 常量池中描述类是否存在
  * 访问的方法或字段是否存在且有足够的权限
  * 。。
### 准备
分配内存，并为类赋值初值
public static int v = 1
在 准备阶段 v 会被设置为 0
在初始化的<clinit> 中才会设置为1
对于 static final 类型，在准备阶段就会被赋值正确的值
public static int v = 1
### 解析
符号引用替换为直接引用
符号引用：字符串，引用对象不一定被加载
直接引用：指针或者地址便宜，引用对象一定在内存
## 初始化
* 执行类构造器 <clinit>
  - static 变量赋值语句
  - static {} 语句
* 子类的 <clinit> 调用前保证父类的 <clinit> 被调用
* <clinit> 是线程安全的

## 编译优化
一堆 JIT 优化，然鹅记不住 
1. 公共子表达式消除
2. 数组边界检查消除
3. 方法内联
4. 。。一大堆优化手段 

## 内存模型
java 内存模型主要用来屏蔽底层各种硬件和操作系统的差异，给java程序在各个平台都能达到一致的内存访问效果。 
以下指令是原子的：
1. lock
2. unlock
3. read
4. load
5. use
6. assign
7. store
8. write

要将一个变量从主内存复制到工作内存，需要 read + load  
将工作内存的变量写回主内存需要 store + write   
这上面两个是不可拆分使用的  
volatile 变量将保证可见性 

并发的3个关键特性
1. 原子性
2. 可见性
3. 有序性

几个先行发生原则，关注几个：
1. 单线程的代码顺序性
2. 加锁先于解锁
3. volatile 写先于读
4. 线程 start 先于每个动作
5. 所有操作先于线程终止
6. 线程中断限于被中断线程的代码检查中断事件发生
7. 对象的初始化完成先于终结（finalize）
8. a 先于 b，b先于 c 那么 a 先于 c  

无论是编译重排序还是cpu 的指令重排序，java 内存模型保证上面的先行发生原则。 
使用在适当的位置插入内存屏障来实现。  


好吧，上面基本就是一些提纲，没啥具体内容，主要是为了看到这些，想到需要了解的知识  
