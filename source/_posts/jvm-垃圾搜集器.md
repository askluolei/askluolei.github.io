---
title: jvm-垃圾搜集器
tags:
  - java
  - jvm
categories:
  - 技术笔记
date: 2019-11-26 00:08:15
---


垃圾回收需要考虑三件事  
1. 哪些内存需要回收
2. 什么时候回收
3. 如何回收

## 对象是否已死
1. 引用计数
2. 可达性分析

引用类型  
* 强引用  常用的，new 
* 软引用  将要发生内存溢出，会回收软引用
* 弱引用  下一次 gc 到来的时候回收
* 虚引用  不知道啥时候回收，只是为了获取通知

类卸载条件
* 类的所有实例已被回收
* 加载该类的 ClassLoader 已经被回收
* 类的 Class 对象没有被其他地方引用

## 垃圾搜集算法
1. 标记清除 Mark-Sweep
2. 复制算法
3. 标记整理 Mark-Compact
4. 分代收集算法 

1. 枚举根节点
  从 GCRoot 找引用链，不在链路上的就是垃圾了
2. 安全点
  SafePoint，在特定的位置，记录引用，就是安全点
3. 安全区域
  线程没在执行的情况，不会引起引用发生变化的区域，是安全区域

## 垃圾搜集器

* Young: Serial，ParNew，Parallel Scavenge，   G1
* Old: CMS, Serial Old, Parallel Old     G1

1. Serial 
  最基本的垃圾搜集器，是单线程的搜集器，在垃圾搜集的时候，需要停止其他工作线程
2. ParNew
  是 Serial 的多线程版本
3. Parallel Scavenge
  关注点在达到可控制的吞吐量。
  上面三个都是复制算法
4. Seril Old
  1 的老年代版本
5. Parallel Old
  Parallel Scavenge 的老年代版本，多线程和标记整理算法
6. CMS
  多线程+标记清除，工作分为 4 步
  1. 初始标记   stop the world   速度很快
  2. 并发标记
  3. 重新标记   stop the world
  4. 并发清除
  缺点：
  1. 会占用用户线程 CPU 资源
  2. 无法清除浮动垃圾 并发清理阶段产生的垃圾
  3. 会有空间碎片，如果过多，可能导致 Full GC
7. G1
  并发，分代搜集，空间整合，可预测的停顿
  基本和上面的不一样了，将真个内存区域划分为 Region ，Region 可以用来作为新生代，老年代，不需要空间连续
  步骤
  1. 初始标记  stop the world  时间很短
  2. 并发标记
  3. 最终标记
  4. 筛选回收

## 内存分配和回收策略
1. 优先在 Eden 分配
2. 当 Eden 没有足够的空间进行分配，将发起一次 Minor GC
3. 大对象直接进老年代，长字符串，数组
4. 长期存活多对象进老年代，对象在 Eden 出生经过一次 Minor GC，进入 Survivor 区，年龄为1，没熬过一次 Minor GC 年龄 + 1，到 15（默认），进老年代，例外：如果相同年龄占 survivor 一半以上，年龄大于等于这个年龄的，直接进老年代

*空间分配担保*
```
在发生 Minor GC 之前，检测
if 老年代 最大连续可用空间 > 新生代所有对象空间
  Minor GC
else if 允许担保是吧 && 老年代 最大连续可用空间 > 历次晋升到老年代的空间
  Minor GC
else 
  Full GC
```
空间分配担保，主要是为了减少 `Full GC`

