---
title: 四数之和
date: 2019-11-20 22:50:51
tags:
 - leetcode
 - 数组
categories: 
 - leetcode
---

## 问题
给定一个包含 `n` 个整数的数组 `nums` 和一个目标值 `target`，判断 nums 中是否存在四个元素 `a，b，c` 和 `d` ，使得 `a + b + c + d` 的值与 `target` 相等？找出所有满足条件且不重复的四元组。
*注意：*  
答案中不可以包含重复的四元组。

示例
```
给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
```

## 提交

### 思路1
暴力解法
```golang
func fourSum(nums []int, target int) [][]int {
	var result [][]int
	len := len(nums)
	if len < 4 {
		return result
  }
  // 先排序
	sort.Ints(nums);
	// 暴力解法
	for i := 0; i < len-3; i++ {
		for ;i!=0 && i < len - 3 && nums[i]==nums[i-1];i++{}
		for j := i + 1; j < len-2;j++ {
			for ;j!=i+1 && j < len-2&&nums[j]==nums[j-1];j++{}
			for k := j+1; k < len -1;k++ {
				for ; k != j+1 && k < len - 1&& nums[k]==nums[k-1];k++{}
				for l := k+1; l < len; l++ {
					sum := nums[i] + nums[j] + nums[k] + nums[l]
					if sum == target {
						result = append(result, []int{nums[i], nums[j], nums[k], nums[l]})
						break
					} else if sum > target{
						break
					}
				}
			}
		}
	}
	return result
}
```

### 思路二
基于上面的，结合 `a + b = target` 的双指针思路  
```golang
func fourSum(nums []int, target int) [][]int {
	var result [][]int
	len := len(nums)
	if len < 4 {
		return result
	}
	sort.Ints(nums)
	// 暴力解法扩展,内部使用 a + b = target 的双向指针解法
	for i := 0; i < len-3; i++ {
		for ; i != 0 && i < len-3 && nums[i] == nums[i-1]; i++ {
		}
		for j := i + 1; j < len-2; j++ {
			for ; j != i+1 && j < len-2 && nums[j] == nums[j-1]; j++ {
			}
			firstIndex := j + 1
			lastIndex := len - 1
			expect := target - nums[i] - nums[j]
			for firstIndex < lastIndex {
				first := nums[firstIndex]
				last := nums[lastIndex]
				sum := first + last
				if sum > expect {
					lastIndex--
					for ; firstIndex < lastIndex && nums[lastIndex] == nums[lastIndex+1]; lastIndex-- {
					}
				} else if sum < expect {
					firstIndex++
					for ; firstIndex < lastIndex && nums[firstIndex] == nums[firstIndex-1]; firstIndex++ {
					}
				} else {
					result = append(result, []int{nums[i], nums[j], first, last})
					lastIndex--
					for ; firstIndex < lastIndex && nums[lastIndex] == nums[lastIndex+1]; lastIndex-- {
					}
					firstIndex++
					for ; firstIndex < lastIndex && nums[firstIndex] == nums[firstIndex-1]; firstIndex++ {
					}
				}
			}
		}
	}
	return result
}
```
