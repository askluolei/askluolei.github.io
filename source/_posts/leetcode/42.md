---
title: 接雨水
date: 2019-12-08 11:32:59
tags:
 - leetcode
 - 数组
categories: 
 - leetcode
---

## 问题
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
{% asset_img 42.png This is an example image %}
上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。

*示例*
```
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```

## 提交

### 思路1
思路是依次判断 每个坐标 i 上，能装多少水  
判断的思路是  计算 坐标 i 左右两边的最大值 maxLeft maxRight ，根据破桶原理，选择其中较小的 min，  
如果 min > height[i] 那么 min - height[i] 就是该坐标能够装的水

时间复杂度为 O(n*n)

```golang
func trap(height []int) int {
	res := 0
	length := len(height)
	if length <= 2 {
		return res
	}
	// 思路是依次判断 每个坐标 i 上，能装多少水
	// 判断的思路是  计算 坐标 i 左右两边的最大值 maxLeft maxRight ，根据破桶原理，选择其中较小的 min，
	// 如果 min > height[i] 那么 min - height[i] 就是该坐标能够装的水
	for i:=1;i<length-1;i++ {
		maxLeft := 0
		for j:=i-1;j>=0;j--{
			if height[j] > maxLeft {
				maxLeft = height[j]
			}
		}
		maxRight := 0
		for j:=i+1;j<length;j++ {
			if height[j] > maxRight {
				maxRight = height[j]
			}
		}
		min := min(maxLeft, maxRight)
		if min > height[i] {
			res = res + (min - height[i])
		}
	}
	return res
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
```

### 思路2
动态规划
还是上面的思路，只不过不需要每次都重新计算 `maxLeft` `maxRight`    
```
maxLeft[i] = max(maxLeft[i-1], height[i-1])
maxRight[i] = max(maxRight[i+1], height[i+1]) 
```
我们可以先计算出来 maxLeftArr maxRightArr

```golang
func trap(height []int) int {
	res := 0
	length := len(height)
	if length <= 2 {
		return res
	}
	maxLeftArr := make([]int, length)
	maxRightArr := make([]int, length)
	for i:=1;i<length-1;i++{
		maxLeftArr[i] = max(maxLeftArr[i-1], height[i-1])
	}
	for i:= length-2; i>0;i-- {
		maxRightArr[i] = max(maxRightArr[i+1], height[i+1])
	}
	for i:=1;i<length-1;i++ {
		min := min(maxLeftArr[i], maxRightArr[i])
		if min > height[i] {
			res = res + (min - height[i])
		}
	}
	return res
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

### 思路3
双指针，从左右两边，找最高都
height[left-1], height[right+1]
哪边更高，就计算旁边坐标的灌水
`if height[left-1] < height[right+1]`
就计算 `height[left]` 的，否则计算 `height[right]` 的

```golang
func trap(height []int) int {
	res := 0
	length := len(height)
	if length <= 2 {
		return res
	}
	var maxLeft, maxRight int
	left := 1
	right := length-2
	for ;left <= right; {
		if height[left-1] < height[right+1] {
			maxLeft = max(height[left-1], maxLeft)
			if maxLeft > height[left] {
				res = res + (maxLeft - height[left])
			}
			left++
		} else {
			maxRight = max(maxRight, height[right+1])
			if maxRight > height[right] {
				res = res + (maxRight - height[right])
			}
			right--
		}
	}
	return res
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```
