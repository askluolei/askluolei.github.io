---
title: 最接近的三数之和
date: 2019-11-19 22:19:52
tags:
 - leetcode
 - 数组
categories: 
 - leetcode
---

## 问题
给定一个包括 `n` 个整数的数组 `nums` 和 一个目标值 `target`。找出 `nums` 中的三个整数，使得它们的和与 `target` 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
```
例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.

与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).

```

## 提交

### 思路1
最简单的肯定还是暴力解法，时间复杂度是 O(n * n * n) 
```golang
func threeSumClosest(nums []int, target int) int {
	minLen := math.MaxInt64
	result := 0
	len := len(nums)
	// 暴力解法
	for i := 0; i < len - 2; i++ {
		for j := i + 1; j < len - 1; j++ {
			for k := j + 1; k < len; k++ {
				sum := nums[i] + nums[j] + nums[k]
				abs := abs(sum, target)
				if abs == 0 {
					return sum
				} else if abs < minLen {
					minLen = abs
          result = sum
				}
			}
		}
	}
	return result
}

func abs(a, b int) int {
	if a > b {
		return a - b
	} else {
		return b - a
	}
}
```

### 思路2
还是像之前的题目，一样，先排序 O(n*logn) ，然后固定前面一位，然后前后指针寻找 O(n * n) ,总共 O(n * n),当然，里面还有一些细节可以优化。  
譬如说，类似二分之类的，目前还是一位一位寻找的  
```golang
func threeSumClosest(nums []int, target int) int {
	result := 0
	// 先排序
	sort.Ints(nums)

	minLen := math.MaxInt64
	len := len(nums)
	for i := 0; i < len - 2; i++ {
		first := i + 1
		last := len - 1
		for ; first < last; {
			sum := nums[i] + nums[first] + nums[last]
			if sum < target {
				abs := target - sum
				if abs < minLen {
					minLen = abs
					result = sum
				}
				first++
			} else if sum > target {
				abs := sum - target
				if abs < minLen {
					minLen = abs
					result = sum
				}
				last--
			} else {
				return sum
			}
		}
	}
	return result
}
```

