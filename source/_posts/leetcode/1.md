---
title: 两数之和
date: 2019-11-10 10:58:56
tags:
 - leetcode
 - 数组
categories: 
 - leetcode
---

## 问题
给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

*示例*
```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]

```

## 提交

最简单的思路就是两层 `for` 循环比较。时间复杂度 `n * n` 

```golang
func twoSum(nums []int, target int) []int {
	for i := 0; i < len(nums); i++ {
		first := nums[i]
		for j := i + 1; j < len(nums); j++ {
			second := nums[j]
			if target == first+second {
				return []int{i, j}
			}
		}
	}
	return []int{}
}
```

另一个思路，使用 `map` 遍历两次.    
```golang
func twoSum(nums []int, target int) []int {
  ints := make(map[int]int)
  
  // 第一遍 记录需要于谁配对，并记录坐标
	for i := 0; i < len(nums); i++ {
    first := nums[i]
    // key 是 expect  value 为 坐标
		ints[target-first] = i
  }
  // 第二遍 判断当前值是否为别人的预期 利用 map ，访问时间复杂度为 O(1)
	for i := 0; i < len(nums); i++ {
		second := nums[i]
    expect, ok := ints[second]
    // 注意，坐标不能为 自己
		if ok && i != expect {
			return []int{expect, i}
		}
	}
	return []int{}
}
```

基于上面的思路扩展，由于配对是相互的，因此可以边记录 `expect` 边判断是否满足条件    
只用一次遍历 
```golang
func twoSum(nums []int, target int) []int {
	ints := make(map[int]int)
	for i := 0; i < len(nums); i++ {
    first := nums[i]
    // 判断本值 是否为其他的配对值 ，如果是，就直接返回另
		if expect, ok := ints[first]; ok {
			return []int{expect, i}
		} else {
      // 如果不是，记录本值 预期的配对值，记录坐标
			ints[target-first] = i
		}
	}
	return []int{}
}
```
