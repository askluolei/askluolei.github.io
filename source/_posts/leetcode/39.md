---
title: 组合总和
date: 2019-12-01 22:33:35
tags:
 - leetcode
 - 数组
categories: 
 - leetcode
---

## 问题
给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 
*示例 1:*
```
输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
```
*示例 2:*
```
输入: candidates = [2,3,5], target = 8,
所求解集为:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
```

## 提交
先排序，用来剔除重复的结果  
譬如 `candidates = [2, 3, 7], target = 18`  
思路就是从 `18 - 2` `18 - 3` `18 - 7` ，然后递归调用。  

```golang
func combinationSum(candidates []int, target int) [][]int {
	// 可以重复使用列表里面的数
	// 结果不能重复
	var res [][]int
	n := len(candidates)
	if n != 0 {
		// n*logn
		sort.Ints(candidates)
		findByCanditates(0, target, candidates, []int{}, &res)
	}
	return res
}
func findByCanditates(i, target int, nums []int, candidates []int, res *[][]int)  {
  // 结果在这里
	if target == 0 {
		*res = append(*res, candidates)
		return
  }
  // 截止情况
	if i == len(nums) || target < nums[i] {
		return
	}
	// 问题在这里，如果直接对 candidates 进行修改，这里是 go 这里是引用传参，会导致其他地方都会有问题
	// 因此，新建一个 slice 然后 copy，但是，copy 对时候，注意 newCandidate 对初始长度与 candidates 一样，否则多出来对会为0，如果少了，它也不自动扩容
	// 因此这里使用 make 创建，而不是初始定义，初始定义为 nil，copy 没作用
	var newCandidate = make([]int, len(candidates))
	copy(newCandidate, candidates)
  newCandidate = append(newCandidate, nums[i])
  // 使用递归调用，来构建树，这里代表深度，尝试先用小的数累加，然后看看有没有结果
  findByCanditates(i, target - nums[i], nums, newCandidate, res)
  // 这里是广度，target 没变化，i + 1，代表，尝试往后面看，有没有用最少的数量组成结果
	findByCanditates(i+1, target, nums, candidates, res)
}
```
