---
title: 组合总和II
date: 2019-12-02 22:14:16
tags:
 - leetcode
 - 数组
categories: 
 - leetcode
---

## 问题
给定一个数组  `candidates`  和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用一次。

说明：

所有数字（包括目标数）都是正整数。
解集不能包含重复的组合。 
*示例 1:*
```
输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
```
*示例 2:*
```
输入: candidates = [2,5,2,1,2], target = 5,
所求解集为:
[
  [1,2,2],
  [5]
]
```

## 提交 
和之前的不同前提
1。 数组可能有重复数字
2。 不能重复使用数组里面的数字

还是之前的思路。之前的解法  
不同点在于，每次都是从 i+1 开始

```golang
func combinationSum2(candidates []int, target int) [][]int {
	// 和之前的不同前提
	// 1。 数组可能有重复数字
	// 2。 不能重复使用数组里面的数字
	var res [][]int
	n := len(candidates)
	if n != 0 {
		// n*logn
		sort.Ints(candidates)
		findByCanditates2(0, target, candidates, []int{}, &res)
	}
	return res
}
func findByCanditates2(i, target int, nums []int, candidates []int, res *[][]int)  {
	if target == 0 {
		*res = append(*res, candidates)
		return
	}
	if i >= len(nums) || target < nums[i] {
		return
	}
	// 问题在这里，如果直接对 candidates 进行修改，这里是 go 这里是引用传参，会导致其他地方都会有问题
	// 因此，新建一个 slice 然后 copy，但是，copy 对时候，注意 newCandidate 对初始长度与 candidates 一样，否则多出来对会为0，如果少了，它也不自动扩容
	// 因此这里使用 make 创建，而不是初始定义，初始定义为 nil，copy 没作用
	var newCandidate = make([]int, len(candidates))
	copy(newCandidate, candidates)
  newCandidate = append(newCandidate, nums[i])
  
  // 不同点1:  i+1 开始
	findByCanditates2(i+1, target - nums[i], nums, newCandidate, res)

	length := len(nums)
  var j = i + 1
  // 不同点2: 跳过同样的数字
	for ;j < length && nums[j] == nums[j-1]; j++ {}
	findByCanditates2(j, target, nums, candidates, res)
}
```
