---
title: 下一个排列
date: 2019-11-24 23:46:39
tags:
 - leetcode
 - 数组
categories: 
 - leetcode
---

## 问题
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须*原地*修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。

```
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
```


## 提交
首先要理解题目意思，什么是下一个序列，最小序列，最大序列  
`1,2,3`  可以看做数字 `123` 那么使用 `1,2,3` 数字组合的下一个序列是 `1,3,2` 其实就是 `1,2,3` 三个数字排列组合后，当前排列的更大的一个排列。   什么时候最小呢？升序的时候，就是 `123` 什么时候最大呢 ？ 降序的时候 `321` 。  
来一个更普通的例子 `1,5,8,4,7,5,3,1` ,它的下一个序列是什么呢？ `1,5,8,5,1,3,4,7`  
我们直接看换的思路是什么？首先降序排列是最大的，同样适用于局部，这里的分界是 `4,7`,我们只要将 `4` 替换为 `5`(刚好比 `4` 大的) 后面的变成升序（最小）就行了。    
具体到思路  
1. 找到 `a[i] <= a[i + 1]`
2. 在 `i` 的右侧，找到刚好大于 `a[i]` 的数 `a[j]`
3. 交互 `a[i], a[j]`
4. 从 `i + 1` 开始，后面的数变成降序

大体思路就是上面的，当然，基于这个思路还可以有一些细节优化

```golang
func nextPermutation(nums []int)  {
	i := len(nums) - 2
	for ; i >= 0 && nums[i + 1] <= nums[i]; i--{}
	if i >= 0 {
		j := len(nums) - 1
		for ; j >= 0 && nums[j] <= nums[i]; j--{}
		swap(nums, i, j)
	}
	reverse(nums, i + 1)
}

func reverse(nums []int, start int) {
	i := start
	j := len(nums) - 1
	for ; i < j ; {
		swap(nums, i, j)
		i++
		j--
	}
}

func swap(nums []int, i, j int) {
	temp := nums[i]
	nums[i] = nums[j]
	nums[j] = temp
}

```
