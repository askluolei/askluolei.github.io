---
title: 缺失的第一个正数
date: 2019-12-04 21:58:25
tags:
 - leetcode
 - 数组
categories: 
 - leetcode
---

## 问题
给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

*示例 1:*
```
输入: [1,2,0]
输出: 3
```
*示例 2:*
```
输入: [3,4,-1,1]
输出: 2
```
*示例 3:*
```
输入: [7,8,9,11,12]
输出: 1
```
*说明:*
你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。

## 提交

### 思路1
不考虑空间限制，使用 `map` 记录出现的数字
```golang
func firstMissingPositive(nums []int) int {
	// 空间换时间，暴力解法
	m := make(map[int]bool)
	for _, num := range nums {
		m[num] = true
	}
	n := len(nums) + 1
	for i:=1;i<n;i++ {
		_, ok := m[i]
		if !ok {
			return i
		}
	}
	return n
}
```

### 思路2
还是上面的思路，不过，依据结果肯定在 `(0,n]` 之间,因此可以使用一个数组来记录  
```golang
func firstMissingPositive(nums []int) int {
	// 使用数组 结果只可能是 (0, len+1] 中间，因此，构建一个数组，坐标元素相同
	length := len(nums)
	m := make([]int, length + 1)
	for _, num := range nums {
		if num>0 && num <= length {
			m[num] = num
		}
	}
	// 不相同的，代表不存在，直接取结果了
	for i:=1;i<=length;i++ {
		if m[i] != i {
			return i
		}
	}
	return length + 1
}
```

### 思路3
上面两个解法空间都不满足要求，题目要求常量级别空间，基本就断定，只能在原数组都基础上修改来。还是利用结果在 `(0,n]`, 剔除掉不在范围内都。都使用 `1` 来填充,上面思路2，我们使用 `a[i] = i + 1` 来表示出现来数字 `i`,现在，使用取负数，来表示出现过 `i`.   
为啥取负数，因为，当我们有 `a = nums[i]` 在范围 `(0,n]` ， 我们需要记录 `nums[a]` .如何记录，上面思路2，是等于 i + 1.但是，这样就修改来原有都数字来，我们需要保留这个数字，因此取负数

```golang
func firstMissingPositive(nums []int) int {
	length := len(nums)

	has1 := 0
	for i:=0;i<length;i++ {
		if nums[i]==1 {
			has1++
			break
		}
	}
	if has1 == 0 {
		return 1
	}
	if length == 1 {
		return 2
	}

	for i:=0; i < length;i++ {
		if nums[i] <= 0 || nums[i] > length {
			nums[i]=1
		}
	}

	for i:=0; i<length;i++{
		a := abs(nums[i])
		if a == length {
			nums[0] = - abs(nums[0])
		} else {
			nums[a] = - abs(nums[a])
		}
	}

	for i:=1;i<length;i++ {
		if nums[i] > 0 {
			return i
		}
	}

	if nums[0] > 0 {
		return length
	}

	return length + 1
}

func abs(a int) int {
	if a < 0 {
		return -a
	}
	return a
}

```
