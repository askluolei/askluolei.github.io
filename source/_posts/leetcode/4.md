---
title: 寻找两个有序数组的中位数
date: 2019-11-16 23:53:47
tags:
 - leetcode
 - 数组
categories: 
 - leetcode
---

## 问题
给定两个大小为 m 和 n 的 *有序* 数组 `nums1` 和 `nums2`。
请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 `O(log(m + n))`。  

*示例1*
```
nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
```

*示例2*
```
nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5
```

## 提交

### 思路1 
先不管时间复杂度，先求出结果，最简单的就是先排好序，然后取中间值，由于是两个有序数组，排序只需要 `O(m + n)` 

```golang
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
  // 简单的方法，合并两个有序数组，取中位数，不过不满足题目要求，时间复杂度 O（m + n）
	mergeArr := []int{}
	var i, j int
	for ;i < len(nums1) && j < len(nums2); {
		first := nums1[i]
		second := nums2[j]
		if first < second {
			mergeArr = append(mergeArr, first)
			i++
		} else if first > second {
			mergeArr = append(mergeArr, second)
			j++
		} else {
			mergeArr = append(mergeArr, first)
			mergeArr = append(mergeArr, second)
			i++
			j++
		}
	}
	for ; i < len(nums1); i++ {
		mergeArr = append(mergeArr, nums1[i])
	}
	for ; j < len(nums2); j++ {
		mergeArr = append(mergeArr, nums2[j])
	}
	len := len(mergeArr)
	if len % 2 == 0 {
		mid := mergeArr[len/2 - 1] + mergeArr[len/2]
		return float64(mid) / 2
	} else {
		return float64(mergeArr[len / 2])
	}
}
```

### 思路2 
是基于思路1的扩展，我们的目的是找到中位数，也就是第 k 位，不需要排序  
```golang
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
  // 基于上面都方法，我们不需要合并，只是找出中位数就可以了，时间复杂度 O（m + n）
	aLen := len(nums1)
	bLen := len(nums2)
	len := aLen + bLen
	var i, j, left, right int

	for index := 0; index <= len / 2; index++ {
		left = right
		if i < aLen && (j >= bLen || nums1[i] < nums2[j]) {
			right = nums1[i]
			i++
		} else {
			right = nums2[j]
			j++
		}
	}
	if len & 1 == 0 {
		return (float64(left) + float64(right)) / 2
	} else {
		return float64(right)
	}
}
```

下面两个看的题解。。

### 思路3
上面两个的数据复杂度都不满足题目要求。  
看到 `log` 都时间复杂度，应该就要想到 `二分法`,还是上面都思路，思路2，是一位一位排除的。  
如果我们取第 K 位，那么，我们可以在两个数组里面各自取 k/2位，比较大小后，就可以直接排除掉 k/2了 
当然，里面有特例情况，k/2 长度超过了数组 len，那么就取最后一位就行了  
如果其中一个数组空了，那么也好处理,直接取剩余数组的中位数就行了
```golang
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
	// 上面两个解法都不满足题目要求，log（m + n） 基本确定需要二分法
	// 根据上一个思路，我们是要在排序好第数组里面，找到第 k 个数，如果是一个数组，那么好说，直接二分查找
	// 但是上面是两个数组，我们也可以借鉴一些思路
	// 譬如，我们要找第 k 个数，那么，同时在两个数组找 k/2 ，如果这个长度大于数组长度，取最后一个
	// 比较两个数组里面找的值，谁小，就相当于把 前面的都剔除掉了

	n := len(nums1)
	m := len(nums2)
	left := (n + m + 1) / 2;
	right := (n + m + 2) / 2;
	//将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。
	v1 := findMid(&nums1, 0, n - 1, &nums2, 0, m - 1, left)
	v2 := findMid(&nums1, 0, n - 1, &nums2, 0, m - 1, right)
	return (float64(v1) + float64(v2)) / 2
}


func findMid(nums1 *[]int, start1, end1 int, nums2 *[]int, start2, end2 int, k int) int {
	len1 := end1 - start1 + 1;
	len2 := end2 - start2 + 1;
	// 	确保 nums 先遍历完
	if len1 > len2 {
		return findMid(nums2, start2, end2, nums1, start1, end1, k)
	}
	// 当 num1 遍历完，其实就是在 nums2 里面找 第 k 个数
	if len1 == 0 {
		return (*nums2)[start2 + k - 1]
	}

	// 找 第 1 个
	if k == 1 {
		return min((*nums1)[start1], (*nums2)[start2])
	}

	// 取每个数组第 k/2 位数，如果 len 小于 k/2 那就是最后一个数
	i := start1 + min(len1, k / 2) - 1;
	j := start2 + min(len2, k / 2) - 1;

	// 排除掉小的
	if (*nums1)[i] > (*nums2)[j] {
		return findMid(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));
	} else {
		return findMid(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1));
	}

}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
```

### 思路4 
什么是中位数，就是一个集合里面，比它小的数量和比它大的数量相同。  
其实刚看到这题，最想当然的想法就是，取两个数组的中位数，然后平均。。。  
这想法当然是有问题的，但是思路是木有问题的。首先，满足两边的数量相同，但是没满足大小的比较  
用图形化的想法，我们将两个数组各自劈成两半，左边是一组，右边是一组，始终保证这个条件下，想办法满足大小条件。  
怎么满足呢？假设 数组1 的分割位是 i ，数组2 的分割位是 j，只要 i+1 ，j-1 ，这样就可以满足数量不变，去尝试满足大小条件 
反过来 i-1， j+1 。那么怎么去满足大小关系？左边的最大值 `<=` 右边的最小值就行了   
假设数组1 为 A ，数组2 为 B ，那么，只涉及到4位数的比较 `A[i - 1], A[i], B[j - 1], B[j]`    
又因为 A，B 是有序的，我们只需要比较 `A[i-1] <= B[j]  B[j-1] <= A[i]` 就行了.   
然后就是边界条件，具体的可以去看题解  
```golang
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
	m := len(nums1)
	n := len(nums2)

	// 保证 m <= n
	if m > n {
		return findMedianSortedArrays(nums2, nums1)
	}

	iMin := 0
	iMax := m

	for ;iMin <= iMax; {
		i := (iMin + iMax) / 2
		j := (m + n + 1)/ 2 - i

		if j != 0 && i != m && nums2[j-1] > nums1[i] { // i 需要增大
			iMin = i + 1
		} else if i != 0 && j != n && nums1[i-1] > nums2[j] { // i 需要减小
			iMax = i - 1
		} else { // 达到要求，并且将边界条件列出来单独考虑
			maxLeft := 0
			if i == 0 {
				maxLeft = nums2[j-1]
			} else if j == 0 {
				maxLeft = nums1[i-1]
			} else {
				maxLeft = max(nums1[i-1], nums2[j-1])
			}
			// 奇数的话，就不需要考虑右半部分了
			if (m + n) % 2 == 1 {
				return float64(maxLeft)
			}

			minRight := 0
			if i == m {
				minRight = nums2[j]
			} else if j == n {
				minRight = nums1[i]
			} else {
				minRight = min(nums1[i], nums2[j])
			}

			return (float64(maxLeft) + float64(minRight)) / 2
		}

	}


	return 0
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}
```

