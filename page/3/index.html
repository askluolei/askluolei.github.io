<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="Askluolei" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
<meta name="keywords" content="java, js, vue, go, 读书, 笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="Askluolei">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;3&#x2F;index.html">
<meta property="og:site_name" content="Askluolei">
<meta property="og:description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Askluolei</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Askluolei</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">个人的学习吐槽网站</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/askluolei" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/14/spring-cloud-openFeign-%E7%A0%94%E7%A9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/14/spring-cloud-openFeign-%E7%A0%94%E7%A9%B6/" class="post-title-link" itemprop="url">spring-cloud-openFeign 研究</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-14 20:12:41" itemprop="dateCreated datePublished" datetime="2019-10-14T20:12:41+08:00">2019-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-22 11:26:07" itemprop="dateModified" datetime="2019-11-22T11:26:07+08:00">2019-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是一篇简单的，<code>openFeign</code> 的源码分析<br>会涉及到 <code>ribbon</code> <code>Hystrix</code><br>不过其中 openFeign 的内容比较简单，其实核心难度在 <code>Hystrix</code>,这个以后有时间看<br>先上一张图。画的很挫。也算是分析思路吧。。  </p>
<img src="/2019/10/14/spring-cloud-openFeign-%E7%A0%94%E7%A9%B6/feign%E5%88%86%E6%9E%90.svg" class="" title="This is an example image">  
<p>主要是从代理构建和方法调用两条线进行分析，下面基本都是代码了  </p>
<p>spring-boot 版本 2.1.5.RELEASE<br>spring-cloud 版本 Greenwich.SR1<br>官方示例很简单<br>配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心就是 @EnableFeignClients 注解，这也是配置入口，我们等会从这里开始看<br>使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"stores"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StoreClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(method = RequestMethod.GET, value = <span class="string">"/stores"</span>)</span><br><span class="line">    <span class="function">List&lt;Store&gt; <span class="title">getStores</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(method = RequestMethod.POST, value = <span class="string">"/stores/&#123;storeId&#125;"</span>, consumes = <span class="string">"application/json"</span>)</span><br><span class="line">    <span class="function">Store <span class="title">update</span><span class="params">(@PathVariable(<span class="string">"storeId"</span>)</span> Long storeId, Store store)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心是 @FeignClient 注解<br>方法里面就是 spring-mvc 里面的注解了</p>
<p>首先来看配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(FeignClientsRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableFeignClients</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Alias for the &#123;<span class="doctag">@link</span> #basePackages()&#125; attribute. Allows for more concise annotation</span></span><br><span class="line"><span class="comment">    * declarations e.g.: &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>("org.my.pkg")&#125; instead of</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>(basePackages="org.my.pkg")&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the array of 'basePackages'.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Base packages to scan for annotated components.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #value()&#125; is an alias for (and mutually exclusive with) this attribute.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Use &#123;<span class="doctag">@link</span> #basePackageClasses()&#125; for a type-safe alternative to String-based</span></span><br><span class="line"><span class="comment">    * package names.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the array of 'basePackages'.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Type-safe alternative to &#123;<span class="doctag">@link</span> #basePackages()&#125; for specifying the packages to</span></span><br><span class="line"><span class="comment">    * scan for annotated components. The package of each class specified will be scanned.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Consider creating a special no-op marker class or interface in each package that</span></span><br><span class="line"><span class="comment">    * serves no purpose other than being referenced by this attribute.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the array of 'basePackageClasses'.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A custom &lt;code&gt;<span class="doctag">@Configuration</span>&lt;/code&gt; for all feign clients. Can contain override</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;<span class="doctag">@Bean</span>&lt;/code&gt; definition for the pieces that make up the client, for instance</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> feign.codec.Decoder&#125;, &#123;<span class="doctag">@link</span> feign.codec.Encoder&#125;, &#123;<span class="doctag">@link</span> feign.Contract&#125;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> FeignClientsConfiguration for the defaults</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> list of default configurations</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   Class&lt;?&gt;[] defaultConfiguration() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * List of classes annotated with <span class="doctag">@FeignClient</span>. If not empty, disables classpath</span></span><br><span class="line"><span class="comment">    * scanning.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> list of FeignClient classes</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   Class&lt;?&gt;[] clients() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面最核心的一行就是 @Import(FeignClientsRegistrar.class)<br>注解里面的属性，都是特殊的配置，具体的含义，我们后面继续看<br>接下面看看 FeignClientsRegistrar 的处理，这是跟 spring 集成的关键，所有基于 spring-boot 的，只要有类似这样的注解，都是这样看的，如果没有注解，那就看 META-INF/spring.factory 文件里面的自动配置<br>核心方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   registerDefaultConfiguration(metadata, registry);</span><br><span class="line">   registerFeignClients(metadata, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要做两件事，注册对应的 配置类 为 bean 注册 client 为 bean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDefaultConfiguration</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   Map&lt;String, Object&gt; defaultAttrs = metadata</span><br><span class="line">         .getAnnotationAttributes(EnableFeignClients<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (defaultAttrs != <span class="keyword">null</span> &amp;&amp; defaultAttrs.containsKey(<span class="string">"defaultConfiguration"</span>)) &#123;</span><br><span class="line">      String name;</span><br><span class="line">      <span class="keyword">if</span> (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">         name = <span class="string">"default."</span> + metadata.getEnclosingClassName();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         name = <span class="string">"default."</span> + metadata.getClassName();</span><br><span class="line">      &#125;</span><br><span class="line">      registerClientConfiguration(registry, name,</span><br><span class="line">            defaultAttrs.get(<span class="string">"defaultConfiguration"</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就是注册全局默认配置，可以看到，从 EnableFeignClients 获取了 defaultConfiguration 属性，默认是空的<br>如果有，就可以注册全局默认配置，至于这个配置有什么用，可以配置什么，后面看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerClientConfiguration</span><span class="params">(BeanDefinitionRegistry registry, Object name,</span></span></span><br><span class="line"><span class="function"><span class="params">      Object configuration)</span> </span>&#123;</span><br><span class="line">   BeanDefinitionBuilder builder = BeanDefinitionBuilder</span><br><span class="line">         .genericBeanDefinition(FeignClientSpecification<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   builder.addConstructorArgValue(name);</span><br><span class="line">   builder.addConstructorArgValue(configuration);</span><br><span class="line">   registry.registerBeanDefinition(</span><br><span class="line">         name + <span class="string">"."</span> + FeignClientSpecification<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>(),</span></span><br><span class="line"><span class="class">         <span class="title">builder</span>.<span class="title">getBeanDefinition</span>())</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里很明确，就是注册 配置 bean ，目前默认配置，和每个 client 的单独配置都是通过这个方法注册的<br>可以看到具体的 bean 是 FeignClientSpecification 将 name 和自定义配置 当做构造参数传进去了<br>后面详细看看 FeignClientSpecification<br>继续看注册 client</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFeignClients</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 这是一个基础扫描类，过滤条件是 独立类（非内部类），非注解</span></span><br><span class="line">   ClassPathScanningCandidateComponentProvider scanner = getScanner();</span><br><span class="line">   scanner.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">   Set&lt;String&gt; basePackages;</span><br><span class="line"></span><br><span class="line">   Map&lt;String, Object&gt; attrs = metadata</span><br><span class="line">         .getAnnotationAttributes(EnableFeignClients<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">   <span class="comment">// 这里看到，处理 client 的注解 @FeignClient</span></span><br><span class="line">   AnnotationTypeFilter annotationTypeFilter = <span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">         FeignClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="keyword">final</span> Class&lt;?&gt;[] clients = attrs == <span class="keyword">null</span> ? <span class="keyword">null</span></span><br><span class="line">         : (Class&lt;?&gt;[]) attrs.get(<span class="string">"clients"</span>);</span><br><span class="line">   <span class="comment">// 这里是对 @EnableFeignClients 注解的 clients 属性支持，可以直接指定有 @FeignClient 注释的接口</span></span><br><span class="line">   <span class="keyword">if</span> (clients == <span class="keyword">null</span> || clients.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 默认是空的，也就是走正常的类扫描</span></span><br><span class="line">      scanner.addIncludeFilter(annotationTypeFilter);</span><br><span class="line">      <span class="comment">// 获取要扫描的包，从注解 @EnableFeignClients 读取 value  basePackages  basePackageClasses 所在的包</span></span><br><span class="line">      <span class="comment">// 如果上面没获取到（默认都是空的），就扫描 @EnableFeignClients 注解标记的类所在的包</span></span><br><span class="line">      basePackages = getBasePackages(metadata);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果自己直接指定了 client ，那么只取指定的</span></span><br><span class="line">      <span class="keyword">final</span> Set&lt;String&gt; clientClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      basePackages = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; clazz : clients) &#123;</span><br><span class="line">         basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">         clientClasses.add(clazz.getCanonicalName());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 也需要走过滤</span></span><br><span class="line">      AbstractClassTestingTypeFilter filter = <span class="keyword">new</span> AbstractClassTestingTypeFilter() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(ClassMetadata metadata)</span> </span>&#123;</span><br><span class="line">            String cleaned = metadata.getClassName().replaceAll(<span class="string">"\\$"</span>, <span class="string">"."</span>);</span><br><span class="line">            <span class="keyword">return</span> clientClasses.contains(cleaned);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      scanner.addIncludeFilter(</span><br><span class="line">            <span class="keyword">new</span> AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 扫描，是 spirng 的工具类，细节不看</span></span><br><span class="line">   <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">      Set&lt;BeanDefinition&gt; candidateComponents = scanner</span><br><span class="line">            .findCandidateComponents(basePackage);</span><br><span class="line">      <span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">         <span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">            <span class="comment">// verify annotated class is an interface</span></span><br><span class="line">            AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">            AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();</span><br><span class="line">            <span class="comment">// client 只能是接口</span></span><br><span class="line">            Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line">                  <span class="string">"@FeignClient can only be specified on an interface"</span>);</span><br><span class="line">            <span class="comment">// 获取 @FeignClient 注解的熟悉</span></span><br><span class="line">            Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">                  .getAnnotationAttributes(</span><br><span class="line">                        FeignClient<span class="class">.<span class="keyword">class</span>.<span class="title">getCanonicalName</span>())</span>;</span><br><span class="line">            <span class="comment">// 获取 name，就是 @FeignClient 里面的熟悉  contextId  value  name  serviceId  按照顺序获取</span></span><br><span class="line">            String name = getClientName(attributes);</span><br><span class="line">            <span class="comment">// 注册 client 对应的 config ，可以 @FeignClient 配置自定义的 configuration ，默认是空</span></span><br><span class="line">            registerClientConfiguration(registry, name,</span><br><span class="line">                  attributes.get(<span class="string">"configuration"</span>));</span><br><span class="line">            <span class="comment">// 注册 client bean</span></span><br><span class="line">            registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面都加了注释了，看看注册 client 的 bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerFeignClient</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">      AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">   String className = annotationMetadata.getClassName();</span><br><span class="line">   <span class="comment">// 注意这里的 factoryBean  FeignClientFactoryBean</span></span><br><span class="line">   BeanDefinitionBuilder definition = BeanDefinitionBuilder</span><br><span class="line">         .genericBeanDefinition(FeignClientFactoryBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   validate(attributes);</span><br><span class="line">   <span class="comment">// url 默认是空，这里应该是直连时候指定url</span></span><br><span class="line">   definition.addPropertyValue(<span class="string">"url"</span>, getUrl(attributes));</span><br><span class="line">   <span class="comment">// path 是 basePath</span></span><br><span class="line">   definition.addPropertyValue(<span class="string">"path"</span>, getPath(attributes));</span><br><span class="line">   <span class="comment">// 这里 name 的获取顺序是 serviceId  name value   支持 placeholder 也就是 $&#123;&#125;</span></span><br><span class="line">   String name = getName(attributes);</span><br><span class="line">   definition.addPropertyValue(<span class="string">"name"</span>, name);</span><br><span class="line">   <span class="comment">// 取 contextId ，如果为空，那就用 getName 获取，也就是上面的 name 默认是一样的</span></span><br><span class="line">   String contextId = getContextId(attributes);</span><br><span class="line">   definition.addPropertyValue(<span class="string">"contextId"</span>, contextId);</span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">   definition.addPropertyValue(<span class="string">"type"</span>, className);</span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">   definition.addPropertyValue(<span class="string">"decode404"</span>, attributes.get(<span class="string">"decode404"</span>));</span><br><span class="line">   <span class="comment">// 容错类</span></span><br><span class="line">   definition.addPropertyValue(<span class="string">"fallback"</span>, attributes.get(<span class="string">"fallback"</span>));</span><br><span class="line">   <span class="comment">// 容错工程类</span></span><br><span class="line">   definition.addPropertyValue(<span class="string">"fallbackFactory"</span>, attributes.get(<span class="string">"fallbackFactory"</span>));</span><br><span class="line">   definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">   <span class="comment">// 可以看到，别名，默认就是 自己设置的 name + "FeignClient"</span></span><br><span class="line">   String alias = contextId + <span class="string">"FeignClient"</span>;</span><br><span class="line">   AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> primary = (Boolean) attributes.get(<span class="string">"primary"</span>); <span class="comment">// has a default, won't be</span></span><br><span class="line">                                             <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">   beanDefinition.setPrimary(primary);</span><br><span class="line">   <span class="comment">// 相当于自己设置别名</span></span><br><span class="line">   String qualifier = getQualifier(attributes);</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">      alias = qualifier;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, className,</span><br><span class="line">         <span class="keyword">new</span> String[] &#123; alias &#125;);</span><br><span class="line">   BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看注册的 配置类 FeignClientSpecification</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeignClientSpecification</span> <span class="keyword">implements</span> <span class="title">NamedContextFactory</span>.<span class="title">Specification</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Class&lt;?&gt;[] configuration;</span><br><span class="line"></span><br><span class="line">   FeignClientSpecification() &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   FeignClientSpecification(String name, Class&lt;?&gt;[] configuration) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Class&lt;?&gt;[] getConfiguration() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.configuration;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfiguration</span><span class="params">(Class&lt;?&gt;[] configuration)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      FeignClientSpecification that = (FeignClientSpecification) o;</span><br><span class="line">      <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.name, that.name)</span><br><span class="line">            &amp;&amp; Arrays.equals(<span class="keyword">this</span>.configuration, that.configuration);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Objects.hash(<span class="keyword">this</span>.name, <span class="keyword">this</span>.configuration);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(<span class="string">"FeignClientSpecification&#123;"</span>).append(<span class="string">"name='"</span>)</span><br><span class="line">            .append(<span class="keyword">this</span>.name).append(<span class="string">"', "</span>).append(<span class="string">"configuration="</span>)</span><br><span class="line">            .append(Arrays.toString(<span class="keyword">this</span>.configuration)).append(<span class="string">"&#125;"</span>).toString();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没啥看的，<br>再看看 client 的 FeignClientFactoryBean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> getTarget();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &lt;T&gt; the target type of the Feign client</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> Feign&#125; client created with the specified data and the context</span></span><br><span class="line"><span class="comment">* information</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// FeignContext 是在 autoconfiguration 的时候注册的</span></span><br><span class="line">   FeignContext context = <span class="keyword">this</span>.applicationContext.getBean(FeignContext<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="comment">// 配置分为三层，默认 - 全局 - 单个client 每个配置类实际上是一个 @Configuration 标记的 spring 配置类</span></span><br><span class="line">   <span class="comment">// context 内部为每个 client 都构建了一个 ApplicationContext parent 指向默认的 context</span></span><br><span class="line">   <span class="comment">// 里面配置类的解析顺序为 单个 - 全局 - 默认 构建内部的 bean</span></span><br><span class="line">   <span class="comment">// 这个方法里面，构建 Feign.Builder 设置 logger encoder decoder contract</span></span><br><span class="line">   <span class="comment">// 然后根据 FeignClientProperties 配置，设置 loggerLevel retryer errorDecoder request.options requestInterceptor decode404 配置</span></span><br><span class="line">   <span class="comment">// 如果自定义配置或者全局配置里面有 logger encoder decoder contract 这里也重新设置</span></span><br><span class="line">   Feign.Builder builder = feign(context);</span><br><span class="line">   <span class="comment">// 默认 url 是没有的</span></span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.name.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line">         <span class="keyword">this</span>.url = <span class="string">"http://"</span> + <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.url = <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.url += cleanPath();</span><br><span class="line">      <span class="comment">// so 大部分应该走这里</span></span><br><span class="line">      <span class="keyword">return</span> (T) loadBalance(builder, context,</span><br><span class="line">            <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type, <span class="keyword">this</span>.name, <span class="keyword">this</span>.url));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url) &amp;&amp; !<span class="keyword">this</span>.url.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.url = <span class="string">"http://"</span> + <span class="keyword">this</span>.url;</span><br><span class="line">   &#125;</span><br><span class="line">   String url = <span class="keyword">this</span>.url + cleanPath();</span><br><span class="line">   Client client = getOptional(context, Client<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// url 存在，代表直连，lodbalance 就不需要了</span></span><br><span class="line">      <span class="keyword">if</span> (client <span class="keyword">instanceof</span> LoadBalancerFeignClient) &#123;</span><br><span class="line">         <span class="comment">// not load balancing because we have a url,</span></span><br><span class="line">         <span class="comment">// but ribbon is on the classpath, so unwrap</span></span><br><span class="line">         client = ((LoadBalancerFeignClient) client).getDelegate();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取默认的 client</span></span><br><span class="line">      builder.client(client);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 构建</span></span><br><span class="line">   Targeter targeter = get(context, Targeter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="keyword">return</span> (T) targeter.target(<span class="keyword">this</span>, builder, context,</span><br><span class="line">         <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧，大概看了下里面的实现，这里其实是生成一个代理的过程，但是又与标准的动态代理不一样<br>构建过程在 builder 里面，之前的 logger encoder deocder contract 等是按照 client 实例配置  default 全局配置  默认配置 的 顺序启用的<br>client 的实例配置，就是在客户端接口注解 @FeignClient 配置的，default 全局配置，则是 @EnableFeignClients 注解里面配置的<br>至于默认配置，是基于 spring-boot 的自动配置 ，这里面也分情况，根据是否存在 ribbon ，有不同的注入配置<br>等会，突然发现上面三层配置，创建 context 的机制是 spring-cloud 里面的东西<br>先来看下基于 ribbon的自动配置，这里默认情况的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里 ILoadBalancer 是 ribbon 包里面的  Feign 就是 feign 了</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; ILoadBalancer<span class="class">.<span class="keyword">class</span>, <span class="title">Feign</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">Configuration</span></span></span><br><span class="line"><span class="class">// 这里，要在 <span class="title">feign</span> 默认配置之前先处理</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureBefore</span>(<span class="title">FeignAutoConfiguration</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">// 开启自定义参数配置</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(</span>&#123; FeignHttpClientProperties<span class="class">.<span class="keyword">class</span> &#125;)</span></span><br><span class="line"><span class="class">// <span class="title">Order</span> <span class="title">is</span> <span class="title">important</span> <span class="title">here</span>, <span class="title">last</span> <span class="title">should</span> <span class="title">be</span> <span class="title">the</span> <span class="title">default</span>, <span class="title">first</span> <span class="title">should</span> <span class="title">be</span> <span class="title">optional</span></span></span><br><span class="line"><span class="class">// <span class="title">see</span></span></span><br><span class="line">// https://github.com/spring-cloud/spring-cloud-netflix/issues/2086#issuecomment-316281653</span><br><span class="line"><span class="comment">// 上面有注释，顺序很重要，就是 FeignLoadBalanced 的自动配置</span></span><br><span class="line"><span class="meta">@Import</span>(&#123; HttpClientFeignLoadBalancedConfiguration<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">      <span class="title">OkHttpFeignLoadBalancedConfiguration</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">      <span class="title">DefaultFeignLoadBalancedConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">FeignRibbonClientAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@Primary</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingClass</span>(<span class="string">"org.springframework.retry.support.RetryTemplate"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> CachingSpringLoadBalancerFactory <span class="title">cachingLBClientFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         SpringClientFactory factory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> CachingSpringLoadBalancerFactory(factory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@Primary</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="meta">@ConditionalOnClass</span>(name = <span class="string">"org.springframework.retry.support.RetryTemplate"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> CachingSpringLoadBalancerFactory <span class="title">retryabeCachingLBClientFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         SpringClientFactory factory, LoadBalancedRetryFactory retryFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> CachingSpringLoadBalancerFactory(factory, retryFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="keyword">public</span> Request.<span class="function">Options <span class="title">feignRequestOptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> LoadBalancerFeignClient.DEFAULT_OPTIONS;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实所有的配置类，最后都会装配到 Feign.Builder 里面<br>在 builder 里面构造代理，直接进去看吧。<br>最终，构建代理的是接口 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Targeter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(FeignClientFactoryBean factory, Feign.Builder feign,</span></span></span><br><span class="line"><span class="function"><span class="params">         FeignContext context, Target.HardCodedTarget&lt;T&gt; target)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 feign 的默认实现是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultTargeter</span> <span class="keyword">implements</span> <span class="title">Targeter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(FeignClientFactoryBean factory, Feign.Builder feign,</span></span></span><br><span class="line"><span class="function"><span class="params">         FeignContext context, Target.HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> feign.target(target);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，直接调用了 builder 的 target 方法<br>还有另一个 实现，这个实现才是自动配置的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HystrixTargeter</span> <span class="keyword">implements</span> <span class="title">Targeter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(FeignClientFactoryBean factory, Feign.Builder feign,</span></span></span><br><span class="line"><span class="function"><span class="params">         FeignContext context, Target.HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!(feign <span class="keyword">instanceof</span> feign.hystrix.HystrixFeign.Builder)) &#123;</span><br><span class="line">         <span class="keyword">return</span> feign.target(target);</span><br><span class="line">      &#125;</span><br><span class="line">      feign.hystrix.HystrixFeign.Builder builder = (feign.hystrix.HystrixFeign.Builder) feign;</span><br><span class="line">      SetterFactory setterFactory = getOptional(factory.getName(), context,</span><br><span class="line">            SetterFactory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span> (setterFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">         builder.setterFactory(setterFactory);</span><br><span class="line">      &#125;</span><br><span class="line">      Class&lt;?&gt; fallback = factory.getFallback();</span><br><span class="line">      <span class="keyword">if</span> (fallback != <span class="keyword">void</span><span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> targetWithFallback(factory.getName(), context, target, builder,</span><br><span class="line">               fallback);</span><br><span class="line">      &#125;</span><br><span class="line">      Class&lt;?&gt; fallbackFactory = factory.getFallbackFactory();</span><br><span class="line">      <span class="keyword">if</span> (fallbackFactory != <span class="keyword">void</span><span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> targetWithFallbackFactory(factory.getName(), context, target, builder,</span><br><span class="line">               fallbackFactory);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> feign.target(target);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">targetWithFallbackFactory</span><span class="params">(String feignClientName, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">         Target.HardCodedTarget&lt;T&gt; target, HystrixFeign.Builder builder,</span></span></span><br><span class="line"><span class="function"><span class="params">         Class&lt;?&gt; fallbackFactoryClass)</span> </span>&#123;</span><br><span class="line">      FallbackFactory&lt;? extends T&gt; fallbackFactory = (FallbackFactory&lt;? extends T&gt;) getFromContext(</span><br><span class="line">            <span class="string">"fallbackFactory"</span>, feignClientName, context, fallbackFactoryClass,</span><br><span class="line">            FallbackFactory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">return</span> builder.target(target, fallbackFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">targetWithFallback</span><span class="params">(String feignClientName, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">         Target.HardCodedTarget&lt;T&gt; target, HystrixFeign.Builder builder,</span></span></span><br><span class="line"><span class="function"><span class="params">         Class&lt;?&gt; fallback)</span> </span>&#123;</span><br><span class="line">      T fallbackInstance = getFromContext(<span class="string">"fallback"</span>, feignClientName, context,</span><br><span class="line">            fallback, target.type());</span><br><span class="line">      <span class="keyword">return</span> builder.target(target, fallbackInstance);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">getFromContext</span><span class="params">(String fallbackMechanism, String feignClientName,</span></span></span><br><span class="line"><span class="function"><span class="params">         FeignContext context, Class&lt;?&gt; beanType, Class&lt;T&gt; targetType)</span> </span>&#123;</span><br><span class="line">      Object fallbackInstance = context.getInstance(feignClientName, beanType);</span><br><span class="line">      <span class="keyword">if</span> (fallbackInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(</span><br><span class="line">               <span class="string">"No "</span> + fallbackMechanism</span><br><span class="line">                     + <span class="string">" instance of type %s found for feign client %s"</span>,</span><br><span class="line">               beanType, feignClientName));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!targetType.isAssignableFrom(beanType)) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(<span class="string">"Incompatible "</span></span><br><span class="line">               + fallbackMechanism</span><br><span class="line">               + <span class="string">" instance. Fallback/fallbackFactory of type %s is not assignable to %s for feign client %s"</span>,</span><br><span class="line">               beanType, targetType, feignClientName));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (T) fallbackInstance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">getOptional</span><span class="params">(String feignClientName, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">         Class&lt;T&gt; beanType)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> context.getInstance(feignClientName, beanType);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，主要处理了 SetterFactory fallback fallbackFactory<br>将这几个配置设置在builder 里面后，调用 builder 的 target<br>默认先看默认的 builder 实现，  Hystrix 有熔断配置的实现是对默认 builder 做了一个扩展</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> build().newInstance(target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Feign <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里，构建这些对象，可以认为将配置分组到不同类</span></span><br><span class="line">  SynchronousMethodHandler.Factory synchronousMethodHandlerFactory =</span><br><span class="line">      <span class="keyword">new</span> SynchronousMethodHandler.Factory(client, retryer, requestInterceptors, logger,</span><br><span class="line">          logLevel, decode404, closeAfterDecode, propagationPolicy);</span><br><span class="line">  ParseHandlersByName handlersByName =</span><br><span class="line">      <span class="keyword">new</span> ParseHandlersByName(contract, options, encoder, decoder, queryMapEncoder,</span><br><span class="line">          errorDecoder, synchronousMethodHandlerFactory);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ReflectiveFeign(handlersByName, invocationHandlerFactory, queryMapEncoder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>build 方法就是把配置分组了，构建了一个 ReflectiveFeign<br>核心是里面的 newInstance 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 这里，解析 type 接口的方法</span></span><br><span class="line">  Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br><span class="line">  Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="keyword">new</span> LinkedHashMap&lt;Method, MethodHandler&gt;();</span><br><span class="line">  List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="keyword">new</span> LinkedList&lt;DefaultMethodHandler&gt;();</span><br><span class="line">  <span class="comment">// 下面是处理 默认方法和过滤掉 object 的方法</span></span><br><span class="line">  <span class="keyword">for</span> (Method method : target.type().getMethods()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isDefault(method)) &#123;</span><br><span class="line">      DefaultMethodHandler handler = <span class="keyword">new</span> DefaultMethodHandler(method);</span><br><span class="line">      defaultMethodHandlers.add(handler);</span><br><span class="line">      methodToHandler.put(method, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// jdk 动态代理的 InvocationHandler 实现，默认是  new ReflectiveFeign.FeignInvocationHandler(target, dispatch);</span></span><br><span class="line">  InvocationHandler handler = factory.create(target, methodToHandler);</span><br><span class="line">  T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(),</span><br><span class="line">      <span class="keyword">new</span> Class&lt;?&gt;[] &#123;target.type()&#125;, handler);</span><br><span class="line">  <span class="comment">// 默认方法绑定到代理对象</span></span><br><span class="line">  <span class="keyword">for</span> (DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">    defaultMethodHandler.bindTo(proxy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// so 返回的是一个 JDK 的动态代理对象</span></span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>so 继续看看 InvocationHandler handler = factory.create(target, methodToHandler); 创建的东西</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Target target;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MethodHandler&gt; dispatch;</span><br><span class="line"></span><br><span class="line">  FeignInvocationHandler(Target target, Map&lt;Method, MethodHandler&gt; dispatch) &#123;</span><br><span class="line">    <span class="keyword">this</span>.target = checkNotNull(target, <span class="string">"target"</span>);</span><br><span class="line">    <span class="keyword">this</span>.dispatch = checkNotNull(dispatch, <span class="string">"dispatch for %s"</span>, target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"equals"</span>.equals(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Object otherHandler =</span><br><span class="line">            args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="keyword">null</span> ? Proxy.getInvocationHandler(args[<span class="number">0</span>]) : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> equals(otherHandler);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"hashCode"</span>.equals(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">return</span> hashCode();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"toString"</span>.equals(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">return</span> toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dispatch.get(method).invoke(args);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>非常，简单，其实核心还是 apply 方法解析出来的 methodHandler </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, MethodHandler&gt; <span class="title">apply</span><span class="params">(Target key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里使用 Contract 解析相关接口</span></span><br><span class="line">    List&lt;MethodMetadata&gt; metadata = contract.parseAndValidatateMetadata(key.type());</span><br><span class="line">    Map&lt;String, MethodHandler&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;String, MethodHandler&gt;();</span><br><span class="line">    <span class="keyword">for</span> (MethodMetadata md : metadata) &#123;</span><br><span class="line">      <span class="comment">// 这个是根据参数构建 request 请求的解析类</span></span><br><span class="line">      BuildTemplateByResolvingArgs buildTemplate;</span><br><span class="line">      <span class="keyword">if</span> (!md.formParams().isEmpty() &amp;&amp; md.template().bodyTemplate() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        buildTemplate = <span class="keyword">new</span> BuildFormEncodedTemplateFromArgs(md, encoder, queryMapEncoder);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (md.bodyIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        buildTemplate = <span class="keyword">new</span> BuildEncodedTemplateFromArgs(md, encoder, queryMapEncoder);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buildTemplate = <span class="keyword">new</span> BuildTemplateByResolvingArgs(md, queryMapEncoder);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这里的 configKey 是 Feign.configKey 方法生成的 类 simpleName + methodName + 参数</span></span><br><span class="line">      <span class="comment">// factory 构建的是 SynchronousMethodHandler 实例 ，可以想象到，具体的调用逻辑就是在这里完成的</span></span><br><span class="line">      result.put(md.configKey(),</span><br><span class="line">          factory.create(key, md, buildTemplate, options, decoder, errorDecoder));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看具体调用的地方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 第一步 就是用 请求参数构建 RequestTemplate 具体有三种，后面详细看看看 BuildFormEncodedTemplateFromArgs  BuildEncodedTemplateFromArgs  BuildTemplateByResolvingArgs</span></span><br><span class="line">  RequestTemplate template = buildTemplateFromArgs.create(argv);</span><br><span class="line">  <span class="comment">// 重试 clone 就是将计数重置为 1</span></span><br><span class="line">  Retryer retryer = <span class="keyword">this</span>.retryer.clone();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 正常调用，如果 ok 就返回了</span></span><br><span class="line">      <span class="comment">// 这里是调用的核心逻辑</span></span><br><span class="line">      <span class="keyword">return</span> executeAndDecode(template);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RetryableException e) &#123;</span><br><span class="line">      <span class="comment">// 如果抛出的是 可重试异常</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 重试策略判断一下，如果不允许，就把异常抛出来，如果允许，内部可以记录一下，或者 等待一会再尝试</span></span><br><span class="line">        retryer.continueOrPropagate(e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RetryableException th) &#123;</span><br><span class="line">        <span class="comment">// 异常是否需要解开包装</span></span><br><span class="line">        Throwable cause = th.getCause();</span><br><span class="line">        <span class="keyword">if</span> (propagationPolicy == UNWRAP &amp;&amp; cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> cause;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> th;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">        logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，就可以详细看看具体的调用逻辑了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">executeAndDecode</span><span class="params">(RequestTemplate template)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 这里将请求封装为 request 内部首先经过 RequestInterceptor 处理  然后构建 request</span></span><br><span class="line">  Request request = targetRequest(template);</span><br><span class="line">  <span class="comment">// 请求日志</span></span><br><span class="line">  <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">    logger.logRequest(metadata.configKey(), logLevel, request);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Response response;</span><br><span class="line">  <span class="comment">// 记录请求时间</span></span><br><span class="line">  <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 Client 执行请求，带上 options 参数，options 也是可配置的，通常是连接超时时间之类的</span></span><br><span class="line">    <span class="comment">// 这里就是核心了，请求控制丢给 client 去了</span></span><br><span class="line">    response = client.execute(request, options);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// 异常日志</span></span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">      logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime(start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抛异常，这里是将异常包装为 可重试异常</span></span><br><span class="line">    <span class="keyword">throw</span> errorExecuting(request, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 正常结果</span></span><br><span class="line">  <span class="keyword">long</span> elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> shouldClose = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 响应日志</span></span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">      response =</span><br><span class="line">          logger.logAndRebufferResponse(metadata.configKey(), logLevel, response, elapsedTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return 类型就是 Response</span></span><br><span class="line">    <span class="keyword">if</span> (Response<span class="class">.<span class="keyword">class</span> </span>== metadata.returnType()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (response.body().length() == <span class="keyword">null</span> ||</span><br><span class="line">          response.body().length() &gt; MAX_RESPONSE_BUFFER_SIZE) &#123;</span><br><span class="line">        shouldClose = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Ensure the response body is disconnected</span></span><br><span class="line">      <span class="keyword">byte</span>[] bodyData = Util.toByteArray(response.body().asInputStream());</span><br><span class="line">      <span class="keyword">return</span> response.toBuilder().body(bodyData).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常响应</span></span><br><span class="line">    <span class="keyword">if</span> (response.status() &gt;= <span class="number">200</span> &amp;&amp; response.status() &lt; <span class="number">300</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">void</span><span class="class">.<span class="keyword">class</span> </span>== metadata.returnType()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object result = decode(response);</span><br><span class="line">        shouldClose = closeAfterDecode;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (decode404 &amp;&amp; response.status() == <span class="number">404</span> &amp;&amp; <span class="keyword">void</span><span class="class">.<span class="keyword">class</span> !</span>= metadata.returnType()) &#123;</span><br><span class="line">      <span class="comment">// 404 并且有需要返回结果</span></span><br><span class="line">      Object result = decode(response);</span><br><span class="line">      shouldClose = closeAfterDecode;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 其他的就根据 errorDecoder 解析抛异常</span></span><br><span class="line">      <span class="keyword">throw</span> errorDecoder.decode(metadata.configKey(), response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// io 异常</span></span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">      logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 封装为 FeignException</span></span><br><span class="line">    <span class="keyword">throw</span> errorReading(request, response, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (shouldClose) &#123;</span><br><span class="line">      ensureClosed(response.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么接下来看看 client</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">* Executes a request against its &#123;<span class="doctag">@link</span> Request#url() url&#125; and returns a response.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> request safe to replay.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> options options to apply to this request.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> connected response, &#123;<span class="doctag">@link</span> Response.Body&#125; is absent or unread.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IOException on a network error connecting to &#123;<span class="doctag">@link</span> Request#url()&#125;.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Response <span class="title">execute</span><span class="params">(Request request, Options options)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有一个接口要实现，有一个默认的内部类实现，就是使用 HttpURLConnection 一看就没有软负载， feign 的负载功能是通过 fibbon 实现了，有一个实现 LoadBalancerFeignClient</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">(Request request, Request.Options options)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      URI asUri = URI.create(request.url());</span><br><span class="line">      String clientName = asUri.getHost();</span><br><span class="line">      URI uriWithoutHost = cleanUrl(request.url(), clientName);</span><br><span class="line">      <span class="comment">// 转为 ribbon 的 request</span></span><br><span class="line">      FeignLoadBalancer.RibbonRequest ribbonRequest = <span class="keyword">new</span> FeignLoadBalancer.RibbonRequest(</span><br><span class="line">            <span class="keyword">this</span>.delegate, request, uriWithoutHost);</span><br><span class="line">      <span class="comment">// 配置类</span></span><br><span class="line">      IClientConfig requestConfig = getClientConfig(options, clientName);</span><br><span class="line">      <span class="comment">// 获取 FeignLoadBalancer 然后执行</span></span><br><span class="line">      <span class="keyword">return</span> lbClient(clientName)</span><br><span class="line">            .executeWithLoadBalancer(ribbonRequest, requestConfig).toResponse();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">      IOException io = findIOException(e);</span><br><span class="line">      <span class="keyword">if</span> (io != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> io;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> FeignLoadBalancer <span class="title">lbClient</span><span class="params">(String clientName)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.lbClientFactory.create(clientName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> FeignLoadBalancer <span class="title">create</span><span class="params">(String clientName)</span> </span>&#123;</span><br><span class="line">   FeignLoadBalancer client = <span class="keyword">this</span>.cache.get(clientName);</span><br><span class="line">   <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> client;</span><br><span class="line">   &#125;</span><br><span class="line">   IClientConfig config = <span class="keyword">this</span>.factory.getClientConfig(clientName);</span><br><span class="line">   ILoadBalancer lb = <span class="keyword">this</span>.factory.getLoadBalancer(clientName);</span><br><span class="line">   ServerIntrospector serverIntrospector = <span class="keyword">this</span>.factory.getInstance(clientName,</span><br><span class="line">         ServerIntrospector<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   client = <span class="keyword">this</span>.loadBalancedRetryFactory != <span class="keyword">null</span></span><br><span class="line">         ? <span class="keyword">new</span> RetryableFeignLoadBalancer(lb, config, serverIntrospector,</span><br><span class="line">               <span class="keyword">this</span>.loadBalancedRetryFactory)</span><br><span class="line">         : <span class="keyword">new</span> FeignLoadBalancer(lb, config, serverIntrospector);</span><br><span class="line">   <span class="comment">// 默认是走 FeignLoadBalancer  可以看到传了一个 ILoadBalancer  ServerIntrospector 和 IClientConfig基本配置</span></span><br><span class="line">   <span class="keyword">this</span>.cache.put(clientName, client);</span><br><span class="line">   <span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后又到了 FeignLoadBalancer 的 executeWithLoadBalancer 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">executeWithLoadBalancer</span><span class="params">(<span class="keyword">final</span> S request, <span class="keyword">final</span> IClientConfig requestConfig)</span> <span class="keyword">throws</span> ClientException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 负载指令，其实就是负载策略</span></span><br><span class="line">    LoadBalancerCommand&lt;T&gt; command = buildLoadBalancerCommand(request, requestConfig);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ribbon 内部使用 rxjava </span></span><br><span class="line">        <span class="comment">// submit 内部控制 负载均衡和重试次数， 包括同 server 重试 和 不同 server 重试</span></span><br><span class="line">        <span class="comment">// 这里的 ServerOperation 就是一次实际的请求，参数是已经选择好的 server 然后调用 execute，本质就是 feign 的 client 请求</span></span><br><span class="line">        <span class="keyword">return</span> command.submit(</span><br><span class="line">            <span class="keyword">new</span> ServerOperation&lt;T&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">call</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">                    URI finalUri = reconstructURIWithServer(server, request.getUri());</span><br><span class="line">                    S requestForServer = (S) request.replaceUri(finalUri);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> Observable.just(AbstractLoadBalancerAwareClient.<span class="keyword">this</span>.execute(requestForServer, requestConfig));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .toBlocking()</span><br><span class="line">            .single();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Throwable t = e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ClientException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (ClientException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClientException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> LoadBalancerCommand&lt;T&gt; <span class="title">buildLoadBalancerCommand</span><span class="params">(<span class="keyword">final</span> S request, <span class="keyword">final</span> IClientConfig config)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 重试策略</span></span><br><span class="line">   RequestSpecificRetryHandler handler = getRequestSpecificRetryHandler(request, config);</span><br><span class="line">   LoadBalancerCommand.Builder&lt;T&gt; builder = LoadBalancerCommand.&lt;T&gt;builder()</span><br><span class="line">         .withLoadBalancerContext(<span class="keyword">this</span>)</span><br><span class="line">         .withRetryHandler(handler)</span><br><span class="line">         .withLoadBalancerURI(request.getUri());</span><br><span class="line">   <span class="comment">// 其他自定义配置</span></span><br><span class="line">   customizeLoadBalancerCommandBuilder(request, config, builder);</span><br><span class="line">   <span class="keyword">return</span> builder.build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestSpecificRetryHandler <span class="title">getRequestSpecificRetryHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      RibbonRequest request, IClientConfig requestConfig)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.ribbon.isOkToRetryOnAllOperations()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RequestSpecificRetryHandler(<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">this</span>.getRetryHandler(),</span><br><span class="line">            requestConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!request.toRequest().httpMethod().name().equals(<span class="string">"GET"</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RequestSpecificRetryHandler(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">this</span>.getRetryHandler(),</span><br><span class="line">            requestConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RequestSpecificRetryHandler(<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">this</span>.getRetryHandler(),</span><br><span class="line">            requestConfig);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后最复杂的方法来了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">submit</span><span class="params">(<span class="keyword">final</span> ServerOperation&lt;T&gt; operation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ExecutionInfoContext context = <span class="keyword">new</span> ExecutionInfoContext();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (listenerInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            listenerInvoker.onExecutionStart();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AbortExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxRetrysSame = retryHandler.getMaxRetriesOnSameServer();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxRetrysNext = retryHandler.getMaxRetriesOnNextServer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the load balancer</span></span><br><span class="line">    Observable&lt;T&gt; o =</span><br><span class="line">            <span class="comment">// server 不为null ，那就代表是直连了，否则使用 selectServer 获取可用列表</span></span><br><span class="line">            (server == <span class="keyword">null</span> ? selectServer() : Observable.just(server))</span><br><span class="line">            <span class="comment">// rxjava 的api 做相当于做一次转换，T 是响应类型</span></span><br><span class="line">            .concatMap(<span class="keyword">new</span> Func1&lt;Server, Observable&lt;T&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="comment">// Called for each server being selected</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">call</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">                    context.setServer(server);</span><br><span class="line">                    <span class="keyword">final</span> ServerStats stats = loadBalancerContext.getServerStats(server);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// Called for each attempt and retry</span></span><br><span class="line">                    Observable&lt;T&gt; o = Observable</span><br><span class="line">                            .just(server)</span><br><span class="line">                            .concatMap(<span class="keyword">new</span> Func1&lt;Server, Observable&lt;T&gt;&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">call</span><span class="params">(<span class="keyword">final</span> Server server)</span> </span>&#123;</span><br><span class="line">                                    context.incAttemptCount();</span><br><span class="line">                                    loadBalancerContext.noteOpenConnection(stats);</span><br><span class="line">                                    </span><br><span class="line">                                    <span class="keyword">if</span> (listenerInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                            listenerInvoker.onStartWithServer(context.toExecutionInfo());</span><br><span class="line">                                        &#125; <span class="keyword">catch</span> (AbortExecutionException e) &#123;</span><br><span class="line">                                            <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    </span><br><span class="line">                                    <span class="keyword">final</span> Stopwatch tracer = loadBalancerContext.getExecuteTracer().start();</span><br><span class="line">                                    <span class="comment">// 注意这里，就是调用传 实际的请求，上面一堆都是记录和重试</span></span><br><span class="line">                                    <span class="keyword">return</span> operation.call(server).doOnEach(<span class="keyword">new</span> Observer&lt;T&gt;() &#123;</span><br><span class="line">                                        <span class="keyword">private</span> T entity;</span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                            recordStats(tracer, stats, entity, <span class="keyword">null</span>);</span><br><span class="line">                                            <span class="comment">// <span class="doctag">TODO:</span> What to do if onNext or onError are never called?</span></span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                                            recordStats(tracer, stats, <span class="keyword">null</span>, e);</span><br><span class="line">                                            logger.debug(<span class="string">"Got error &#123;&#125; when executed on server &#123;&#125;"</span>, e, server);</span><br><span class="line">                                            <span class="keyword">if</span> (listenerInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                                listenerInvoker.onExceptionWithServer(e, context.toExecutionInfo());</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T entity)</span> </span>&#123;</span><br><span class="line">                                            <span class="keyword">this</span>.entity = entity;</span><br><span class="line">                                            <span class="keyword">if</span> (listenerInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                                listenerInvoker.onExecutionSuccess(entity, context.toExecutionInfo());</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;                            </span><br><span class="line">                                        </span><br><span class="line">                                        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recordStats</span><span class="params">(Stopwatch tracer, ServerStats stats, Object entity, Throwable exception)</span> </span>&#123;</span><br><span class="line">                                            tracer.stop();</span><br><span class="line">                                            loadBalancerContext.noteRequestCompletion(stats, entity, exception, tracer.getDuration(TimeUnit.MILLISECONDS), retryHandler);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// retry 也是 rxjava api ，retryPolicy 方法判断是否可以重试</span></span><br><span class="line">                    <span class="keyword">if</span> (maxRetrysSame &gt; <span class="number">0</span>)</span><br><span class="line">                        o = o.retry(retryPolicy(maxRetrysSame, <span class="keyword">true</span>));</span><br><span class="line">                    <span class="keyword">return</span> o;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">// 上面重试是针对同一个 server 的，这里是针对不同的 server 的   </span></span><br><span class="line">    <span class="keyword">if</span> (maxRetrysNext &gt; <span class="number">0</span> &amp;&amp; server == <span class="keyword">null</span>)</span><br><span class="line">        o = o.retry(retryPolicy(maxRetrysNext, <span class="keyword">false</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> o.onErrorResumeNext(<span class="keyword">new</span> Func1&lt;Throwable, Observable&lt;T&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">call</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (context.getAttemptCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (maxRetrysNext &gt; <span class="number">0</span> &amp;&amp; context.getServerAttemptCount() == (maxRetrysNext + <span class="number">1</span>)) &#123;</span><br><span class="line">                    e = <span class="keyword">new</span> ClientException(ClientException.ErrorType.NUMBEROF_RETRIES_NEXTSERVER_EXCEEDED,</span><br><span class="line">                            <span class="string">"Number of retries on next server exceeded max "</span> + maxRetrysNext</span><br><span class="line">                            + <span class="string">" retries, while making a call for: "</span> + context.getServer(), e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (maxRetrysSame &gt; <span class="number">0</span> &amp;&amp; context.getAttemptCount() == (maxRetrysSame + <span class="number">1</span>)) &#123;</span><br><span class="line">                    e = <span class="keyword">new</span> ClientException(ClientException.ErrorType.NUMBEROF_RETRIES_EXEEDED,</span><br><span class="line">                            <span class="string">"Number of retries exceeded max "</span> + maxRetrysSame</span><br><span class="line">                            + <span class="string">" retries, while making a call for: "</span> + context.getServer(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (listenerInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                listenerInvoker.onExecutionFailed(e, context.toFinalExecutionInfo());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/10/spring-boot-%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/10/spring-boot-%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">spring-boot 分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-10 12:26:44" itemprop="dateCreated datePublished" datetime="2019-10-10T12:26:44+08:00">2019-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-22 11:25:22" itemprop="dateModified" datetime="2019-11-22T11:25:22+08:00">2019-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <img src="/2019/10/10/spring-boot-%E5%88%86%E6%9E%90/springboot.svg" class="" title="This is an example image">
<h2 id="org-springframework-context-ApplicationContextInitializer"><a href="#org-springframework-context-ApplicationContextInitializer" class="headerlink" title="org.springframework.context.ApplicationContextInitializer"></a><code>org.springframework.context.ApplicationContextInitializer</code></h2><ol>
<li><code>org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer</code><br> 这里面添加了一个 <code>BeanFactoryPostProcessor</code> 实现类 <code>ConfigurationWarningsPostProcessor</code><br> 主要是打印启动过程中的警告信息的</li>
<li><code>org.springframework.boot.context.ContextIdApplicationContextInitializer</code><br> 这里处理 <code>ContextId</code>    </li>
<li><code>org.springframework.boot.context.config.DelegatingApplicationContextInitializer</code><br> 这里处理 <code>ApplicationContextInitializer</code> 的实现类<br> 这个接口就是一个 <code>initialize</code> 方法，参数是 <code>ConfigurableApplicationContext</code> 的子类<br> 当然，不是所有的 <code>ApplicationContextInitializer</code> 都会被调用，可以通过参数 <code>context.initializer.classes</code> 指定要调用的实现类，多个用逗号分隔</li>
<li><code>org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer</code><br> 这个类也实现了 <code>ApplicationListener</code> 接口，用来监听 <code>WebServerInitializedEvent</code> 时间<br> 作用是处理设置 <code>server.port</code></li>
</ol>
<h2 id="org-springframework-context-ApplicationListener"><a href="#org-springframework-context-ApplicationListener" class="headerlink" title="org.springframework.context.ApplicationListener"></a><code>org.springframework.context.ApplicationListener</code></h2><ol>
<li><code>org.springframework.boot.ClearCachesApplicationListener</code><br> 监听的事件是 <code>ContextRefreshedEvent</code> ，也就是 <code>refersh</code> 方法完成后<br> 清理反射使用的缓存</li>
<li><code>org.springframework.boot.builder.ParentContextCloserApplicationListener</code><br>监听的事件是 <code>ParentContextAvailableEvent</code><br>这个是在 <code>ParentContextApplicationContextInitializer</code> 里面触发的，<code>ApplicationContextInitializer</code> 上面说过了<br>这里处理的是有 parent 的情况，使用 <code>SpringApplicationBuilder</code> 的时候，可以指定 parent    </li>
<li><code>org.springframework.boot.context.FileEncodingApplicationListener</code><br>监听的事件是 <code>ApplicationEnvironmentPreparedEvent</code><br>就是实例化 <code>ConfigurableEnvironment</code> 后<br>作用是，检查 <code>spring.mandatory-file-encoding</code> 参数强制指定的字符集与 <code>file.encoding</code> 系统参数的字符集是否一样，如果不愿意，就异常</li>
<li><code>org.springframework.boot.context.config.AnsiOutputApplicationListener</code><br> 监听的事件是 <code>ApplicationEnvironmentPreparedEvent</code><br> 就是实例化 <code>ConfigurableEnvironment</code> 后<br> 处理参数 <code>spring.output.ansi.enabled</code> 和 <code>spring.output.ansi.console-available</code> 就是控制彩色输出</li>
<li><code>org.springframework.boot.context.config.ConfigFileApplicationListener</code><br> 监听的事件是 <code>ApplicationEnvironmentPreparedEvent</code> 和 <code>ApplicationPreparedEvent</code><br> 就是实例化 <code>ConfigurableEnvironment</code> 后和注册完主类为 BeanDefinition 后<br> 处理事件 <code>ApplicationEnvironmentPreparedEvent</code><pre><code> 加载 `EnvironmentPostProcessor` 的实现类
 默认配置有
 `org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor`
 `org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor`
 `org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor`
 在加上自身，调用 `postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application)` 方法
 这里 *关键* ，后面再细看
</code></pre> 处理事件 <code>ApplicationPreparedEvent</code><pre><code> 这里添加了一个 `BeanFactoryPostProcessor` 的实例 `PropertySourceOrderingPostProcessor`
 作用是将 `defaultProperties` 的 `PropertySource` 添加到最后
</code></pre></li>
<li><code>org.springframework.boot.context.config.DelegatingApplicationListener</code><br> 监听的事件是 <code>ApplicationEnvironmentPreparedEvent</code><br> 在 <code>ApplicationEnvironmentPreparedEvent</code> 事件的时候，获取配置 <code>context.listener.classes</code> 指定的 <code>ApplicationListener</code> 类，如果有的话，就转发其他所有事件</li>
<li><code>org.springframework.boot.context.logging.ClasspathLoggingApplicationListener</code><br> 监听的事件是 <code>ApplicationEnvironmentPreparedEvent</code> 或者 <code>ApplicationFailedEvent</code><br> 就是打印一个 <code>classpath</code> 日志</li>
<li><code>org.springframework.boot.context.logging.LoggingApplicationListener</code><br> 监听的事件 <code>ApplicationStartingEvent.class, ApplicationEnvironmentPreparedEvent.class, ApplicationPreparedEvent.class, ContextClosedEvent.class, ApplicationFailedEvent.class</code><br> 处理日志配置和等级的</li>
<li><code>org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener</code><br><code>Liquibase</code> 是数据库版本控制，具体里面做啥，没看。</li>
</ol>
<h2 id="org-springframework-boot-env-EnvironmentPostProcessor"><a href="#org-springframework-boot-env-EnvironmentPostProcessor" class="headerlink" title="org.springframework.boot.env.EnvironmentPostProcessor"></a><code>org.springframework.boot.env.EnvironmentPostProcessor</code></h2><p>上面第 5 条会触发这里，继续看    </p>
<ol>
<li><code>org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor</code><br>云原生相关的，后面看 <code>spring-cloud</code> 的时候再细看</li>
<li><code>org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor</code><br>作用就是找参数 <code>spring.application.json</code> 或者 <code>SPRING_APPLICATION_JSON</code> 指定的 <code>json</code> 文件，加载配置，优先级高于系统参数</li>
<li><code>org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor</code><br>处理 <code>systemEnvironment</code></li>
<li><p><code>org.springframework.boot.context.config.ConfigFileApplicationListener</code><br> 这里就是加载 <code>application.properties</code> 的地方<br> 如果直接指定了 <code>spring.config.location</code> 那么只去加载这里<br> 如果指定了 <code>spring.config.additional-location</code> 额外加载的文件，先加载这里<br> 加上默认的 <code>classpath:/,classpath:/config/,file:./,file:./config/</code></p>
<p> 一般上面指定的是目录，然后在目录下，找文件名，默认是 <code>application</code> , 可以通过 <code>spring.config.name</code> 参数来修改文件名<br> 剩下的就是加载过程了<br> 加载过程中，先加载 <code>spring.factory</code> 的 <code>org.springframework.boot.env.PropertySourceLoader</code> , 默认有两个实现类<br> <code>org.springframework.boot.env.PropertiesPropertySourceLoader</code>   <code>properties</code> 和 <code>xml</code><br> <code>org.springframework.boot.env.YamlPropertySourceLoader</code>      <code>yml</code> 和 <code>yaml</code><br> 好吧，看名字就知道分别处理 <code>properteis</code> 和 <code>yaml</code> 文件了</p>
</li>
</ol>
<p>以上就是 <code>spring-boot</code> 的核心配置<br>我们主要知道了，<code>spring-boot</code> 的启动过程，以及通过哪些扩展接口进行增强<br>接下来看看 <code>spring-boot-autoconfigure</code></p>
<h2 id="org-springframework-context-ApplicationContextInitializer-1"><a href="#org-springframework-context-ApplicationContextInitializer-1" class="headerlink" title="org.springframework.context.ApplicationContextInitializer"></a><code>org.springframework.context.ApplicationContextInitializer</code></h2><ol>
<li><code>org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer</code><br> 注册了一个 <code>BeanFactoryPostProcessor</code> 实现类 <code>CachingMetadataReaderFactoryPostProcessor</code><br> 作用，注册了一个 <code>SharedMetadataReaderFactoryBean</code> 的 <code>BeanDefinition</code></li>
<li><code>org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</code><br> 作用就是打印一些自动注册的日志</li>
</ol>
<h2 id="org-springframework-context-ApplicationListener-1"><a href="#org-springframework-context-ApplicationListener-1" class="headerlink" title="org.springframework.context.ApplicationListener"></a><code>org.springframework.context.ApplicationListener</code></h2><ol>
<li><code>org.springframework.boot.autoconfigure.BackgroundPreinitializer</code><br> 监听的事件是 <code>SpringApplicationEvent</code> 这是一个抽象类 ，上面说的 <code>spring-boot</code> 相关的事件类，大部分都是这个类的子类<br> 作用就是启动一个线程去做一些初始化，类相关的</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/08/spring-%E6%BA%90%E7%A0%81%E5%86%8D%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/08/spring-%E6%BA%90%E7%A0%81%E5%86%8D%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">spring 源码再分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-08 12:32:26" itemprop="dateCreated datePublished" datetime="2019-10-08T12:32:26+08:00">2019-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-22 11:25:16" itemprop="dateModified" datetime="2019-11-22T11:25:16+08:00">2019-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <img src="/2019/10/08/spring-%E6%BA%90%E7%A0%81%E5%86%8D%E5%88%86%E6%9E%90/spring%E5%88%9D%E5%A7%8B%E5%8C%96-%E5%8D%95%E4%BE%8B%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B.svg" class="" title="This is an example image">
<p>ConfigurationClassPostProcessor        BeanDefinitionRegistryPostProcessor<br>AutowiredAnnotationBeanPostProcessor            InstantiationAwareBeanPostProcessorAdapter<br>CommonAnnotationBeanPostProcessor             InstantiationAwareBeanPostProcessor</p>
<p>EventListenerMethodProcessor        SmartInitializingSingleton<br>DefaultEventListenerFactory                EventListenerFactory<br>ApplicationContextAwareProcessor        BeanPostProcessor</p>
<p>ApplicationListenerDetector        BeanPostProcessor</p>
<p>BeanPostProcessorChecker</p>
<ol>
<li>prepareRefresh<br> 记录启动时间</li>
<li>prepareBeanFactory<br> 忽略和设置框架依赖注入</li>
<li>postProcessBeanFactory<br> 扩展方法，</li>
<li><p>invokeBeanFactoryPostProcessors<br> 调用 BeanFactoryPostProcessor  BeanDefinitionRegistryPostProcessor 扩展</p>
<ol>
<li>直接挂在 context 上的 BeanDefinitionRegistryPostProcessor   -&gt; postProcessBeanDefinitionRegistry</li>
<li>beanFactory 里面的  BeanDefinitionRegistryPostProcessor ,PriorityOrdered -&gt;  postProcessBeanDefinitionRegistry</li>
<li>beanFactory 里面的  BeanDefinitionRegistryPostProcessor ,Ordered -&gt;  postProcessBeanDefinitionRegistry</li>
<li>beanFactory 里面的  BeanDefinitionRegistryPostProcessor -&gt;  postProcessBeanDefinitionRegistry</li>
<li>上面执行过的 继续执行 BeanFactoryPostProcessor —&gt; postProcessBeanFactory</li>
<li>直接挂在 context 上的 BeanFactoryPostProcessor —&gt; postProcessBeanFactory</li>
<li>beanFactory 里面的 BeanFactoryPostProcessor , PriorityOrdered  -&gt;  postProcessBeanFactory</li>
<li>beanFactory 里面的 BeanFactoryPostProcessor , Ordered -&gt;  postProcessBeanFactory</li>
<li>beanFactory 里面的 BeanFactoryPostProcessor  -&gt;  postProcessBeanFactory<br>这里核心的是 ConfigurationClassPostProcessor</li>
</ol>
</li>
<li><p>registerBeanPostProcessors<br> 添加 BeanPostProcessor<br> beanFactory 自身带的<br> 添加 BeanPostProcessorChecker<br> 容器里面的<br> BeanPostProcessor - PriorityOrdered<br> BeanPostProcessor - Ordered<br> BeanPostProcessor -<br> 上面三个，按照顺序添加到自身带的后面<br> BeanPostProcessor - MergedBeanDefinitionPostProcessor - PriorityOrdered<br> BeanPostProcessor - MergedBeanDefinitionPostProcessor - Ordered<br> BeanPostProcessor - MergedBeanDefinitionPostProcessor<br> 再添加一次 MergedBeanDefinitionPostProcessor 类型的，按照上面的顺序<br> 最后添加 ApplicationListenerDetector</p>
</li>
<li>initMessageSource<br> 这个是国际化的地方<br> DelegatingMessageSource</li>
<li>initApplicationEventMulticaster<br> 事件<br> SimpleApplicationEventMulticaster</li>
<li>onRefresh<br>空的，扩展接口</li>
<li>registerListeners<br>添加 ApplicationListener<br>先 beanFactory 上挂的，然后 beanFactory 里面的<br>然后将这之前的事件发布了</li>
<li>finishBeanFactoryInitialization<br>特殊处理 LoadTimeWeaverAware 先进行初始化 （getBean）<br>冻结 beanDefinition ,不再改变<br>实例化非延时加载的单例</li>
<li>finishRefresh<br>结束</li>
</ol>
<p>实例化非延时加载的单例</p>
<p>spring 实例化 bean 其实就是调用 getBean<br>内部实现是 doGetBean<br>先看 普通的 bean  后面再看 factoryBean</p>
<ol>
<li>就是去手动注册的 bean 里面检查是否存在，如果存在，直接返回了  一般只有部分 spring 内部的 bean 是手动注册的</li>
<li>在创建 bean 之前，用 InstantiationAwareBeanPostProcessor -&gt; postProcessBeforeInstantiation 处理<br> 这里参数是 class 和 beanName ，如果返回非 null ，那么就使用这里返回的 bean 然后<pre><code> BeanPostProcessor -&gt; postProcessAfterInitialization 处理生成的 bean
</code></pre></li>
<li>如果没被上面的扩展接口处理，那么进入标准的创建流程</li>
<li>如果提供了 bean 的工厂类，那么使用工厂类创建 （可以是 Supplier 或者 factoryMethod）</li>
<li>核心创建方法两个 autowireConstructor （有构造依赖的构建） 和 instantiateBean （标准创建）</li>
<li>创建完成后 调用扩展 MergedBeanDefinitionPostProcessor -&gt; postProcessMergedBeanDefinition  这里是修改 BeanDefinetion 的地方</li>
<li>populateBean  处理扩展接口 InstantiationAwareBeanPostProcessor -&gt; postProcessAfterInstantiation   返回值决定是否继续处理 propertyValue<br> 后面继续处理扩展接口  InstantiationAwareBeanPostProcessor -&gt; postProcessProperties  postProcessPropertyValues</li>
</ol>
<p>BeanPostProcessor -&gt; postProcessBeforeInitialization  </p>
<p>afterPropertiesSet  initMethod<br>BeanPostProcessor -&gt; postProcessAfterInitialization<br>注册 destoryMethod</p>
<p>几个核心的 BeanPostProcessor<br>ApplicationContextAwareProcessor<br>ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor<br>PostProcessorRegistrationDelegate$BeanPostProcessorChecker<br>CommonAnnotationBeanPostProcessor<br>AutowiredAnnotationBeanPostProcessor<br>ApplicationListenerDetector</p>
<ol>
<li>ApplicationContextAwareProcessor  实现  BeanPostProcessor<br>作用：<br>在 init 方法之前，调用 bean 的 Aware 接口<br>EnvironmentAware<br>EmbeddedValueResolverAware<br>ResourceLoaderAware<br>ApplicationEventPublisherAware<br>MessageSourceAware<br>ApplicationContextAware</li>
<li>ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor 实现 InstantiationAwareBeanPostProcessor<br>作用:<br>在依赖注入前，设置 BeanFactory 接口  EnhancedConfiguration<br>在 init 方法前 调用<br>ImportAware</li>
<li>PostProcessorRegistrationDelegate$BeanPostProcessorChecker<br>这个扩展是用来检测 bean 是否经过了所有 BeanPostProcess 的处理 ，如果没有，会有 info 日志<br>因为在实例化 bean 之前，首先处理的是 BeanPostProcessor 实例，按照顺序，是内建 -&gt; PriorityOrdered -&gt; Ordered -&gt; 非排序的<br>如果直接存在依赖注入的问题，那么，会有一个问题，在 BeanPostProcessor 里面依赖了其他普通的 bean，那么会先触发普通 bean 的实例化，但是没法享受 BeanPostProcessor 的处理了<br>要知道 无论是 ioc 还是 aop 都是使用 BeanPostProcessor 扩展的</li>
<li>CommonAnnotationBeanPostProcessor 实现 InstantiationAwareBeanPostProcessor MergedBeanDefinitionPostProcessor DestructionAwareBeanPostProcessor<br>这里处理的是 init 和 destroy 和 JSR-250 注解依赖注入的地方<br>这里的注解属于标准注解 javax.annotation.PostConstruct javax.annotation.PreDestroy  javax.annotation.Resource 等</li>
<li>AutowiredAnnotationBeanPostProcessor 实现 InstantiationAwareBeanPostProcessor  MergedBeanDefinitionPostProcessor<br>这里是处理内置注解 @Autowired   @Value  javax.inject.Inject  的注入</li>
<li>ApplicationListenerDetector<br>这里是处理 ApplicationListener 的地方，单例的 ApplicationListener 实例注册，非单例，打印警告信息</li>
</ol>
<p>ConfigurationClassPostProcessor 这个是核心类，还要仔细看看</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/29/spring-security%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/29/spring-security%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">spring-security分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-29 00:41:34" itemprop="dateCreated datePublished" datetime="2019-09-29T00:41:34+08:00">2019-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-22 11:25:01" itemprop="dateModified" datetime="2019-11-22T11:25:01+08:00">2019-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <img src="/2019/09/29/spring-security%E5%88%86%E6%9E%90/security-core.png" class="" title="This is an example image">
<p>网上都说 shiro 比 security 好，分析完 shiro 后，发现确实实现的挺轻量级的，而且扩展也比较容易，他实现的代码也很漂亮<br>但是后台开发通常都会用 spring ，spring-security 自然就是官方支持的，有时候为了方便，直接使用 spring-security 了，但是配置都是网上抄的<br>而 spring-security 又像一个全家桶，一个配置，加了一堆东西，有时候出了问题，都不知道怎么排查<br>于是，抱着弄懂原理，心理不慌的想法，开始前线的分析源码  </p>
<p>首先明确一个概念，安全框架的基本功能就是认证授权，至于额外的密码hash，防御攻击之类的，都是额外的操作，security 一键就给你加了一堆东西，虽然用的爽，实际上，连使用者都可能不知道到底添加了哪些功能  </p>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>认证的核心接口是 <code>AuthenticationManager</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthenticationManager</span> </span>&#123;</span><br><span class="line">	<span class="function">Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只有一个认证方法，凭证 <code>Authentication</code> 可以代表认证成功前的请求信息，也可以表示认证成功后的调用凭证信息<br><code>AuthenticationManager</code> 内部已经有实现了 <code>ProviderManager</code>，我们通常不会去重新实现它<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    Class&lt;? extends Authentication&gt; toTest = authentication.getClass();</span><br><span class="line">    AuthenticationException lastException = <span class="keyword">null</span>;</span><br><span class="line">    Authentication result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> debug = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!provider.supports(toTest)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Authentication attempt using "</span></span><br><span class="line">                    + provider.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = provider.authenticate(authentication);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                copyDetails(authentication, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AccountStatusException e) &#123;</span><br><span class="line">            prepareException(e, authentication);</span><br><span class="line">            <span class="comment">// SEC-546: Avoid polling additional providers if auth failure is due to</span></span><br><span class="line">            <span class="comment">// invalid account status</span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InternalAuthenticationServiceException e) &#123;</span><br><span class="line">            prepareException(e, authentication);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            lastException = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Allow the parent to try.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = parent.authenticate(authentication);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ProviderNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// ignore as we will throw below if no other exception occurred prior to</span></span><br><span class="line">            <span class="comment">// calling parent and the parent</span></span><br><span class="line">            <span class="comment">// may throw ProviderNotFound even though a provider in the child already</span></span><br><span class="line">            <span class="comment">// handled the request</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            lastException = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eraseCredentialsAfterAuthentication</span><br><span class="line">                &amp;&amp; (result <span class="keyword">instanceof</span> CredentialsContainer)) &#123;</span><br><span class="line">            <span class="comment">// Authentication is complete. Remove credentials and other secret data</span></span><br><span class="line">            <span class="comment">// from authentication</span></span><br><span class="line">            ((CredentialsContainer) result).eraseCredentials();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent was null, or didn't authenticate (or throw an exception).</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastException == <span class="keyword">null</span>) &#123;</span><br><span class="line">        lastException = <span class="keyword">new</span> ProviderNotFoundException(messages.getMessage(</span><br><span class="line">                <span class="string">"ProviderManager.providerNotFound"</span>,</span><br><span class="line">                <span class="keyword">new</span> Object[] &#123; toTest.getName() &#125;,</span><br><span class="line">                <span class="string">"No AuthenticationProvider found for &#123;0&#125;"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prepareException(lastException, authentication);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> lastException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>逻辑很清晰，内部使用的是 <code>AuthenticationProvider</code> 接口来认证的，而我们如果要自定义的话，通常是实现这个接口，不过内部已经有很多实现了，如果可以满足需求，直接使用内部实现就可以了<br>认证成功和失败都会发布对应的事件，内部的事件都是继承 <code>AbstractAuthenticationFailureEvent</code> 的，只要捕获这个抽象的事件，就可以处理认证相关的事件了，具体的事件列表如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AuthenticationSuccessEvent</span><br><span class="line">AuthenticationFailureBadCredentialsEvent</span><br><span class="line">AuthenticationFailureExpiredEvent</span><br><span class="line">AuthenticationFailureProviderNotFoundEvent</span><br><span class="line">AuthenticationFailureDisabledEvent</span><br><span class="line">AuthenticationFailureLockedEvent</span><br><span class="line">AuthenticationFailureServiceExceptionEvent</span><br><span class="line">AuthenticationFailureCredentialsExpiredEvent</span><br><span class="line">AuthenticationFailureProxyUntrustedEvent</span><br></pre></td></tr></table></figure></p>
<p>再看看 <code>AuthenticationProvider</code> 是怎么定义的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两个方法，其中 <code>supports</code> 的方法参数，通常是 <code>Authentication</code> 的子类，根据方法名就知道，每个 <code>AuthenticationProvider</code> 处理特定 <code>Authentication</code> 的类型，很可能是成对出现的<br>security 内部已经实现了一部分了，譬如 </p>
<ol>
<li><code>RememberMeAuthenticationProvider</code> 处理 <code>RememberMeAuthenticationToken</code>  </li>
<li><code>AnonymousAuthenticationProvider</code> 处理 <code>AnonymousAuthenticationToken</code></li>
<li><code>RunAsImplAuthenticationProvider</code> 处理 <code>RunAsUserToken</code></li>
<li><code>PreAuthenticatedAuthenticationProvider</code> 处理 <code>PreAuthenticatedAuthenticationToken</code></li>
<li><code>DaoAuthenticationProvider</code> 处理 <code>UsernamePasswordAuthenticationToken</code>  </li>
<li>。。。</li>
</ol>
<p>这里就已经出现了后台管理系统里面常用的认证方法：用户名密码认证<br><code>DaoAuthenticationProvider</code> 类是继承 <code>AbstractUserDetailsAuthenticationProvider</code> 的<br>我们关注一下 <code>AbstractUserDetailsAuthenticationProvider</code> 的 <code>authenticate</code> 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    Assert.isInstanceOf(UsernamePasswordAuthenticationToken<span class="class">.<span class="keyword">class</span>, <span class="title">authentication</span>,</span></span><br><span class="line"><span class="class">            <span class="title">messages</span>.<span class="title">getMessage</span>(</span></span><br><span class="line">                    "AbstractUserDetailsAuthenticationProvider.onlySupports",</span><br><span class="line">                    <span class="string">"Only UsernamePasswordAuthenticationToken is supported"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine username</span></span><br><span class="line">    String username = (authentication.getPrincipal() == <span class="keyword">null</span>) ? <span class="string">"NONE_PROVIDED"</span></span><br><span class="line">            : authentication.getName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里只是一个简单的 cache</span></span><br><span class="line">    <span class="keyword">boolean</span> cacheWasUsed = <span class="keyword">true</span>;</span><br><span class="line">    UserDetails user = <span class="keyword">this</span>.userCache.getUserFromCache(username);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cacheWasUsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 抽象方法，子类实现</span></span><br><span class="line">            user = retrieveUser(username,</span><br><span class="line">                    (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (UsernameNotFoundException notFound) &#123;</span><br><span class="line">            logger.debug(<span class="string">"User '"</span> + username + <span class="string">"' not found"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hideUserNotFoundExceptions) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line">                        <span class="string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line">                        <span class="string">"Bad credentials"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> notFound;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Assert.notNull(user,</span><br><span class="line">                <span class="string">"retrieveUser returned null - a violation of the interface contract"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 本类实现的前置检查 检查账号的状态，是否禁用，过期之类的</span></span><br><span class="line">        preAuthenticationChecks.check(user);</span><br><span class="line">        <span class="comment">// 抽象方法，自定义前置检查</span></span><br><span class="line">        additionalAuthenticationChecks(user,</span><br><span class="line">                (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AuthenticationException exception) &#123;</span><br><span class="line">        <span class="comment">// 通过缓存认证失败了，尝试从正常途径获取信息再认证一次</span></span><br><span class="line">        <span class="keyword">if</span> (cacheWasUsed) &#123;</span><br><span class="line">            <span class="comment">// There was a problem, so try again after checking</span></span><br><span class="line">            <span class="comment">// we're using latest data (i.e. not from the cache)</span></span><br><span class="line">            cacheWasUsed = <span class="keyword">false</span>;</span><br><span class="line">            user = retrieveUser(username,</span><br><span class="line">                    (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">            preAuthenticationChecks.check(user);</span><br><span class="line">            additionalAuthenticationChecks(user,</span><br><span class="line">                    (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本类实现的后置检查，密码是否过期了</span></span><br><span class="line">    postAuthenticationChecks.check(user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cacheWasUsed) &#123;</span><br><span class="line">        <span class="keyword">this</span>.userCache.putUserInCache(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object principalToReturn = user;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (forcePrincipalAsString) &#123;</span><br><span class="line">        principalToReturn = user.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来子类重点应该实现 <code>retrieveUser</code> 和做一下其他的校验<br>看看 <code>DaoAuthenticationProvider</code> 里面的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> UserDetails <span class="title">retrieveUser</span><span class="params">(String username,</span></span></span><br><span class="line"><span class="function"><span class="params">        UsernamePasswordAuthenticationToken authentication)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    prepareTimingAttackProtection();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里就是熟悉的 UserDetailsService 了</span></span><br><span class="line">        UserDetails loadedUser = <span class="keyword">this</span>.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (loadedUser == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalAuthenticationServiceException(</span><br><span class="line">                    <span class="string">"UserDetailsService returned null, which is an interface contract violation"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loadedUser;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (UsernameNotFoundException ex) &#123;</span><br><span class="line">        mitigateAgainstTimingAttack(authentication);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InternalAuthenticationServiceException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalAuthenticationServiceException(ex.getMessage(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails,</span></span></span><br><span class="line"><span class="function"><span class="params">        UsernamePasswordAuthenticationToken authentication)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (authentication.getCredentials() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Authentication failed: no credentials provided"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line">                <span class="string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line">                <span class="string">"Bad credentials"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String presentedPassword = authentication.getCredentials().toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里也应该比较熟悉了 PasswordEncoder</span></span><br><span class="line">    <span class="keyword">if</span> (!passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Authentication failed: password does not match stored value"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line">                <span class="string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line">                <span class="string">"Bad credentials"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，如果要用用户名密码认证，只要指定 <code>UserDetailsService</code> 的实现 和 <code>PasswordEncoder</code> 的实现了<br>顺便说一句，<code>PasswordEncoder</code> 有一个代理实现 <code>DelegatingPasswordEncoder</code> ，包装了所有具体实现  </p>
<p>认证流程核心就是这些概念，但是要注意，实际使用肯定不止这些，要使用注解，就得将这些实现跟 aop 结合，要使用拦截器，就得跟 filter 结合，这些后面再细讲  </p>
<h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>授权也就是访问控制，在 security 里面是在 access 包里面<br>授权的核心类是 <code>AbstractSecurityInterceptor</code> (别问我怎么找到的)，这个类的名字虽然是 interceptor ， 但是跟 spring-web 里面的拦截器没关系，只是逻辑上的拦截（跟 shiro 类型），具体的实现类，可以做 aop 拦截 或者 filter 拦截<br>这个类里面涉及到授权相关的很多类 </p>
<ol>
<li><code>AccessDecisionManager</code>  授权管理</li>
<li><code>AfterInvocationManager</code> 鉴权完成后，如果这个不为null，继续鉴权</li>
<li><code>AuthenticationManager</code> 认证管理</li>
<li><code>RunAsManager</code>  权限认证成功后，转换角色用的，默认没有转换功能</li>
<li><code>SecurityMetadataSource</code> 根据调用参数，判断是否需要鉴权</li>
</ol>
<p>这个类实际上是一个辅助类，提供了 调用前 <code>beforeInvocation</code> 调用后 <code>finallyInvocation</code> 调用结束 <code>afterInvocation</code><br>我们一个一个看，首先调用前  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> InterceptorStatusToken <span class="title">beforeInvocation</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(object, <span class="string">"Object was null"</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> debug = logger.isDebugEnabled();</span><br><span class="line">    <span class="comment">// getSecureObjectClass 是一个抽象方法，由子类指定方法参数类型</span></span><br><span class="line">    <span class="keyword">if</span> (!getSecureObjectClass().isAssignableFrom(object.getClass())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">"Security invocation attempted for object "</span></span><br><span class="line">                        + object.getClass().getName()</span><br><span class="line">                        + <span class="string">" but AbstractSecurityInterceptor only configured to support secure objects of type: "</span></span><br><span class="line">                        + getSecureObjectClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里有点关键，就是使用 SecurityMetadataSource 处理调用参数，判断是否需要鉴权</span></span><br><span class="line">    Collection&lt;ConfigAttribute&gt; attributes = <span class="keyword">this</span>.obtainSecurityMetadataSource()</span><br><span class="line">            .getAttributes(object);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (attributes == <span class="keyword">null</span> || attributes.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 默认是 false</span></span><br><span class="line">        <span class="keyword">if</span> (rejectPublicInvocations) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"Secure object invocation "</span></span><br><span class="line">                            + object</span><br><span class="line">                            + <span class="string">" was denied as public invocations are not allowed via this interceptor. "</span></span><br><span class="line">                            + <span class="string">"This indicates a configuration error because the "</span></span><br><span class="line">                            + <span class="string">"rejectPublicInvocations property is set to 'true'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Public object - authentication not attempted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        publishEvent(<span class="keyword">new</span> PublicInvocationEvent(object));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不需要鉴权，返回 null 了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// no further work post-invocation</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Secure object: "</span> + object + <span class="string">"; Attributes: "</span> + attributes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        credentialsNotFound(messages.getMessage(</span><br><span class="line">                <span class="string">"AbstractSecurityInterceptor.authenticationNotFound"</span>,</span><br><span class="line">                <span class="string">"An Authentication object was not found in the SecurityContext"</span>),</span><br><span class="line">                object, attributes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还没认证，那就先做认证，不同，通常，认证应该在之前就做了，设置了 SecurityContextHolder </span></span><br><span class="line">    Authentication authenticated = authenticateIfRequired();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attempt authorization</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里判断权限</span></span><br><span class="line">        <span class="keyword">this</span>.accessDecisionManager.decide(authenticated, object, attributes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AccessDeniedException accessDeniedException) &#123;</span><br><span class="line">        publishEvent(<span class="keyword">new</span> AuthorizationFailureEvent(object, attributes, authenticated,</span><br><span class="line">                accessDeniedException));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> accessDeniedException;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Authorization successful"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (publishAuthorizationSuccess) &#123;</span><br><span class="line">        publishEvent(<span class="keyword">new</span> AuthorizedEvent(object, attributes, authenticated));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换用户，默认这个是返回 null 的</span></span><br><span class="line">    <span class="comment">// Attempt to run as a different user</span></span><br><span class="line">    Authentication runAs = <span class="keyword">this</span>.runAsManager.buildRunAs(authenticated, object,</span><br><span class="line">            attributes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runAs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            logger.debug(<span class="string">"RunAsManager did not change Authentication object"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所以正常逻辑走这里</span></span><br><span class="line">        <span class="comment">// no further work post-invocation</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InterceptorStatusToken(SecurityContextHolder.getContext(), <span class="keyword">false</span>,</span><br><span class="line">                attributes, object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Switching to RunAs Authentication: "</span> + runAs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则，就转换角色（认证凭证换了）</span></span><br><span class="line">        SecurityContext origCtx = SecurityContextHolder.getContext();</span><br><span class="line">        SecurityContextHolder.setContext(SecurityContextHolder.createEmptyContext());</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(runAs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// need to revert to token.Authenticated post-invocation</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InterceptorStatusToken(origCtx, <span class="keyword">true</span>, attributes, object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用后<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finallyInvocation</span><span class="params">(InterceptorStatusToken token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (token != <span class="keyword">null</span> &amp;&amp; token.isContextHolderRefreshRequired()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Reverting to original Authentication: "</span></span><br><span class="line">                    + token.getSecurityContext().getAuthentication());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SecurityContextHolder.setContext(token.getSecurityContext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">afterInvocation</span><span class="params">(InterceptorStatusToken token, Object returnedObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// public object</span></span><br><span class="line">        <span class="keyword">return</span> returnedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    finallyInvocation(token); <span class="comment">// continue to clean in this method for passivity</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (afterInvocationManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Attempt after invocation handling</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            returnedObject = afterInvocationManager.decide(token.getSecurityContext()</span><br><span class="line">                    .getAuthentication(), token.getSecureObject(), token</span><br><span class="line">                    .getAttributes(), returnedObject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AccessDeniedException accessDeniedException) &#123;</span><br><span class="line">            AuthorizationFailureEvent event = <span class="keyword">new</span> AuthorizationFailureEvent(</span><br><span class="line">                    token.getSecureObject(), token.getAttributes(), token</span><br><span class="line">                            .getSecurityContext().getAuthentication(),</span><br><span class="line">                    accessDeniedException);</span><br><span class="line">            publishEvent(event);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> accessDeniedException;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> returnedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个方法的逻辑很简单，重点在 <code>AfterInvocationManager</code> 的实现，作用跟 <code>AccessDecisionManager</code> 类似，也是用来处理权限的  </p>
<p>抽象类下面也就是两个方向，处理注解的 aop 实现 <code>MethodSecurityInterceptor</code> 和 处理 web 的 过滤器实现 <code>FilterSecurityInterceptor</code><br>这两个实现的不同就是调用参数不同，和判断是否需要权限验证的类不同 <code>MethodSecurityMetadataSource</code>, <code>FilterInvocationSecurityMetadataSource</code><br>这个后面再看，先看重点 <code>AccessDecisionManager</code> 的实现，权限判断，主要是这个类做的  </p>
<p>这个里面有一个 <code>AccessDecisionVoter</code> 列表，代表一组权限鉴定器，鉴定结果有3种，授权通过，拒绝，保留意见。<br>具体判断是否授权通过由子类处理，而 <code>AccessDecisionManager</code> 的具体实现，就是鉴定策略，具体实现有<br><code>AffirmativeBased</code>  只有有一个授权通过，那就授权，如果没有通过的，只要有拒绝的，直接拒绝，否则保留意见就看怎么设置的参数了<br><code>ConsensusBased</code>  通过和拒绝的投票数，看哪种结果票数多，如果同票，参数处理<br><code>UnanimousBased</code>  只要有拒绝，那就直接拒绝  </p>
<p>再来看看具体的 aop 拦截器 <code>MethodSecurityInterceptor</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getSecureObjectClass() &#123;</span><br><span class="line">    <span class="keyword">return</span> MethodInvocation<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    InterceptorStatusToken token = <span class="keyword">super</span>.beforeInvocation(mi);</span><br><span class="line"></span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.finallyInvocation(token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.afterInvocation(token, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodSecurityMetadataSource <span class="title">getSecurityMetadataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.securityMetadataSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SecurityMetadataSource <span class="title">obtainSecurityMetadataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.securityMetadataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/27/spring-tx-%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/27/spring-tx-%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">spring-tx 分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-27 00:29:10" itemprop="dateCreated datePublished" datetime="2019-09-27T00:29:10+08:00">2019-09-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-22 11:24:54" itemprop="dateModified" datetime="2019-11-22T11:24:54+08:00">2019-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><p>稍微想一下，大概就可以猜到，事务是通过 aop 实现的，在前后增强，类似 @Around<br>但是，在 aop 里面就说过了，我们自定义的 aop 才使用 @Around ，框架内部使用的是直接的 Advisor<br>tx 的配置类是 <code>ProxyTransactionManagementConfiguration</code> 里面注册了3个 bean<br><code>BeanFactoryTransactionAttributeSourceAdvisor</code>,  这个后面要详细说，aop 找的就是这个类，这个类使用了下面两个<br><code>TransactionAttributeSource</code>, 这个是用来判断是否有事务的<br><code>TransactionInterceptor</code> 具体做事的地方，Advice 的另一个分支 intercept 的实现，也使用了 <code>TransactionAttributeSource</code>  </p>
<p>我们先看看 <code>TransactionAttributeSource</code> 是干啥的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionAttributeSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">TransactionAttribute <span class="title">getTransactionAttribute</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>看一眼就知道，从方法和类型里面读取事务信息的，估计如果没有读取到，那就不走事务，没有事务 aop<br>使用的具体实现是  <code>AnnotationTransactionAttributeSource</code> 可以进去看看，分为3中类型，ejb，jta，springtx，现在只关注最有一个<br>spring 的使用 <code>@Transactional</code> 注解 </p>
<p>然后看看 <code>TransactionInterceptor</code> 这里是具体做事的地方，细节很复杂，详细看看，对以后配置事务，数据源有帮助<br>实际类型是 <code>TransactionInterceptor</code>  实现了 <code>MethodInterceptor</code> 接口，这个接口是 <code>Advice</code> 的扩展接口<br>里面，invoke 方法直接调用父类的 <code>invokeWithinTransaction</code> 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">	<span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span></span><br><span class="line">	TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">	Object retVal = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line">		<span class="comment">// This will normally result in a target object being invoked.</span></span><br><span class="line">		retVal = invocation.proceedWithInvocation();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="comment">// target invocation exception</span></span><br><span class="line">		completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		cleanupTransactionInfo(txInfo);</span><br><span class="line">	&#125;</span><br><span class="line">	commitTransactionAfterReturning(txInfo);</span><br><span class="line">	<span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>虽然有 else 的逻辑，但是，大部分走的是这里，逻辑很清晰，这里就不多讲了，直接看细节。<br>首先是创建事务，这里可能创建新事务，具体需要看配置（spring 的事务传播级别）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">createTransactionIfNecessary</span><span class="params">(@Nullable PlatformTransactionManager tm,</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nullable TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If no name specified, apply method identification as transaction name.</span></span><br><span class="line">	<span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; txAttr.getName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">		txAttr = <span class="keyword">new</span> DelegatingTransactionAttribute(txAttr) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TransactionStatus status = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tm != <span class="keyword">null</span>) &#123;</span><br><span class="line">			status = tm.getTransaction(txAttr);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Skipping transactional joinpoint ["</span> + joinpointIdentification +</span><br><span class="line">						<span class="string">"] because no transaction manager has been configured"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实，这里只是调用了 <code>PlatformTransactionManager</code> 的 getTransaction 方法，在这里面处理了传播级别，我们过会看里面的细节，<br>还是看事务的拦截器那里，获取事务，方法调用，异常处理，事务完成<br>我们接下来看看异常处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">completeTransactionAfterThrowing</span><span class="params">(@Nullable TransactionInfo txInfo, Throwable ex)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (txInfo != <span class="keyword">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Completing transaction for ["</span> + txInfo.getJoinpointIdentification() +</span><br><span class="line">					<span class="string">"] after exception: "</span> + ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (txInfo.transactionAttribute != <span class="keyword">null</span> &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">				logger.error(<span class="string">"Application exception overridden by rollback exception"</span>, ex);</span><br><span class="line">				ex2.initApplicationException(ex);</span><br><span class="line">				<span class="keyword">throw</span> ex2;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (RuntimeException | Error ex2) &#123;</span><br><span class="line">				logger.error(<span class="string">"Application exception overridden by rollback exception"</span>, ex);</span><br><span class="line">				<span class="keyword">throw</span> ex2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// We don't roll back on this exception.</span></span><br><span class="line">			<span class="comment">// Will still roll back if TransactionStatus.isRollbackOnly() is true.</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">				logger.error(<span class="string">"Application exception overridden by commit exception"</span>, ex);</span><br><span class="line">				ex2.initApplicationException(ex);</span><br><span class="line">				<span class="keyword">throw</span> ex2;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (RuntimeException | Error ex2) &#123;</span><br><span class="line">				logger.error(<span class="string">"Application exception overridden by commit exception"</span>, ex);</span><br><span class="line">				<span class="keyword">throw</span> ex2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一大坨代码，实际上做了两件事，如果抛出的异常是需要回滚的，那就回滚，否则提交，还是使用 <code>PlatformTransactionManager</code> 的方法<br>提交事务一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">commitTransactionAfterReturning</span><span class="params">(@Nullable TransactionInfo txInfo)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (txInfo != <span class="keyword">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Completing transaction for ["</span> + txInfo.getJoinpointIdentification() + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么，我们就可以把注意力转移到 <code>PlatformTransactionManager</code> 的实现了，我们先看看这个接口，也就3个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>外部也只调用了这3个方法<br>下面的继承关系也很简单，只有一个抽象类 <code>AbstractPlatformTransactionManager</code> ，然后下面的都是具体实现了<br>先看  <code>getTransaction</code> 方法,先简单说一下逻辑，代码贴的太多了，<br>首先调用 <code>doGetTransaction</code> 方法获取事务对象，事务对象的具体类型是子类确定的<br>判断事务是否已经存在（方法外部已经有事务了） <code>isExistingTransaction</code> 这个子类实现，<br>如果存在了，那就调用 <code>handleExistingTransaction</code> 方法返回<br>这里就需要判断事务传播级别了，这里先说说传播级别</p>
<ol>
<li>PROPAGATION_REQUIRED  支持当前事务，如果没有，就新建事务，这个是默认的</li>
<li>PROPAGATION_SUPPORTS  支持当前事务，如果没有，那本方法不走业务</li>
<li>PROPAGATION_MANDATORY  支持当前事务，如果没有，就抛异常</li>
<li>PROPAGATION_REQUIRES_NEW  本方法使用新事务，如果当前存在事务了，就暂停当前的事务</li>
<li>PROPAGATION_NOT_SUPPORTED  不支持当前事务，总是以非事务运行</li>
<li>PROPAGATION_NEVER  不支持当前事务，如果存在，抛异常</li>
<li>PROPAGATION_NESTED 如果存在当前事务，本方法就以内部事务运行</li>
</ol>
<p>清楚传播级别后，代码可以自己细看了<br>这里说说新建事务相关的方法 </p>
<ol>
<li>newTransactionStatus 新建事务，这方方法的返回值，就是 getTransaction 的返回值</li>
<li>doBegin 这里才是开始事务，如果没有执行这个方法，实际上是使用当前事务，调用了这个，就是新建事务</li>
<li>prepareSynchronization 这个方法应该是在 doBegin 后面执行的，设置一些线程上下文</li>
<li>prepareTransactionStatus 这个方法包含 newTransactionStatus 和 prepareSynchronization</li>
</ol>
<p>如果是使用当前事务，那么新建的事务对象里面 <code>newTransaction</code> 属性是 false<br>再说 commit 方法，只有当当前的事务对象 <code>newTransaction</code> 是 true 的时候，才调用 <code>doCommit</code> 方法做真正的提交<br>rollback 方法，同样，只有当当前的事务对象 <code>newTransaction</code> 是 true 的时候，才调用 <code>doRollback</code> 方法做回滚<br>除了上面的关键逻辑，还有一些其他的，譬如事务释放只回滚（test的时候用的）,触发一些事件  </p>
<p>那么子类需要实现的方法就有如下方法了  </p>
<ol>
<li>doGetTransaction 获取事务对象，返回的对象是自己定义的类型</li>
<li>isExistingTransaction  当前事务是否存在，参数就是事务对象，自己定义的对象要能够分辨出来事务是否存在</li>
<li>doBegin 开始事务，通常，调用了这个方法，事务才被激活，才能说事务存在</li>
<li>doSuspend 暂停当前事务，返回值会传递给恢复方法 doResume</li>
<li>doResume 恢复事务</li>
<li>doCommit 实际的事务提交</li>
<li>doRollback 实际的事务回滚</li>
<li>doCleanupAfterCompletion 事务结束后的清尾操作</li>
</ol>
<p>上面是必须的，其他的方法，可以覆盖父类，或者自定义方法  </p>
<p>需要看看 <code>DataSourceTransactionManager</code> 管理 jdbc 事务<br>所谓事务，就是当前线程中，执行的方法，要使用同一个数据库连接对象 <code>Connection</code><br>很自然的想要，要使用线程对象来存储，spring 也是这样做的，在 doBegin 的时候，才需要获取数据库连接，存到线程对象中<br>忽略其他细节<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());</span><br></pre></td></tr></table></figure><br>详细的可以看看 <code>TransactionSynchronizationManager</code> 这个类，里面有一堆线程对象<br>顺便说一句，我们可以看到 <code>bindResource</code> 方法第一个对象是key 第二个对象是value，key 是数据库连接池对象<br>我们可以使用 aop 在运行过程中确定使用哪个数据库连接池(数据库),再设置一个默认的数据库连接池，就可以使用多数据库了，不过不支持分布式事务，但是可以做读写分离<br>具体的可以使用 <code>AbstractRoutingDataSource</code><br>事务和连接池的就分析到这里了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/26/spring-mvc-HandlerAdapter%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/26/spring-mvc-HandlerAdapter%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">spring-mvc-HandlerAdapter详解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-26 00:32:35" itemprop="dateCreated datePublished" datetime="2019-09-26T00:32:35+08:00">2019-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-22 11:24:48" itemprop="dateModified" datetime="2019-11-22T11:24:48+08:00">2019-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>HandlerAdapter<br>这个主要是适配器，来调用 handler 的，在之前和之后做一些增强处理，每个 adapter 类型，支持对应的 handler 类型<br>三个方法</p>
<ol>
<li>boolean supports(Object handler);</li>
<li>ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;</li>
<li>long getLastModified(HttpServletRequest request, Object handler);</li>
</ol>
<p>主要有 4 中 adapter</p>
<ol>
<li>HttpRequestHandlerAdapter 这个处理 handler 的类型为 HttpRequestHandler </li>
<li>SimpleServletHandlerAdapter 这个处理 handler 的类型为 Servlet 调用 service 方法</li>
<li>SimpleControllerHandlerAdapter 这个处理 handler 的类型为 Controller </li>
<li>RequestMappingHandlerAdapter 这个是大部分逻辑走的地方，上面3个一般是 spring 自己用的，这个处理的 handler 类型是 HandlerMethod </li>
</ol>
<p>重点关注 RequestMappingHandlerAdapter 其他3个很简单</p>
<p>有一个继承 AbstractHandlerMethodAdapter<br>这里实现 supports 方法 支持 HandlerMethod  并且要满足 supportsInternal 返回true 这是一个抽象方法<br>实现 handle 方法，将 handler 转型为 HandlerMethod ，调用 handleInternal 也是一个抽象方法<br>实现 getLastModified 方法，将 handler 转型为 HandlerMethod ，调用 getLastModifiedInternal 也是一个抽象方法<br>。。。</p>
<p>直接看 RequestMappingHandlerAdapter<br>这个里面的东西就很多了，重点要关注的是初始化方法，这个类实现了 InitializingBean 所以会触发初始化方法 afterPropertiesSet 在这个方法里面，就可以看到它有哪些扩展组件了<br>初始化主要做4件事</p>
<ol>
<li><p>initControllerAdviceCache<br>看名字就知道了 找 @ControllerAdvice 注解的 bean ，<br>然后找里面带 @RequestMapping &amp;&amp; @ModelAttribute 注解的方法，丢到 modelAttributeAdviceCache 里面<br>找带 @InitBinder 注解的方法丢到 initBinderAdviceCache 里面<br>然后处理 RequestBodyAdvice 和 ResponseBodyAdvice</p>
</li>
<li><p>argumentResolvers<br>这里就是请求参数处理的地方，参数处理接口是 HandlerMethodArgumentResolver<br>获取所有默认的参数处理，和自定义的参数处理，默认的优先<br>然后用 HandlerMethodArgumentResolverComposite 对象组合</p>
</li>
<li><p>initBinderArgumentResolvers<br>其实跟上面一样的，只是默认添加的东西不一样，自定义的还是在这里<br>一样是 HandlerMethodArgumentResolver 用 HandlerMethodArgumentResolverComposite 对象组合</p>
</li>
<li><p>returnValueHandlers<br>这个是处理返回结果的 HandlerMethodReturnValueHandler<br>使用 HandlerMethodReturnValueHandlerComposite 对象组合</p>
</li>
</ol>
<p>这里面重要的是要实现3个抽象方法 </p>
<ol>
<li>supportsInternal 这个固定返回 true</li>
<li>getLastModifiedInternal 返回 -1 ，到这里的请求，通常是业务处理，不用 http 缓存</li>
<li>handleInternal<br>就是业务处理了，其实是做业务处理前后的一些事情，具体业务处理是 HanderMethod 完成的</li>
</ol>
<p>这里的逻辑</p>
<ol>
<li>检查 request http 方法这里是否支持，如果需要 session ，则判断 session 是否存在</li>
<li>调用 invokeHandlerMethod 虽然有判断，本质还是调用这个方法<br> 里面的细节不详细看了，看初始化的东西，就知道里面是要干啥了。<br> invokeHandlerMethod 还是要说几句关键步骤<ol>
<li>根据 handler 的参数列表，使用 HandlerMethodArgumentResolver 看看能不能处理该参数，设置对应值，如果有处理不了的就异常了</li>
<li>使用参数，调用 handler 方法，获取返回结果</li>
<li>处理响应码，响应码和原因可以使用注解自定义 @ResponseStatus(code = HttpStatus.ACCEPTED, reason = “test”) 如果没自定义，那就spring 自己处理了，大部分都是 200</li>
<li>然后只用 HandlerMethodReturnValueHandler ，看能不能处理返回类型的东西，譬如我们常用 @RestController 或者 @ResponseBody 返回对象或者字符串的，都会在这里就处理了，写入 response，然后后面就跑流程了</li>
</ol>
</li>
<li>getModelAndView 这里的方法，如果响应结果有人处理了，这里就返回 null 了，如果没处理，可能就是返回的 modelandview 或者 view ，构造返回</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/25/spring-mvc-HandlerMapping%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/25/spring-mvc-HandlerMapping%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">spring-mvc-HandlerMapping详解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-25 00:33:25" itemprop="dateCreated datePublished" datetime="2019-09-25T00:33:25+08:00">2019-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-22 11:24:43" itemprop="dateModified" datetime="2019-11-22T11:24:43+08:00">2019-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>HandlerMapping</p>
<p>这个类的主要作用就是匹配 request 有哪个 handler 处理<br>返回的是 HandlerExecutionChain 里面包含 具体的 handler 拦截器 和 跨域处理</p>
<p>重要的 handlerMapping 主要有几个，都是继承</p>
<p>AbstractHandlerMapping </p>
<p>这个类里面处理 拦截器 跨域，url 匹配的类<br>最终，这里实现了 getHandler 方法，并且是 final 的，不允许付款，也就是说，这里定义了寻找 handler 的具体流程</p>
<ol>
<li>getHandlerInternal 这个方法留给子类实现</li>
<li>上一步如果没找到就 getDefaultHandler  这个默认处理器是外部设置的</li>
<li>上面两步没找到，那就是没有了</li>
<li>如果找到了，判断是否为 string，如果是，则认为是 beanName，直接在容器里根据 beanName 获取，这里没捉异常，没获取到就异常出去了</li>
<li>使用这个找到的 handler 构建 HandlerExecutionChain ，添加拦截器</li>
<li>如果是cors跨域请求，分两种，一是 option 方法 handler 换成 PreFlightHandler 内部是 DefaultCorsProcessor 处理的，二是正常请求，带 origin 了，在 chain 里面添加一个 cors 拦截器 CorsInterceptor，内部也是 DefaultCorsProcessor 处理的 </li>
</ol>
<p>接下来，子类各自实现 getHandlerInternal 方法就可以了<br>下面一层有两个子类 </p>
<ol>
<li>AbstractUrlHandlerMapping 这个是基于处理 url 的</li>
<li>AbstractHandlerMethodMapping  </li>
</ol>
<p>AbstractUrlHandlerMapping 里面又添加了一个 rootHandler ，外部设置，用来处理 / 的请求，这里的 getHandlerInternal 处理流程是</p>
<ol>
<li>根据 request 获取 url：lookupPath</li>
<li>使用这个 lookupPath 获取 handler ，调用的是 lookupHandler 方法</li>
<li>如果没找到，判断 URL 是否为 /,如果是，就使用 rootHandler </li>
<li>如果还是 null  就使用 defaultHandler</li>
<li>如果存在了 ，判断是否为 string，如果是，则认为是 beanName，直接在容器里根据 beanName 获取，这里没捉异常，没获取到就异常出去了</li>
<li>validateHandler 验证一下，这个留给子类实现</li>
<li>构建 HandlerExecutionChain，这里构建的 chain 里面添加了 PathExposingHandlerInterceptor 拦截器，可能添加 UriTemplateVariablesHandlerInterceptor 拦截器 这两个拦截器的作用就是在 request 里面设置一些属性，还有 第二步，如果找到 handler 后，构建步骤跟这里的一样</li>
</ol>
<p>这个类有一个 map 存放 url -&gt; handler  有一个方法 registerHandler 给子类往里面注册 handler  </p>
<p>这个抽象类下面，就有2个直接实现了<br>WelcomePageHandlerMapping<br>这个类重写了 getHandlerInternal 方法，根据 request 的 accept ，来判断，如果包含 text/html 那就调用父类，也就是上面的查找流程，否则返回null，也就是，这里只处理 html 请求，不过看名字也就清楚了</p>
<p>SimpleUrlHandlerMapping<br>这个类就是注册处理 handler 或者 handler 的 beanName<br>在本类初始化的过程中，会根据注册的信息完成初始化，简单的说，就是这个对象有一个 Map<String,Object> 左边是 url 右边是 handler 或者 beanName，在初始化过程中，如果是 beanName 那么就会从容器里面获取 handler<br>另外，如果注册的 url 是 / 那么本 handler 就是 rootHandler ，如果 url 是 /* 那么 handler 就是 defaultHandler 注意一点的是 </p>
<p>除了上面有个直接实现，还有一个抽象子类 AbstractDetectingUrlHandlerMapping</p>
<p>AbstractDetectingUrlHandlerMapping<br>这个抽象类，也是在初始化的时候寻找 handler，过程是获取容器里的所有 beanName，使用 determineUrlsForHandler 传入参数是 beanName 来获取 url 数组，如果获取到了，就注册 handler<br>determineUrlsForHandler 这个方法是一个抽象方法，子类实现</p>
<p>接下来的实现类是<br>BeanNameUrlHandlerMapping</p>
<p>那么这个类主要功能就是判断 beanName 是不是 / 开头的，如果是，那么就代表，本类是 handler 类，处理的url 就是 beanName， 如果 beanName 没有 / 开头，继续看别名</p>
<p>这里是分割线，接下来换另一个继承分支,这个分支才是正常流程常走的地方<br>AbstractHandlerMethodMapping<br>这里面重要的属性是 MappingRegistry 就是 handler 注册的地方，在初始化的时候做一些事情<br>首先，获取所有 beanName， 然后排除一部分代理 也就是 beanName 以 scopedTarget. 开头的，排除后，就获取 beanName 对应的 class ，判断是否为 hander ，如果是，就找里面的 method 然后注册 handler<br>这里的 handler 类型都是 HandleMehtod ，是根据方法划分的，上面的 AbstractUrlHandlerMapping 是一个 bean 就是 handler<br>判断是否为 handler 类型方法 isHandler 由子类实现，<br>获取 handlemethod 的方法 detectHandlerMethods 逻辑为</p>
<ol>
<li>获取具体类型,如果是代理，就找到具体类</li>
<li>过滤方法的具体逻辑是 getMappingForMethod ，这个也是子类实现，方法包含了类型的所有接口</li>
<li>找到后就注册 handler ，三个参数 mapping, handler, method  其中 mapping 是泛型的，handler 就是处理的 beanName 或者 handler 对象，method 就是找到的方法</li>
<li>使用 handlerMethodsInitialized 方法处理已经注册的 handler ，空方法，留给子类覆盖</li>
</ol>
<p>上面是初始化的过程，后面要具体看看 MappingRegistry 的注册和逻辑<br>这个类有一个注册方法 register ，里面会 initCorsConfiguration 初始化自定义 cors 跨域配置，这是一个抽象方法</p>
<p>这个类的 getHandlerInternal 逻辑</p>
<ol>
<li>处理 url 获取 lookupPath</li>
<li>根据 url 找 HandlerMethod  方法是 lookupHandlerMethod<br>怎么找的，就是根据 url 找 mapping 如果没找到 mapping  如果有 mapping（列表） 那就遍历 根据 mapping 和 request 找匹配的 mapping 方法是 getMatchingMapping  子类实现<br>如果没有匹配的，那就使用所有的 mapping 都试着匹配一次<br>如果没匹配到 handleNoMatch 默认返回 null<br>匹配到的话，getMappingComparator 根据 request 获取排序器，将匹配到的 mapping 进行排序，然后找到里面最匹配的一个，最匹配的一个就是第一个，实际上排序就完成了选择了，如果多个匹配，则异常<br>执行 handleMatch 匹配成功方法，这里只是设置一个 request 属性<br>返回 HandlerMethod</li>
</ol>
<p>接下来继续看下面的子类<br>RequestMappingInfoHandlerMapping<br>这里，泛型已经具体了 RequestMappingInfo  很多匹配逻辑都在里面，后面可以看看<br>这个抽象类实现了一些方法  </p>
<ol>
<li>getMatchingMapping  找到匹配的方法 ，具体是 RequestMappingInfo.getMatchingCondition（request）</li>
<li>getMappingComparator 获取排序器，实际上是 RequestMappingInfo 有 compareTo 方法了，直接比较就行了</li>
<li>handleMatch 在匹配成功后做的一些操作，继续设置一些 request 属性，譬如 mediatype uri 参数</li>
<li>handleNoMatch 在没匹配后做的一些操作，具体就是，看到底是什么不匹配，抛出对应异常，譬如 HttpRequestMethodNotSupportedException ,HttpMediaTypeNotSupportedException 等</li>
</ol>
<p>接下来就到最终实现类了<br>RequestMappingHandlerMapping<br>首先，他要实现的是 isHandler ，判断 bean 是否为处理类，逻辑是类上有注解 @Controller 或者 @RequestMapping ，注解上的注解也行<br>接下来是 getMappingForMethod 这个方法是判断 method 是否为处理方法的。逻辑是看有没有 @RequestMapping 注解，注解上的注解也行，譬如 @GetMapping<br>然后 initCorsConfiguration 方法，重写了，处理类上和方法上的 @CrossOrigin 注解，自定义 cors 跨域配置<br>最后有一个 match 方法，是 MatchableHandlerMapping 接口定义的，使用 request 和 pattern 进行匹配</p>
<p>上面留了两个坑，AbstractHandlerMethodMapping 类里面的 MappingRegistry 和 RequestMappingInfoHandlerMapping 类里面的 RequestMappingInfo<br>这两个涉及到注册 handler 和 判断是否匹配，待填</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/24/spring-webmvc-%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/24/spring-webmvc-%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">spring-webmvc 分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-24 00:31:00" itemprop="dateCreated datePublished" datetime="2019-09-24T00:31:00+08:00">2019-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-22 11:24:36" itemprop="dateModified" datetime="2019-11-22T11:24:36+08:00">2019-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ApplicationContextInitializer"><a href="#ApplicationContextInitializer" class="headerlink" title="ApplicationContextInitializer"></a>ApplicationContextInitializer</h2><ol>
<li>class org.springframework.boot.context.config.DelegatingApplicationContextInitializer</li>
<li>class org.springframework.boot.context.ContextIdApplicationContextInitializer</li>
<li>class org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer</li>
<li>class org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer</li>
<li>class org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer</li>
<li>class org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</li>
</ol>
<h2 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h2><ol>
<li>class org.springframework.boot.context.config.ConfigFileApplicationListener</li>
<li>class org.springframework.boot.context.config.AnsiOutputApplicationListener</li>
<li>class org.springframework.boot.context.logging.LoggingApplicationListener</li>
<li>class org.springframework.boot.context.logging.ClasspathLoggingApplicationListener</li>
<li>class org.springframework.boot.autoconfigure.BackgroundPreinitializer</li>
<li>class org.springframework.boot.context.config.DelegatingApplicationListener</li>
<li>class org.springframework.boot.builder.ParentContextCloserApplicationListener</li>
<li>class org.springframework.boot.ClearCachesApplicationListener</li>
<li>class org.springframework.boot.context.FileEncodingApplicationListener</li>
<li>class org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener</li>
</ol>
<p>org.springframework.boot.SpringApplicationRunListener</p>
<p>org.springframework.boot.context.event.EventPublishingRunListener</p>
<p>使用的 ApplicationContext<br>org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext</p>
<p>继承下面的<br>ServletWebServerApplicationContext</p>
<p>先放一张图<br><img src="/2019/09/24/spring-webmvc-%E5%88%86%E6%9E%90/spring-mvc.png" class="" title="This is an example image"></p>
<h2 id="9大组件"><a href="#9大组件" class="headerlink" title="9大组件"></a>9大组件</h2><p>编号后面是接口，下面是默认实现</p>
<ol>
<li>MultipartResolver<br>class org.springframework.web.multipart.support.StandardServletMultipartResolver<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MultipartResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isMultipart</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">MultipartHttpServletRequest <span class="title">resolveMultipart</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> MultipartException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cleanupMultipart</span><span class="params">(MultipartHttpServletRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>顾名思义，这里就是处理文件上传的地方，做三件事，判断请求是不是文件上传，将 request 转换成 文件上传 request，以及清理工作<br><code>StandardServletMultipartResolver</code> 标准解析，其实只是从标准 request 解析part 出来，所谓转行 request，实际上是让内部知道是否为文件上传请求，接收一个参数，用来控制是否立即解析，<br>默认是立即解析，非立即就是在第一次调用 getMultipart 的时候触发解析</p>
<ol>
<li>LocaleResolver<br>class org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LocaleResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Locale <span class="title">resolveLocale</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setLocale</span><span class="params">(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable Locale locale)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语言解析，两个方法，解析使用的语言，设置语言。<code>AcceptHeaderLocaleResolver</code> 这个就是从请求头里面解析，但是没法设置   </p>
<ol>
<li>ThemeResolver<br>class org.springframework.web.servlet.theme.FixedThemeResolver<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThemeResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">resolveThemeName</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setThemeName</span><span class="params">(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable String themeName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>主题解析和设置</p>
<ol>
<li>HandlerMapping<br>class org.springframework.web.servlet.handler.SimpleUrlHandlerMapping<br>class org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping<br>class org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping<br>class org.springframework.boot.autoconfigure.web.servlet.WelcomePageHandlerMapping</li>
</ol>
<p>重头戏，这里很重要<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMapping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + ".pathWithinHandlerMapping";</span><br><span class="line"></span><br><span class="line">	String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + ".bestMatchingPattern";</span><br><span class="line"></span><br><span class="line">	String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + ".introspectTypeLevelMapping";</span><br><span class="line"></span><br><span class="line">	String URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + ".uriTemplateVariables";</span><br><span class="line"></span><br><span class="line">	String MATRIX_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + ".matrixVariables";</span><br><span class="line"></span><br><span class="line">	String PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.class.getName() + ".producibleMediaTypes";</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只有一个方法，返回 <code>HandlerExecutionChain</code>,这里面将有 handler 实例（controller 里面的方法）还有拦截器，里面是具体执行的业务逻辑<br>列出里面关键字段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerInterceptor&gt; interceptorList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> interceptorIndex = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>上面关键的是 RequestMappingHandlerMapping 大部分业务处理在这里</p>
<ol>
<li>HandlerAdapter<br>class org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter<br>class org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter<br>class org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter</li>
</ol>
<p>为什么会有 adapter 呢，是为了增强，需要在业务逻辑前后做一些处理，譬如参数注入，返回数据处理等    </p>
<p><code>RequestMappingHandlerAdapter</code> 处理的 handler 为 <code>HandlerMethod</code><br><code>HttpRequestHandlerAdapter</code> 处理的 handler 为 <code>HttpRequestHandler</code><br><code>SimpleControllerHandlerAdapter</code> 处理的 handler 为 <code>Controller</code> 这里的 controler 是一个接口，不是常用的注解  </p>
<p>从 debug 路径来看，大部分的 handler 都是 <code>HandlerMethod</code>, 也就是说，使用的代理是 <code>RequestMappingHandlerAdapter</code><br>除了上面默认的几个外，还有一个实现 <code>SimpleServletHandlerAdapter</code> 这个是处理 <code>Servlet</code> 的  </p>
<p>接下来重点关照 <code>RequestMappingHandlerAdapter</code>    </p>
<p>首先，要看一下调用流程,下面是 <code>doDispatch</code> 方法里面的片段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">String method = request.getMethod();</span><br><span class="line"><span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line"><span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">	<span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></pre></td></tr></table></figure><br>可以看到在获取到对应的 adapter 后，先触发前置拦截器，这里说明一下 <code>mappedHandler</code> 是 <code>HandlerExecutionChain</code> 类型，可以通过调用其 <code>getHandler</code> 方法获取处理类，<code>mappedHandler</code> 里面还有拦截器等其他信息.<br>然后就是 adapter 执行 handler 了，注意传入的参数，请求，响应，以及处理 handler，这个handler 是 adapter 支持的 handler    </p>
<p>看看里面的处理逻辑,很长，又是代码了    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">			HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	ModelAndView mav;</span><br><span class="line">	<span class="comment">// 检查 http method 是否支持，如果需要 session 则判断是否存在 session</span></span><br><span class="line">	checkRequest(request);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">		HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">			Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line">			<span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">				mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// No HttpSession available -&gt; no mutex necessary</span></span><br><span class="line">			mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// No synchronization on session demanded at all...</span></span><br><span class="line">		mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">			applyCacheSeconds(response, <span class="keyword">this</span>.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			prepareResponse(response);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然多，核心方法是 <code>invokeHandlerMethod</code>,其他的是控制代码，后面有兴趣可以仔细看看<br>这个方法又是一个很复杂的方法，需要细看，里面有很多请求处理相关的，譬如参数是如果映射的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">			HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// 包装一下 request，这个就是内部常用到的 WebRequest 的实现类了</span></span><br><span class="line">	ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 处理 @InitBinder 注解的，很少用到，跳过，全局的可以通过 @ControllerAdvice 注解的类定义，全局优先</span></span><br><span class="line">		WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line">		<span class="comment">// @RequestMapping &amp;&amp; @ModelAttribute 注解同时标记的，同上，全局优先,  PS: 这个注解也用的比较少，后面可以瞅瞅</span></span><br><span class="line">		ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line">		<span class="comment">// 这个类继承 HandlerMethod ，new 一个，就是把原来的属性全部赋值给新的对象了</span></span><br><span class="line">		ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">		<span class="comment">// 设置 参数解析，这里就应该熟悉了，比如常用的 @RequestParam 注解等，都是这里处理的，也可以自己定义添加 HandlerMethodArgumentResolver</span></span><br><span class="line">		<span class="comment">// 这里是 HandlerMethodArgumentResolverComposite 里面组合所有的实际解析类</span></span><br><span class="line">		<span class="comment">// 在 getDefaultArgumentResolvers 方法里面，有默认清单</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 设置响应解析，基本同上，接口是 HandlerMethodReturnValueHandler</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			invocableMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">		&#125;</span><br><span class="line">		invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">		invocableMethod.setParameterNameDiscoverer(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这里填充 一些属性 主要是围绕 @ModelAttribute 注解</span></span><br><span class="line">		ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</span><br><span class="line">		mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">		modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">		mavContainer.setIgnoreDefaultModelOnRedirect(<span class="keyword">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// servlet3.0 的异步请求</span></span><br><span class="line">		AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">		asyncWebRequest.setTimeout(<span class="keyword">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">		asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</span><br><span class="line">		asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">		asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</span><br><span class="line">		asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">			Object result = asyncManager.getConcurrentResult();</span><br><span class="line">			mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">			asyncManager.clearConcurrentResult();</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Found concurrent result value ["</span> + result + <span class="string">"]"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 上面都是异步相关，一般都是跳过，这里才是调用，之前的一些字段已经设置到 invocableMethod 里面了 mavContainer 里面包含 session 属性</span></span><br><span class="line">		invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">		<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取响应结果</span></span><br><span class="line">		<span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		webRequest.requestCompleted();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续重点方法分析 <code>invokeAndHandle</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">			Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 调用，获取返回结果，里面涉及到 参数注入，记住一点，处理方法的参数，一定是要 HandlerMethodArgumentResolver 可以处理的</span></span><br><span class="line">	Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置 http 响应状态码，大部分时候，这里是没设置的，除非使用注解 @ResponseStatus 标记</span></span><br><span class="line">	setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于没有返回值的情况，如果是 请求资源没变（http 缓存），或者自定义响应状态码了（譬如204），或者已经被标记处理过了，那么标记处理完成</span></span><br><span class="line">	<span class="comment">// 如果有状态说明原因，也处理完成</span></span><br><span class="line">	<span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">			mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">		mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 否则，接下来就处理响应结果，这是大部分时候走的地方，关于请求参数和响应结果的处理，可以详细看看初始化的时候，spring 默认设置了哪些，这里就不往下看了</span></span><br><span class="line">	mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line">	Assert.state(<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>, <span class="string">"No return value handlers"</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">				returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(getReturnValueHandlingErrorMessage(<span class="string">"Error handling return value"</span>, returnValue), ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取最终结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ModelAndView <span class="title">getModelAndView</span><span class="params">(ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">			ModelFactory modelFactory, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	modelFactory.updateModel(webRequest, mavContainer);</span><br><span class="line">	<span class="keyword">if</span> (mavContainer.isRequestHandled()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ModelMap model = mavContainer.getModel();</span><br><span class="line">	ModelAndView mav = <span class="keyword">new</span> ModelAndView(mavContainer.getViewName(), model, mavContainer.getStatus());</span><br><span class="line">	<span class="keyword">if</span> (!mavContainer.isViewReference()) &#123;</span><br><span class="line">		mav.setView((View) mavContainer.getView());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (model <span class="keyword">instanceof</span> RedirectAttributes) &#123;</span><br><span class="line">		Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();</span><br><span class="line">		HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line">			RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>HandlerExceptionResolver<br>class org.springframework.boot.web.servlet.error.DefaultErrorAttributes<br>class org.springframework.web.servlet.handler.HandlerExceptionResolverComposite</li>
</ol>
<p>异常处理,处理的是 adpeter 调用 handle 方法可能出现的异常<br>在 processDispatchResult 方法里面处理了<br>有一个 HandlerExceptionResolver 列表，处理异常</p>
<ol>
<li>RequestToViewNameTranslator<br>class org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</li>
</ol>
<p>处理响应结果和异常，没有返回 mv 的时候，尝试获取对应的view<br>这里只在 getDefaultViewName 方法里面使用，从 request 的url 找到对应的模版</p>
<ol>
<li>ViewResolver<br>class org.springframework.web.servlet.view.ContentNegotiatingViewResolver<br>class org.springframework.web.servlet.view.BeanNameViewResolver<br>class org.springframework.web.servlet.view.ViewResolverComposite<br>class org.springframework.web.servlet.view.InternalResourceViewResolver</li>
</ol>
<p>视图渲染<br>根据 view name 找到对应的视图<br>一个 ViewResolver 列表，遍历</p>
<ol>
<li>FlashMapManager<br>class org.springframework.web.servlet.support.SessionFlashMapManager</li>
</ol>
<p>用来保存上一次请求设置的数据，这样在本次请求就可以获取了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/23/spring%E5%88%86%E6%9E%90-aop%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/23/spring%E5%88%86%E6%9E%90-aop%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">spring分析-aop详解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-23 23:39:31" itemprop="dateCreated datePublished" datetime="2019-09-23T23:39:31+08:00">2019-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-22 11:23:57" itemprop="dateModified" datetime="2019-11-22T11:23:57+08:00">2019-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>总所周知，aop 的核心是动态代理 ，但是 动态代理 是如何跟 ioc 容器结合，是什么时候生成代理对象，怎么生成代理对象，什么情况下才会有 aop ， advice ， advisor， pointcut 这些概念在代码里面的体现?<br>我们需要知道 spring 的 aop 在容器中的运行机制，而不是一句简单的动态代理</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>核心类为 <code>AnnotationAwareAspectJAutoProxyCreator</code> ,为什么一上来就是这个类，可以看 springboot 里面 aop 的自动<br>配置类里面，就可以看到这个类了<br>那么这个类是怎么起作用的，我们知道，aop 的核心就是动态代理，代理，肯定需要代理一个对象，<br>我们也很清楚，被代理的是 spring 容器里面的 bean 实例，那么，需要使用代理对象替换容器里面的对象<br>需要使用 ioc 的扩展接口 <code>BeanPostProcessor</code> 及其子接口，我们往这个类的父类上看看，就可以<br>看到 <code>AbstractAutoProxyCreator</code> 这个类就是实现了 <code>SmartInstantiationAwareBeanPostProcessor</code> 接口</p>
<p>经过简单的测试和 debug 跟踪，发现，代理发生的方式是 <code>postProcessAfterInitialization</code> 这个方法是在<br>bean 实例化之后发生的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">		Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">			<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重点在 <code>wrapIfNecessary</code> 方法，这个地方就是用来判断是否需要使用代理,贴出关键代码片段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create proxy if we have advice.</span></span><br><span class="line"><span class="comment">// 这里就是找代理增强的动作</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">	<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">	<span class="comment">// 创建代理</span></span><br><span class="line">	Object proxy = createProxy(</span><br><span class="line">			bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">	<span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">	<span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，上面就是两个关键动作，找到需要增强的动作，然后创建代理<br>我们先看看怎么找增强动作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 找出增强</span></span><br><span class="line">	List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">	<span class="comment">// 是否可以用在本类型上</span></span><br><span class="line">	List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">	<span class="comment">// 这个留给子类玩</span></span><br><span class="line">	extendAdvisors(eligibleAdvisors);</span><br><span class="line">	<span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">	    <span class="comment">// 排序</span></span><br><span class="line">		eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是在类 AnnotationAwareAspectJAutoProxyCreator 里面的实现</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Add all the Spring advisors found according to superclass rules.</span></span><br><span class="line">	List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line">	<span class="comment">// Build Advisors for all AspectJ aspects in the bean factory.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorsBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">		advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到先调用 super 的，然后调用本类的，找 aspect 相关的<br>实际上，这里处理的是两个类型的，一般增强的动作，概念上就是 Adivce ，而它下面可以分为两个分支<br>一个是 aspect 的 before after around 这一批，另一个是 intercept 这一批<br>第一批通常是我们自定义用的，第二批通常是框架用的，如果是框架用，通常直接就注册 advisor 了<br>这里父类处理的就是 框架的，子类处理的，就是自定义的，我们详细看看<br>先看父类处<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (advisorNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">	<span class="comment">// uninitialized to let the auto-proxy creator apply to them!</span></span><br><span class="line">	advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">			<span class="keyword">this</span>.beanFactory, Advisor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">	<span class="keyword">this</span>.cachedAdvisorBeanNames = advisorNames;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">advisors.add(<span class="keyword">this</span>.beanFactory.getBean(name, Advisor<span class="class">.<span class="keyword">class</span>))</span>;</span><br></pre></td></tr></table></figure><br>这里是在容器里面直接找 <code>Advisor</code> 类型的 bean，我们可以结合自己使用 aop 的方式看<br>我们通常使用 aop 就是定义 aspect 使用 @Aspect 注解 ，定义 pointcut 和 advice<br>基本确定，自己使用的 aop 肯定不是在这里处理的，那么我们再看看子类的处理(只有关键步骤)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">		<span class="keyword">this</span>.beanFactory, Object<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// We must be careful not to instantiate beans eagerly as in this case they</span></span><br><span class="line"><span class="comment">// would be cached by the Spring container but would not have been weaved.</span></span><br><span class="line">Class&lt;?&gt; beanType = <span class="keyword">this</span>.beanFactory.getType(beanName);</span><br><span class="line"><span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">	aspectNames.add(beanName);</span><br><span class="line">	AspectMetadata amd = <span class="keyword">new</span> AspectMetadata(beanType, beanName);</span><br><span class="line">	<span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">		MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">				<span class="keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">		List&lt;Advisor&gt; classAdvisors = <span class="keyword">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">		&#125;</span><br><span class="line">		advisors.addAll(classAdvisors);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Per target or per this.</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Bean with name '"</span> + beanName +</span><br><span class="line">					<span class="string">"' is a singleton, but aspect instantiation model is not singleton"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">				<span class="keyword">new</span> PrototypeAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">		<span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">		advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一般走上面的判断，判断就是看是单例还是原型，重点逻辑是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">		<span class="keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">List&lt;Advisor&gt; classAdvisors = <span class="keyword">this</span>.advisorFactory.getAdvisors(factory);</span><br></pre></td></tr></table></figure></p>
<p>这里获取 Advisor ，但是之前说过了，我们自定使用的 aop 是没有实现 Advisor 的，我们使用的是注解 @Aspect @Pointcut @Before @Around 等<br>那么，里面肯定有一个转换过程，我们进去看看 getAdvisors 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;</span><br><span class="line">	Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);</span><br><span class="line">	<span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">		advisors.add(advisor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// Find introduction fields.</span></span><br><span class="line"><span class="keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;</span><br><span class="line">	Advisor advisor = getDeclareParentsAdvisor(field);</span><br><span class="line">	<span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">		advisors.add(advisor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>里面有两个重点，一个是处理方法，一个是处理字段<br>自己可以进去看看，方法是没有 @Pointcut 注解的，都要处理<br>处理的逻辑就是方法带 Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class 注解的<br>构造 InstantiationModelAwarePointcutAdvisorImpl 返回，我们清楚，这里就有了 Advice 增强动作，pointcut 哪里增强<br>事件上 beforeAdvice 也有哪里增强的逻辑（before），所以真正标识在哪里增强的，应该是 Advisor 实例，这个是 spring 内部帮忙处理的</p>
<p>在看看怎么处理字段的<br>它处理的是带 @DeclareParents 注解的，返回 DeclareParentsAdvisor 实例，具体的，可以看看这个注解的用法，这里就不详看了  </p>
<p>到这里，找到 Advisor 哪里增强，就结束了，接下来就是创建代理的过程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建代理</span></span><br><span class="line">Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br></pre></td></tr></table></figure></p>
<p>传入的参数，class 类型，beanName，这里的 specificInterceptors 就是返回的 Advisor ，保证一下原始对象<br>我们看看创建代理的详细过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, @Nullable String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">			@Nullable Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">		AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">	proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">			proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">	proxyFactory.addAdvisors(advisors);</span><br><span class="line">	proxyFactory.setTargetSource(targetSource);</span><br><span class="line">	customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">	proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">	<span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">		proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看上起很多，事件上逻辑很简单 </p>
<ol>
<li>判断使用 cglib 还是 java 的动态代理</li>
<li>buildAdvisors 其实就是返回之前的参数，里面会添加自定义的（commonInterceptors），但是通常是没有</li>
<li>创建代理<br>重点在创建代理，我们已经知道了，只有两种情况，直接看就行了<br>先看看 cglib 的，先要会 cglib 的基本 api 才行  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">Enhancer enhancer = createEnhancer();</span><br><span class="line"><span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">	enhancer.setClassLoader(classLoader);</span><br><span class="line">	<span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">			((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">		enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</span><br><span class="line"></span><br><span class="line">Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">	types[x] = callbacks[x].getClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(</span><br><span class="line">		<span class="keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line"><span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面重点有两个，一个是设置 callback 一个是 setCallbackFilter<br>callback 是一个数组 ProxyCallbackFilter 里面有一个方法，返回 int 类型，是 callback 数组的下标，对应的 callback 处理<br>重点关注 aop 的 callback 就可以了 DynamicAdvisedInterceptor 使用的是这个<br>里面重点就是一行，其他的可以自己看<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br></pre></td></tr></table></figure></p>
<p>里面的具体调用过程就是代理过程了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//	We start with an index of -1 and increment early.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object interceptorOrInterceptionAdvice =</span><br><span class="line">		<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line"><span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">	<span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line">	<span class="comment">// been evaluated and found to match.</span></span><br><span class="line">	InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">			(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">	<span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">		<span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Dynamic matching failed.</span></span><br><span class="line">		<span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">		<span class="keyword">return</span> proceed();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// It's an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">	<span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">	<span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个调用模式可以学一学<br>到这里，cglib 的实现就看完了，其实大部分时候，就是用的 cglib 动态代理<br>jdk 的动态代理，就是实现 <code>InvocationHandler</code> 然后看看 invoke 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		MethodInvocation invocation;</span><br><span class="line">	Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">	Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">			<span class="comment">// The target does not implement the equals(Object) method itself.</span></span><br><span class="line">			<span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">			<span class="comment">// The target does not implement the hashCode() method itself.</span></span><br><span class="line">			<span class="keyword">return</span> hashCode();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">			<span class="comment">// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span></span><br><span class="line">			<span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">				method.getDeclaringClass().isAssignableFrom(Advised<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">			<span class="comment">// Service invocations on ProxyConfig with the proxy config...</span></span><br><span class="line">			<span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object retVal;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">			<span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">			oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">			setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Get as late as possible to minimize the time we "own" the target,</span></span><br><span class="line">		<span class="comment">// in case it comes from a pool.</span></span><br><span class="line">		target = targetSource.getTarget();</span><br><span class="line">		Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Get the interception chain for this method.</span></span><br><span class="line">		List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check whether we have any advice. If we don't, we can fallback on direct</span></span><br><span class="line">		<span class="comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span></span><br><span class="line">		<span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">			<span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line">			<span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line">			<span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">			Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">			retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// We need to create a method invocation...</span></span><br><span class="line">			invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">			<span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">			retVal = invocation.proceed();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Massage return value if necessary.</span></span><br><span class="line">		Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">		<span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">				returnType != Object<span class="class">.<span class="keyword">class</span> &amp;&amp; <span class="title">returnType</span>.<span class="title">isInstance</span>(<span class="title">proxy</span>) &amp;&amp;</span></span><br><span class="line"><span class="class">				!<span class="title">RawTargetAccess</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line">			<span class="comment">// Special case: it returned "this" and the return type of the method</span></span><br><span class="line">			<span class="comment">// is type-compatible. Note that we can't help if the target sets</span></span><br><span class="line">			<span class="comment">// a reference to itself in another returned object.</span></span><br><span class="line">			retVal = proxy;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line">					<span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">			<span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">			targetSource.releaseTarget(target);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">			<span class="comment">// Restore old proxy.</span></span><br><span class="line">			AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 一大坨代码，自己看了<br> 到此，aop 流程就结束了 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/21/spring%E5%88%86%E6%9E%90-aop%E6%B5%85%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/21/spring%E5%88%86%E6%9E%90-aop%E6%B5%85%E6%9E%90/" class="post-title-link" itemprop="url">spring分析-aop浅析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-21 23:38:49" itemprop="dateCreated datePublished" datetime="2019-09-21T23:38:49+08:00">2019-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-22 11:23:50" itemprop="dateModified" datetime="2019-11-22T11:23:50+08:00">2019-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li>Advice 通知<br>定义在连接点做什么，BeforeAdvice，AfterAdvice，ThrowsAdvice 等</li>
<li>Pointcut 切点<br>定义 Advice 作用哪个连接点</li>
<li>Advisor 通知器<br>组合 Advice 和 Pointcut</li>
</ol>
<p><strong>动态代理</strong></p>
<ol>
<li>JDK 的动态代理（基于接口的）</li>
<li>Cglib 的字节码增强（spring5 还有 Objenesis ）</li>
</ol>
<p>简单点说， Advice 就是要做什么 ， Pointcut 是在哪里做，通常我们不需要关注 Advisor ，这个是 spring 内部用来连接 Advice 和 Pointcut 的<br>Advice 有很两种，一种是 beforeAdvice，afterAdvice，aroundAdvie 这是一类，还有 Interceptor 也是一类<br>通常，我们用户使用注解方式的，使用的是第一类，spring 内部扩展，使用的是第二类，譬如 spring-tx 事务</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Luo lei"
    src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Luo lei</p>
  <div class="site-description" itemprop="description">主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Luo lei</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  <script src="/js/local-search.js"></script>












    <div id="pjax">

  

  

  


    </div>
</body>
</html>
