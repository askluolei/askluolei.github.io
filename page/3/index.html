<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="Askluolei" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
<meta name="keywords" content="java, js, vue, go, 读书, 笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="Askluolei">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;3&#x2F;index.html">
<meta property="og:site_name" content="Askluolei">
<meta property="og:description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Askluolei</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Askluolei</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">个人的学习吐槽网站</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/askluolei" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/shiro-%E6%B5%85%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/27/shiro-%E6%B5%85%E6%9E%90/" class="post-title-link" itemprop="url">shiro-浅析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-07-27 00:45:58 / 修改时间：00:47:26" itemprop="dateCreated datePublished" datetime="2019-07-27T00:45:58+08:00">2019-07-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>shiro 的核心接口就是 <code>SecurityManager</code> , 所有的实现，全是围绕这个接口的<br>这个接口继承了 <code>Authenticator</code> 认证接口 , <code>Authorizer</code> 权限接口 , <code>SessionManager</code> session 管理接口<br>我们先分别看看这些接口的定义  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Authenticator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationInfo <span class="title">authenticate</span><span class="params">(AuthenticationToken authenticationToken)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>认证接口，是有一个方法，token 换成  info ，虽然方法名是 <code>authenticate</code> 但是，认证流程不是在这里实现的（我们后面具体分析）<br>先说 token 和 info 的 区别， token 通常是用户(请求)带过来的凭证（用户名密码，accessToken 等）,默认是 <code>UsernamePasswordToken</code> 实现<br>这里可以自己扩展，而 info 是什么呢？ 凭证是请求带的，不一定是真的有效的凭证，我们需要根据这个凭证去数据库（缓存）去查询系统信息<br>简单点，凭证是用户名密码， info 就是根据用户名密码，返回这个用户的认证信息 用户名，加密（hash）过的密码，还有其他信息（角色，权限）  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Authorizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPermitted</span><span class="params">(PrincipalCollection principals, String permission)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPermitted</span><span class="params">(PrincipalCollection subjectPrincipal, Permission permission)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] isPermitted(PrincipalCollection subjectPrincipal, String... permissions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] isPermitted(PrincipalCollection subjectPrincipal, List&lt;Permission&gt; permissions);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPermittedAll</span><span class="params">(PrincipalCollection subjectPrincipal, String... permissions)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPermittedAll</span><span class="params">(PrincipalCollection subjectPrincipal, Collection&lt;Permission&gt; permissions)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(PrincipalCollection subjectPrincipal, String permission)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(PrincipalCollection subjectPrincipal, Permission permission)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkPermissions</span><span class="params">(PrincipalCollection subjectPrincipal, String... permissions)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkPermissions</span><span class="params">(PrincipalCollection subjectPrincipal, Collection&lt;Permission&gt; permissions)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasRole</span><span class="params">(PrincipalCollection subjectPrincipal, String roleIdentifier)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] hasRoles(PrincipalCollection subjectPrincipal, List&lt;String&gt; roleIdentifiers);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasAllRoles</span><span class="params">(PrincipalCollection subjectPrincipal, Collection&lt;String&gt; roleIdentifiers)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkRole</span><span class="params">(PrincipalCollection subjectPrincipal, String roleIdentifier)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkRoles</span><span class="params">(PrincipalCollection subjectPrincipal, Collection&lt;String&gt; roleIdentifiers)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkRoles</span><span class="params">(PrincipalCollection subjectPrincipal, String... roleIdentifiers)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>权限这个接口方法很多，因为权限可以根据角色和权限两个维度控制，而权限，除了可以使用字符串（应该叫权限表达式）,在内部，还以对象 <code>Permission</code> 标识<br>只要记住，这个接口就是用来验证权限的  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SessionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Session <span class="title">start</span><span class="params">(SessionContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Session <span class="title">getSession</span><span class="params">(SessionKey key)</span> <span class="keyword">throws</span> SessionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>session 管理，但是要注意的是，这里的 session 跟 servlet 里面的session 不是一个东西，虽然这里的 session 也可以支持 servlet 的<br>但是，这个 session 也可以用在非web环境里面<br>其中 <code>SessionContext</code> 是继承 Map 的 主要有 host 和 sessionId 两个属性（接口的 get set）<br><code>SessionKey</code> 这个里面就只有一个 <code>getSessionId</code> 方法了  </p>
<p>父类接口看完了，接下来看看 <code>SecurityManager</code> 里面的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SecurityManager</span> <span class="keyword">extends</span> <span class="title">Authenticator</span>, <span class="title">Authorizer</span>, <span class="title">SessionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Subject <span class="title">login</span><span class="params">(Subject subject, AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logout</span><span class="params">(Subject subject)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Subject <span class="title">createSubject</span><span class="params">(SubjectContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法很少，登录，登出，创建 <code>Subject</code> （接口），这个对象代表用户，他本身可以验证权限<br><code>SubjectContext</code> 里面继承 Map 添加了一些属性的 get set 方法，比如 <code>SecurityManager</code>, <code>sessionId</code>, <code>Subject</code> … 可以自己看<br>下面看看 <code>SecurityManager</code> 的实现，继承关系非常简单，一条直线，看类名就清楚每层是干什么的了  </p>
<p><code>CachingSecurityManager</code><br>这层直接继承 <code>SecurityManager</code> 里面有一个 <code>CacheManager</code> 当调用 <code>setCacheManager</code> 会调用 <code>afterCacheManagerSet</code> 这个是空方法，子类实现<br>很清楚，这一层只是加上了缓存管理，至于缓存怎么用，要看子类  </p>
<p><code>RealmSecurityManager</code><br><code>Realm</code> 这个是很关键的接口，可以代表数据源，无论认证还是授权，具体数据都是从 <code>Realm</code> 里面取的<br>这里维护了一个 <code>Collection&lt;Realm&gt;</code> 集合，当完成 <code>setRealms</code> 调用后会触发 <code>afterRealmsSet</code> 方法<br>现在的默认实现是如果 <code>Realm</code> 实现了 <code>CacheManagerAware</code> 接口，就把上层的 <code>CacheManager</code> 设置进去  </p>
<p><code>AuthenticatingSecurityManager</code><br>这一层看名字就大概知道了，处理认证的，内部一个 <code>Authenticator</code> 实现，用来处理认证方法<br>默认的实现是 <code>ModularRealmAuthenticator</code>  是基于一个 <code>Realm</code> 的认证器，在 <code>afterRealmsSet</code> 方法，设置的 <code>Realm</code> 也会设置到这里面<br>然后将认证方法 <code>authenticate</code> 委托给内部的 <code>Authenticator</code> 实现了<br>后面具体看看 <code>ModularRealmAuthenticator</code> 的实现，大部分时候，我们不会修改这个实现  </p>
<p><code>AuthorizingSecurityManager</code><br>跟上面认证一样，内部一个 <code>Authorizer</code> 实例，将授权相关的方法全部委托给内部实例处理，默认是 <code>ModularRealmAuthorizer</code><br>也是基于 <code>Realm</code> 的实现，后面具体看看 <code>ModularRealmAuthorizer</code> 内部实现  </p>
<p><code>SessionsSecurityManager</code><br>同上，内部 <code>SessionManager</code> 的默认实现为 <code>DefaultSessionManager</code>，相关方法委托<br>构造或者 set 了 <code>SessionManager</code> 后会触发 <code>afterSessionManagerSet</code> 方法，<br>目前的实现是，如果 <code>SessionManager</code> 实现接口 <code>CacheManagerAware</code> 就把上层的 <code>CacheManager</code> 设置进去  </p>
<p><code>DefaultSecurityManager</code><br>上面三层分别处理了 <code>Authenticator, Authorizer, SessionManager</code> 接口<br>这一层重点有3个属性<br><code>RememberMeManager</code><br><code>SubjectDAO</code>  默认实现 <code>DefaultSubjectDAO</code><br><code>SubjectFactory</code> 默认实现 <code>DefaultSubjectFactory</code><br>这个里面要实现 <code>SecurityManager</code> 接口自己的3个方法 <code>login</code>, <code>logout</code>, <code>createSubject</code>  </p>
<ol>
<li><p>login </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Subject <span class="title">login</span><span class="params">(Subject subject, AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">	AuthenticationInfo info;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		info = authenticate(token);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (AuthenticationException ae) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			onFailedLogin(token, ae, subject);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">				log.info(<span class="string">"onFailedLogin method threw an "</span> +</span><br><span class="line">						<span class="string">"exception.  Logging and propagating original AuthenticationException."</span>, e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> ae; <span class="comment">//propagate</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Subject loggedIn = createSubject(token, info, subject);</span><br><span class="line"></span><br><span class="line">	onSuccessfulLogin(token, info, loggedIn);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> loggedIn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑很简单，这里就不细讲了<br>其中 <code>onFailedLogin</code> 和 <code>onSuccessfulLogin</code> 分别触发 <code>rememberMeFailedLogin</code>, <code>rememberMeFailedLogin</code> ，里面又是调用 <code>RememberMeManager</code> (如果存在) 的方法  </p>
</li>
<li><p>logout</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (subject == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Subject method argument cannot be null."</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	beforeLogout(subject);</span><br><span class="line"></span><br><span class="line">	PrincipalCollection principals = subject.getPrincipals();</span><br><span class="line">	<span class="keyword">if</span> (principals != <span class="keyword">null</span> &amp;&amp; !principals.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">			log.debug(<span class="string">"Logging out subject with primary principal &#123;&#125;"</span>, principals.getPrimaryPrincipal());</span><br><span class="line">		&#125;</span><br><span class="line">		Authenticator authc = getAuthenticator();</span><br><span class="line">		<span class="keyword">if</span> (authc <span class="keyword">instanceof</span> LogoutAware) &#123;</span><br><span class="line">			((LogoutAware) authc).onLogout(principals);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		delete(subject);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		<span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">			String msg = <span class="string">"Unable to cleanly unbind Subject.  Ignoring (logging out)."</span>;</span><br><span class="line">			log.debug(msg, e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			stopSession(subject);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">				String msg = <span class="string">"Unable to cleanly stop Session for Subject ["</span> + subject.getPrincipal() + <span class="string">"] "</span> +</span><br><span class="line">						<span class="string">"Ignoring (logging out)."</span>;</span><br><span class="line">				log.debug(msg, e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑也不复杂，先触发 <code>beforeLogout</code> 方法，当前实现是 <code>rememberMeLogout</code> 调用 <code>RememberMeManager</code><br>然后如果认证器需要感知登出操作 <code>LogoutAware</code> 也去触发<br>删除 subject 和 停止 session<br>这里面可以看到 <code>SubjectDAO</code> 主要做 subject 的增删改查  </p>
</li>
<li><p>createSubject</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Subject <span class="title">createSubject</span><span class="params">(SubjectContext subjectContext)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//create a copy so we don't modify the argument's backing map:</span></span><br><span class="line">	SubjectContext context = copy(subjectContext);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ensure that the context has a SecurityManager instance, and if not, add one:</span></span><br><span class="line">	context = ensureSecurityManager(context);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 重点在这里，这里会拿到 session （session 存储在服务端，根据 sessionId（sessionKey） 来获取）</span></span><br><span class="line">	context = resolveSession(context);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Similarly, the SubjectFactory should not require any concept of RememberMe - translate that here first</span></span><br><span class="line">	<span class="comment">//if possible before handing off to the SubjectFactory:</span></span><br><span class="line">	context = resolvePrincipals(context);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里创建的时候，会把 session 里面的一些信息带出来</span></span><br><span class="line">	Subject subject = doCreateSubject(context);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//save this subject for future reference if necessary:</span></span><br><span class="line">	<span class="comment">//(this is needed here in case rememberMe principals were resolved and they need to be stored in the</span></span><br><span class="line">	<span class="comment">//session, so we don't constantly rehydrate the rememberMe PrincipalCollection on every operation).</span></span><br><span class="line">	<span class="comment">//Added in 1.2:</span></span><br><span class="line">	save(subject);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> subject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>登录成功后，会创建 <code>SubjectContext</code> 然后调用这个方法<br>后面可以详细看看 <code>SubjectDAO</code> <code>SubjectFactory</code>, <code>RememberMeManager</code>(没有默认值)<br>到这里，就已经可以用了，最后一层是对 web 应用的适配  </p>
</li>
</ol>
<p><code>DefaultWebSecurityManager</code><br>这里面将一些相关类，全部换成 web 的实现了（大部分都是从之前的类继承下来的）<br>后面详看 </p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>之前说过了，认证是委托给内部实现了，我们直接看具体实现 <code>ModularRealmAuthenticator</code><br>继承 <code>AbstractAuthenticator</code> 这里面维护 <code>AuthenticationListener</code> 列表，在登录成功，失败，和登出的时候用来回调（观察者模式）,<br>同时实现了 <code>authenticate</code> 固定了登录实现流程，留出一个 <code>doAuthenticate</code> 抽象方法子类实现（模版）  </p>
<p><code>ModularRealmAuthenticator</code> 是基于 <code>Realm</code> 的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doAuthenticate</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">	assertRealmsConfigured();</span><br><span class="line">	Collection&lt;Realm&gt; realms = getRealms();</span><br><span class="line">	<span class="keyword">if</span> (realms.size() == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> doSingleRealmAuthentication(realms.iterator().next(), authenticationToken);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> doMultiRealmAuthentication(realms, authenticationToken);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中 <code>doSingleRealmAuthentication</code> 好里面，只有一个认证数据源的时候<br>如果 <code>realm</code> 没返回 info 直接异常<br><code>doMultiRealmAuthentication</code> 就涉及到认证策略了，其中有至少一次，第一次成功，全部成功<br>策略接口是 <code>AuthenticationStrategy</code> 里面有四个方法，</p>
<ol>
<li>所有 realm 认证之前</li>
<li>每个 realm 认证之前</li>
<li>每个 realm 认证之后</li>
<li>所有 realm 认证之后<br>通过这4个方法，在合适的地方抛异常，就可以实现各种策略了，通常不需要我们自己重写，或者自己实现策略<br>默认是至少一个认证成功  </li>
</ol>
<p>我们看看 <code>Realm</code> 接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Realm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(AuthenticationToken token)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">AuthenticationInfo <span class="title">getAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中就有从 token 获取 info 的接口，所以认证就很简单了  </p>
<h3 id="权限验证"><a href="#权限验证" class="headerlink" title="权限验证"></a>权限验证</h3><p><code>ModularRealmAuthorizer</code> 内部实现<br>里面主要涉及有两个相关类 <code>PermissionResolver</code> <code>RolePermissionResolver</code><br>至于权限验证，还是 <code>Realm</code> 做的，找到 <code>Realm</code> 里面也实现 <code>Authorizer</code> 的去验证<br>针对多值交易，只要任意一个 <code>Reaml</code> 里面认证通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPermitted</span><span class="params">(PrincipalCollection principals, Permission permission)</span> </span>&#123;</span><br><span class="line">	assertRealmsConfigured();</span><br><span class="line">	<span class="keyword">for</span> (Realm realm : getRealms()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(realm <span class="keyword">instanceof</span> Authorizer)) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (((Authorizer) realm).isPermitted(principals, permission)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span>[] isPermitted(PrincipalCollection principals, String... permissions) &#123;</span><br><span class="line">	assertRealmsConfigured();</span><br><span class="line">	<span class="keyword">if</span> (permissions != <span class="keyword">null</span> &amp;&amp; permissions.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">boolean</span>[] isPermitted = <span class="keyword">new</span> <span class="keyword">boolean</span>[permissions.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; permissions.length; i++) &#123;</span><br><span class="line">			isPermitted[i] = isPermitted(principals, permissions[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> isPermitted;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>瞅一眼代码就清楚了，那么现在无聊是 认证，还是授权，关键又在 <code>Realm</code> 那里去了  </p>
<h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h3><p>我们需要看看 <code>Realm</code> 的继承体系了<br>跟 manage 的继承体系一样，<br>首先是 <code>CachingRealm</code> 获取 <code>CacheManager</code><br>接着  <code>AuthenticatingRealm</code> </p>
<p>这里有认证流程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AuthenticationInfo <span class="title">getAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">	AuthenticationInfo info = getCachedAuthenticationInfo(token);</span><br><span class="line">	<span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//otherwise not cached, perform the lookup:</span></span><br><span class="line">		info = doGetAuthenticationInfo(token);</span><br><span class="line">		log.debug(<span class="string">"Looked up AuthenticationInfo [&#123;&#125;] from doGetAuthenticationInfo"</span>, info);</span><br><span class="line">		<span class="keyword">if</span> (token != <span class="keyword">null</span> &amp;&amp; info != <span class="keyword">null</span>) &#123;</span><br><span class="line">			cacheAuthenticationInfoIfPossible(token, info);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.debug(<span class="string">"Using cached authentication info [&#123;&#125;] to perform credentials matching."</span>, info);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">		assertCredentialsMatch(token, info);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.debug(<span class="string">"No AuthenticationInfo found for submitted AuthenticationToken [&#123;&#125;].  Returning null."</span>, token);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上层就是调用这里，先从缓存里面获取，没有就调用 <code>doGetAuthenticationInfo</code> 方法（抽象）<br>有返回值，就对比 Credentials<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">assertCredentialsMatch</span><span class="params">(AuthenticationToken token, AuthenticationInfo info)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">	CredentialsMatcher cm = getCredentialsMatcher();</span><br><span class="line">	<span class="keyword">if</span> (cm != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!cm.doCredentialsMatch(token, info)) &#123;</span><br><span class="line">			<span class="comment">//not successful - throw an exception to indicate this:</span></span><br><span class="line">			String msg = <span class="string">"Submitted credentials for token ["</span> + token + <span class="string">"] did not match the expected credentials."</span>;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IncorrectCredentialsException(msg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationException(<span class="string">"A CredentialsMatcher must be configured in order to verify "</span> +</span><br><span class="line">				<span class="string">"credentials during authentication.  If you do not wish for credentials to be examined, you "</span> +</span><br><span class="line">				"can configure an " + AllowAllCredentialsMatcher.class.getName() + " instance.");</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体怎么对比的，后面可以看看 <code>CredentialsMatcher</code> 实现，里面有一套基于密码 hash 的对比方式<br>顺便说一句，这里的 cache 的 key 是 Principal 对象，自定义的对象一定要重新 hashcode 方法  </p>
<p>最后一层就是<br><code>AuthorizingRealm</code><br>这里就是验证权限的<br>权限表达式的解析由 <code>PermissionResolver</code> 处理，里面默认实现是 <code>WildcardPermissionResolver</code><br>规则是 resource:operation  可以多个 : 分割 ,包含多个操作 * 包含所有<br>验证权限，首先得获取到权限数据源里面的权限 <code>doGetAuthorizationInfo</code> 留了一个抽象方法，通过凭证(用户名)来获取权限信息<br>这一层主要处理缓存和匹配<br>到这里就已经结束了，这下面的实现就是具体实现了，譬如 <code>JdbcRealm</code> 等。<br>通常我们都是自定义 <code>Realm</code> 只要继承这个类 <code>AuthorizingRealm</code> 重写获取认证信息和权限信息的方法就可以了  </p>
<h3 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h3><p>这是一个很重要的接口，需要单独拿出来讲 <code>SecurityUtils.getSubject</code> 获取的当前用户，总是非 null 的<br>但是非null，不代表已经认证过了，或者有权限， 如果当前用户没有登录，是会新建一个的<br>通过 subject 对象 可以做登录验证权限操作，和登出操作<br>其实他是包装了 <code>SecurityManager</code> 对象，只是用来表示用户而已  </p>
<p>其实到这里 shiro 的核心包已经看完了<br>但是 shiro 可以跟 web 集成，有 shiro-web 包<br>这个里面其实就一堆过滤器有点有，但是过滤器里面人认证权限校验，还是使用 <code>SecurityUtils.getSubject</code> 获取当前用户<br>然后使用 <code>Subject</code> 的 api 进行权限校验，至于其他的 web 相关的类，大部分都是继承了上面的那些，多了 <code>Request</code> 和 <code>Response</code> 一般都不会用这里的对象的（不排除会用，也可以仔细看看） </p>
<p>web 里面重点的有 <code>AbstractShiroFilter</code> 拦截器 ，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, <span class="keyword">final</span> FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Throwable t = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> ServletRequest request = prepareServletRequest(servletRequest, servletResponse, chain);</span><br><span class="line">		<span class="keyword">final</span> ServletResponse response = prepareServletResponse(request, servletResponse, chain);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">final</span> Subject subject = createSubject(request, response);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//noinspection unchecked</span></span><br><span class="line">		subject.execute(<span class="keyword">new</span> Callable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				updateSessionLastAccessTime(request, response);</span><br><span class="line">				executeChain(request, response, chain);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (ExecutionException ex) &#123;</span><br><span class="line">		t = ex.getCause();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">		t = throwable;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (t <span class="keyword">instanceof</span> ServletException) &#123;</span><br><span class="line">			<span class="keyword">throw</span> (ServletException) t;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (t <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">			<span class="keyword">throw</span> (IOException) t;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//otherwise it's not one of the two exceptions expected by the filter method signature - wrap it in one:</span></span><br><span class="line">		String msg = <span class="string">"Filtered request failed."</span>;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ServletException(msg, t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它会在进入拦截器之前创建 subject 并且绑定当前线程，这样 <code>SecurityUtils.getSubject</code> 就可以正常使用了<br>这里是根据 session 实现的，如果自定义(jjwt) , 那就需要自己定义拦截器，放在最前面进行处理</p>
<p>认证授权，除了可以用在 url 拦截上，还可以用在 方法上，使用 aop （shiro 注解的封装感觉很不错）<br>web 相关的，可以自己细看，下面重点说说与 spring 集成  </p>
<h3 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h3><p>shiro-spring 里面的内容很少<br>重要的只有几个东西  </p>
<ol>
<li><p>LifecycleBeanPostProcessor 这个是用来处理 shiro 内置的生命周期的，将这个注册为 spring 的 bean 那么 shiro 里面的生命周期，就跟 spring bean 的生命周期绑定了<br>主要是 shiro 的两个接口的实现类，都需要注册到 bean ，来处理生命周期 主要是 <code>SecurityManager</code> 和 <code>Realm</code>  还有 <code>Environment</code> 的实现的实现<br>值得注意的一点是，如果你不在乎生命周期，这些，你都可以不注册为 bean </p>
</li>
<li><p>AuthorizationAttributeSourceAdvisor  这个是用来处理 shiro 的注解的，借助 spring-aop 实现的，至于原理，在 aop 里面已经分析过了<br>注解是用来保证方法级别的权限，通常不是必须的，因为功能是通过 http 接口开放出去的，如果有 rpc 相关的，可以使用这个注解<br>因此，只有当你确实需要使用注解，才将这个类注册为 bean， 否则，这个不是必须的 </p>
</li>
<li><p><code>ShiroFilterFactoryBean</code> 这个是用来注册 shiro 的 Filter 的，用来在 http 调用接口的层面做权限控制，web 项目，通常这个是必须要配置的<br>如果你只想用 注解的方式，这个也是可以不注册为 bean 的，里面的 shiro 的 filter 都有 name 的，具体可以看内部的 <code>DefaultFilter</code> 类  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">anon(AnonymousFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class"><span class="title">authc</span>(<span class="title">FormAuthenticationFilter</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class"><span class="title">authcBasic</span>(<span class="title">BasicHttpAuthenticationFilter</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class"><span class="title">logout</span>(<span class="title">LogoutFilter</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class"><span class="title">noSessionCreation</span>(<span class="title">NoSessionCreationFilter</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class"><span class="title">perms</span>(<span class="title">PermissionsAuthorizationFilter</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class"><span class="title">port</span>(<span class="title">PortFilter</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class"><span class="title">rest</span>(<span class="title">HttpMethodPermissionFilter</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class"><span class="title">roles</span>(<span class="title">RolesAuthorizationFilter</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class"><span class="title">ssl</span>(<span class="title">SslFilter</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class"><span class="title">user</span>(<span class="title">UserFilter</span>.<span class="title">class</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>顺便说一句，这里是  factoryBean，他的 getObject 方法返回的实例，才是真实使用的,实际上是 <code>AbstractShiroFilter</code> 类型的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringShiroFilter</span> <span class="keyword">extends</span> <span class="title">AbstractShiroFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">SpringShiroFilter</span><span class="params">(WebSecurityManager webSecurityManager, FilterChainResolver resolver)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">if</span> (webSecurityManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"WebSecurityManager property cannot be null."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		setSecurityManager(webSecurityManager);</span><br><span class="line">		<span class="keyword">if</span> (resolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">			setFilterChainResolver(resolver);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/spring-security%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/27/spring-security%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">spring-security分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-07-27 00:41:34 / 修改时间：00:47:30" itemprop="dateCreated datePublished" datetime="2019-07-27T00:41:34+08:00">2019-07-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <img src="/2019/07/27/spring-security%E5%88%86%E6%9E%90/security-core.png" class="" title="This is an example image">
<p>网上都说 shiro 比 security 好，分析完 shiro 后，发现确实实现的挺轻量级的，而且扩展也比较容易，他实现的代码也很漂亮<br>但是后台开发通常都会用 spring ，spring-security 自然就是官方支持的，有时候为了方便，直接使用 spring-security 了，但是配置都是网上抄的<br>而 spring-security 又像一个全家桶，一个配置，加了一堆东西，有时候出了问题，都不知道怎么排查<br>于是，抱着弄懂原理，心理不慌的想法，开始前线的分析源码  </p>
<p>首先明确一个概念，安全框架的基本功能就是认证授权，至于额外的密码hash，防御攻击之类的，都是额外的操作，security 一键就给你加了一堆东西，虽然用的爽，实际上，连使用者都可能不知道到底添加了哪些功能  </p>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>认证的核心接口是 <code>AuthenticationManager</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthenticationManager</span> </span>&#123;</span><br><span class="line">	<span class="function">Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只有一个认证方法，凭证 <code>Authentication</code> 可以代表认证成功前的请求信息，也可以表示认证成功后的调用凭证信息<br><code>AuthenticationManager</code> 内部已经有实现了 <code>ProviderManager</code>，我们通常不会去重新实现它<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    Class&lt;? extends Authentication&gt; toTest = authentication.getClass();</span><br><span class="line">    AuthenticationException lastException = <span class="keyword">null</span>;</span><br><span class="line">    Authentication result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> debug = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!provider.supports(toTest)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Authentication attempt using "</span></span><br><span class="line">                    + provider.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = provider.authenticate(authentication);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                copyDetails(authentication, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AccountStatusException e) &#123;</span><br><span class="line">            prepareException(e, authentication);</span><br><span class="line">            <span class="comment">// SEC-546: Avoid polling additional providers if auth failure is due to</span></span><br><span class="line">            <span class="comment">// invalid account status</span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InternalAuthenticationServiceException e) &#123;</span><br><span class="line">            prepareException(e, authentication);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            lastException = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Allow the parent to try.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = parent.authenticate(authentication);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ProviderNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// ignore as we will throw below if no other exception occurred prior to</span></span><br><span class="line">            <span class="comment">// calling parent and the parent</span></span><br><span class="line">            <span class="comment">// may throw ProviderNotFound even though a provider in the child already</span></span><br><span class="line">            <span class="comment">// handled the request</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            lastException = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eraseCredentialsAfterAuthentication</span><br><span class="line">                &amp;&amp; (result <span class="keyword">instanceof</span> CredentialsContainer)) &#123;</span><br><span class="line">            <span class="comment">// Authentication is complete. Remove credentials and other secret data</span></span><br><span class="line">            <span class="comment">// from authentication</span></span><br><span class="line">            ((CredentialsContainer) result).eraseCredentials();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent was null, or didn't authenticate (or throw an exception).</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastException == <span class="keyword">null</span>) &#123;</span><br><span class="line">        lastException = <span class="keyword">new</span> ProviderNotFoundException(messages.getMessage(</span><br><span class="line">                <span class="string">"ProviderManager.providerNotFound"</span>,</span><br><span class="line">                <span class="keyword">new</span> Object[] &#123; toTest.getName() &#125;,</span><br><span class="line">                <span class="string">"No AuthenticationProvider found for &#123;0&#125;"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prepareException(lastException, authentication);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> lastException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>逻辑很清晰，内部使用的是 <code>AuthenticationProvider</code> 接口来认证的，而我们如果要自定义的话，通常是实现这个接口，不过内部已经有很多实现了，如果可以满足需求，直接使用内部实现就可以了<br>认证成功和失败都会发布对应的事件，内部的事件都是继承 <code>AbstractAuthenticationFailureEvent</code> 的，只要捕获这个抽象的事件，就可以处理认证相关的事件了，具体的事件列表如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AuthenticationSuccessEvent</span><br><span class="line">AuthenticationFailureBadCredentialsEvent</span><br><span class="line">AuthenticationFailureExpiredEvent</span><br><span class="line">AuthenticationFailureProviderNotFoundEvent</span><br><span class="line">AuthenticationFailureDisabledEvent</span><br><span class="line">AuthenticationFailureLockedEvent</span><br><span class="line">AuthenticationFailureServiceExceptionEvent</span><br><span class="line">AuthenticationFailureCredentialsExpiredEvent</span><br><span class="line">AuthenticationFailureProxyUntrustedEvent</span><br></pre></td></tr></table></figure></p>
<p>再看看 <code>AuthenticationProvider</code> 是怎么定义的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两个方法，其中 <code>supports</code> 的方法参数，通常是 <code>Authentication</code> 的子类，根据方法名就知道，每个 <code>AuthenticationProvider</code> 处理特定 <code>Authentication</code> 的类型，很可能是成对出现的<br>security 内部已经实现了一部分了，譬如 </p>
<ol>
<li><code>RememberMeAuthenticationProvider</code> 处理 <code>RememberMeAuthenticationToken</code>  </li>
<li><code>AnonymousAuthenticationProvider</code> 处理 <code>AnonymousAuthenticationToken</code></li>
<li><code>RunAsImplAuthenticationProvider</code> 处理 <code>RunAsUserToken</code></li>
<li><code>PreAuthenticatedAuthenticationProvider</code> 处理 <code>PreAuthenticatedAuthenticationToken</code></li>
<li><code>DaoAuthenticationProvider</code> 处理 <code>UsernamePasswordAuthenticationToken</code>  </li>
<li>。。。</li>
</ol>
<p>这里就已经出现了后台管理系统里面常用的认证方法：用户名密码认证<br><code>DaoAuthenticationProvider</code> 类是继承 <code>AbstractUserDetailsAuthenticationProvider</code> 的<br>我们关注一下 <code>AbstractUserDetailsAuthenticationProvider</code> 的 <code>authenticate</code> 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    Assert.isInstanceOf(UsernamePasswordAuthenticationToken<span class="class">.<span class="keyword">class</span>, <span class="title">authentication</span>,</span></span><br><span class="line"><span class="class">            <span class="title">messages</span>.<span class="title">getMessage</span>(</span></span><br><span class="line">                    "AbstractUserDetailsAuthenticationProvider.onlySupports",</span><br><span class="line">                    <span class="string">"Only UsernamePasswordAuthenticationToken is supported"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine username</span></span><br><span class="line">    String username = (authentication.getPrincipal() == <span class="keyword">null</span>) ? <span class="string">"NONE_PROVIDED"</span></span><br><span class="line">            : authentication.getName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里只是一个简单的 cache</span></span><br><span class="line">    <span class="keyword">boolean</span> cacheWasUsed = <span class="keyword">true</span>;</span><br><span class="line">    UserDetails user = <span class="keyword">this</span>.userCache.getUserFromCache(username);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cacheWasUsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 抽象方法，子类实现</span></span><br><span class="line">            user = retrieveUser(username,</span><br><span class="line">                    (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (UsernameNotFoundException notFound) &#123;</span><br><span class="line">            logger.debug(<span class="string">"User '"</span> + username + <span class="string">"' not found"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hideUserNotFoundExceptions) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line">                        <span class="string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line">                        <span class="string">"Bad credentials"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> notFound;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Assert.notNull(user,</span><br><span class="line">                <span class="string">"retrieveUser returned null - a violation of the interface contract"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 本类实现的前置检查 检查账号的状态，是否禁用，过期之类的</span></span><br><span class="line">        preAuthenticationChecks.check(user);</span><br><span class="line">        <span class="comment">// 抽象方法，自定义前置检查</span></span><br><span class="line">        additionalAuthenticationChecks(user,</span><br><span class="line">                (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AuthenticationException exception) &#123;</span><br><span class="line">        <span class="comment">// 通过缓存认证失败了，尝试从正常途径获取信息再认证一次</span></span><br><span class="line">        <span class="keyword">if</span> (cacheWasUsed) &#123;</span><br><span class="line">            <span class="comment">// There was a problem, so try again after checking</span></span><br><span class="line">            <span class="comment">// we're using latest data (i.e. not from the cache)</span></span><br><span class="line">            cacheWasUsed = <span class="keyword">false</span>;</span><br><span class="line">            user = retrieveUser(username,</span><br><span class="line">                    (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">            preAuthenticationChecks.check(user);</span><br><span class="line">            additionalAuthenticationChecks(user,</span><br><span class="line">                    (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本类实现的后置检查，密码是否过期了</span></span><br><span class="line">    postAuthenticationChecks.check(user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cacheWasUsed) &#123;</span><br><span class="line">        <span class="keyword">this</span>.userCache.putUserInCache(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object principalToReturn = user;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (forcePrincipalAsString) &#123;</span><br><span class="line">        principalToReturn = user.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来子类重点应该实现 <code>retrieveUser</code> 和做一下其他的校验<br>看看 <code>DaoAuthenticationProvider</code> 里面的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> UserDetails <span class="title">retrieveUser</span><span class="params">(String username,</span></span></span><br><span class="line"><span class="function"><span class="params">        UsernamePasswordAuthenticationToken authentication)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    prepareTimingAttackProtection();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里就是熟悉的 UserDetailsService 了</span></span><br><span class="line">        UserDetails loadedUser = <span class="keyword">this</span>.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (loadedUser == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalAuthenticationServiceException(</span><br><span class="line">                    <span class="string">"UserDetailsService returned null, which is an interface contract violation"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loadedUser;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (UsernameNotFoundException ex) &#123;</span><br><span class="line">        mitigateAgainstTimingAttack(authentication);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InternalAuthenticationServiceException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalAuthenticationServiceException(ex.getMessage(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails,</span></span></span><br><span class="line"><span class="function"><span class="params">        UsernamePasswordAuthenticationToken authentication)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (authentication.getCredentials() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Authentication failed: no credentials provided"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line">                <span class="string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line">                <span class="string">"Bad credentials"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String presentedPassword = authentication.getCredentials().toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里也应该比较熟悉了 PasswordEncoder</span></span><br><span class="line">    <span class="keyword">if</span> (!passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Authentication failed: password does not match stored value"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line">                <span class="string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line">                <span class="string">"Bad credentials"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，如果要用用户名密码认证，只要指定 <code>UserDetailsService</code> 的实现 和 <code>PasswordEncoder</code> 的实现了<br>顺便说一句，<code>PasswordEncoder</code> 有一个代理实现 <code>DelegatingPasswordEncoder</code> ，包装了所有具体实现  </p>
<p>认证流程核心就是这些概念，但是要注意，实际使用肯定不止这些，要使用注解，就得将这些实现跟 aop 结合，要使用拦截器，就得跟 filter 结合，这些后面再细讲  </p>
<h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>授权也就是访问控制，在 security 里面是在 access 包里面<br>授权的核心类是 <code>AbstractSecurityInterceptor</code> (别问我怎么找到的)，这个类的名字虽然是 interceptor ， 但是跟 spring-web 里面的拦截器没关系，只是逻辑上的拦截（跟 shiro 类型），具体的实现类，可以做 aop 拦截 或者 filter 拦截<br>这个类里面涉及到授权相关的很多类 </p>
<ol>
<li><code>AccessDecisionManager</code>  授权管理</li>
<li><code>AfterInvocationManager</code> 鉴权完成后，如果这个不为null，继续鉴权</li>
<li><code>AuthenticationManager</code> 认证管理</li>
<li><code>RunAsManager</code>  权限认证成功后，转换角色用的，默认没有转换功能</li>
<li><code>SecurityMetadataSource</code> 根据调用参数，判断是否需要鉴权</li>
</ol>
<p>这个类实际上是一个辅助类，提供了 调用前 <code>beforeInvocation</code> 调用后 <code>finallyInvocation</code> 调用结束 <code>afterInvocation</code><br>我们一个一个看，首先调用前  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> InterceptorStatusToken <span class="title">beforeInvocation</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(object, <span class="string">"Object was null"</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> debug = logger.isDebugEnabled();</span><br><span class="line">    <span class="comment">// getSecureObjectClass 是一个抽象方法，由子类指定方法参数类型</span></span><br><span class="line">    <span class="keyword">if</span> (!getSecureObjectClass().isAssignableFrom(object.getClass())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">"Security invocation attempted for object "</span></span><br><span class="line">                        + object.getClass().getName()</span><br><span class="line">                        + <span class="string">" but AbstractSecurityInterceptor only configured to support secure objects of type: "</span></span><br><span class="line">                        + getSecureObjectClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里有点关键，就是使用 SecurityMetadataSource 处理调用参数，判断是否需要鉴权</span></span><br><span class="line">    Collection&lt;ConfigAttribute&gt; attributes = <span class="keyword">this</span>.obtainSecurityMetadataSource()</span><br><span class="line">            .getAttributes(object);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (attributes == <span class="keyword">null</span> || attributes.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 默认是 false</span></span><br><span class="line">        <span class="keyword">if</span> (rejectPublicInvocations) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"Secure object invocation "</span></span><br><span class="line">                            + object</span><br><span class="line">                            + <span class="string">" was denied as public invocations are not allowed via this interceptor. "</span></span><br><span class="line">                            + <span class="string">"This indicates a configuration error because the "</span></span><br><span class="line">                            + <span class="string">"rejectPublicInvocations property is set to 'true'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Public object - authentication not attempted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        publishEvent(<span class="keyword">new</span> PublicInvocationEvent(object));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不需要鉴权，返回 null 了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// no further work post-invocation</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Secure object: "</span> + object + <span class="string">"; Attributes: "</span> + attributes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        credentialsNotFound(messages.getMessage(</span><br><span class="line">                <span class="string">"AbstractSecurityInterceptor.authenticationNotFound"</span>,</span><br><span class="line">                <span class="string">"An Authentication object was not found in the SecurityContext"</span>),</span><br><span class="line">                object, attributes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还没认证，那就先做认证，不同，通常，认证应该在之前就做了，设置了 SecurityContextHolder </span></span><br><span class="line">    Authentication authenticated = authenticateIfRequired();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attempt authorization</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里判断权限</span></span><br><span class="line">        <span class="keyword">this</span>.accessDecisionManager.decide(authenticated, object, attributes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AccessDeniedException accessDeniedException) &#123;</span><br><span class="line">        publishEvent(<span class="keyword">new</span> AuthorizationFailureEvent(object, attributes, authenticated,</span><br><span class="line">                accessDeniedException));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> accessDeniedException;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Authorization successful"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (publishAuthorizationSuccess) &#123;</span><br><span class="line">        publishEvent(<span class="keyword">new</span> AuthorizedEvent(object, attributes, authenticated));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换用户，默认这个是返回 null 的</span></span><br><span class="line">    <span class="comment">// Attempt to run as a different user</span></span><br><span class="line">    Authentication runAs = <span class="keyword">this</span>.runAsManager.buildRunAs(authenticated, object,</span><br><span class="line">            attributes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runAs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            logger.debug(<span class="string">"RunAsManager did not change Authentication object"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所以正常逻辑走这里</span></span><br><span class="line">        <span class="comment">// no further work post-invocation</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InterceptorStatusToken(SecurityContextHolder.getContext(), <span class="keyword">false</span>,</span><br><span class="line">                attributes, object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Switching to RunAs Authentication: "</span> + runAs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则，就转换角色（认证凭证换了）</span></span><br><span class="line">        SecurityContext origCtx = SecurityContextHolder.getContext();</span><br><span class="line">        SecurityContextHolder.setContext(SecurityContextHolder.createEmptyContext());</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(runAs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// need to revert to token.Authenticated post-invocation</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InterceptorStatusToken(origCtx, <span class="keyword">true</span>, attributes, object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用后<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finallyInvocation</span><span class="params">(InterceptorStatusToken token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (token != <span class="keyword">null</span> &amp;&amp; token.isContextHolderRefreshRequired()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Reverting to original Authentication: "</span></span><br><span class="line">                    + token.getSecurityContext().getAuthentication());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SecurityContextHolder.setContext(token.getSecurityContext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">afterInvocation</span><span class="params">(InterceptorStatusToken token, Object returnedObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// public object</span></span><br><span class="line">        <span class="keyword">return</span> returnedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    finallyInvocation(token); <span class="comment">// continue to clean in this method for passivity</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (afterInvocationManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Attempt after invocation handling</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            returnedObject = afterInvocationManager.decide(token.getSecurityContext()</span><br><span class="line">                    .getAuthentication(), token.getSecureObject(), token</span><br><span class="line">                    .getAttributes(), returnedObject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AccessDeniedException accessDeniedException) &#123;</span><br><span class="line">            AuthorizationFailureEvent event = <span class="keyword">new</span> AuthorizationFailureEvent(</span><br><span class="line">                    token.getSecureObject(), token.getAttributes(), token</span><br><span class="line">                            .getSecurityContext().getAuthentication(),</span><br><span class="line">                    accessDeniedException);</span><br><span class="line">            publishEvent(event);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> accessDeniedException;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> returnedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个方法的逻辑很简单，重点在 <code>AfterInvocationManager</code> 的实现，作用跟 <code>AccessDecisionManager</code> 类似，也是用来处理权限的  </p>
<p>抽象类下面也就是两个方向，处理注解的 aop 实现 <code>MethodSecurityInterceptor</code> 和 处理 web 的 过滤器实现 <code>FilterSecurityInterceptor</code><br>这两个实现的不同就是调用参数不同，和判断是否需要权限验证的类不同 <code>MethodSecurityMetadataSource</code>, <code>FilterInvocationSecurityMetadataSource</code><br>这个后面再看，先看重点 <code>AccessDecisionManager</code> 的实现，权限判断，主要是这个类做的  </p>
<p>这个里面有一个 <code>AccessDecisionVoter</code> 列表，代表一组权限鉴定器，鉴定结果有3种，授权通过，拒绝，保留意见。<br>具体判断是否授权通过由子类处理，而 <code>AccessDecisionManager</code> 的具体实现，就是鉴定策略，具体实现有<br><code>AffirmativeBased</code>  只有有一个授权通过，那就授权，如果没有通过的，只要有拒绝的，直接拒绝，否则保留意见就看怎么设置的参数了<br><code>ConsensusBased</code>  通过和拒绝的投票数，看哪种结果票数多，如果同票，参数处理<br><code>UnanimousBased</code>  只要有拒绝，那就直接拒绝  </p>
<p>再来看看具体的 aop 拦截器 <code>MethodSecurityInterceptor</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getSecureObjectClass() &#123;</span><br><span class="line">    <span class="keyword">return</span> MethodInvocation<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    InterceptorStatusToken token = <span class="keyword">super</span>.beforeInvocation(mi);</span><br><span class="line"></span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.finallyInvocation(token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.afterInvocation(token, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodSecurityMetadataSource <span class="title">getSecurityMetadataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.securityMetadataSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SecurityMetadataSource <span class="title">obtainSecurityMetadataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.securityMetadataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/spring-mvc-HandlerMapping%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/27/spring-mvc-HandlerMapping%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">spring-mvc-HandlerMapping详解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-07-27 00:33:25 / 修改时间：00:47:40" itemprop="dateCreated datePublished" datetime="2019-07-27T00:33:25+08:00">2019-07-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>HandlerMapping</p>
<p>这个类的主要作用就是匹配 request 有哪个 handler 处理<br>返回的是 HandlerExecutionChain 里面包含 具体的 handler 拦截器 和 跨域处理</p>
<p>重要的 handlerMapping 主要有几个，都是继承</p>
<p>AbstractHandlerMapping </p>
<p>这个类里面处理 拦截器 跨域，url 匹配的类<br>最终，这里实现了 getHandler 方法，并且是 final 的，不允许付款，也就是说，这里定义了寻找 handler 的具体流程</p>
<ol>
<li>getHandlerInternal 这个方法留给子类实现</li>
<li>上一步如果没找到就 getDefaultHandler  这个默认处理器是外部设置的</li>
<li>上面两步没找到，那就是没有了</li>
<li>如果找到了，判断是否为 string，如果是，则认为是 beanName，直接在容器里根据 beanName 获取，这里没捉异常，没获取到就异常出去了</li>
<li>使用这个找到的 handler 构建 HandlerExecutionChain ，添加拦截器</li>
<li>如果是cors跨域请求，分两种，一是 option 方法 handler 换成 PreFlightHandler 内部是 DefaultCorsProcessor 处理的，二是正常请求，带 origin 了，在 chain 里面添加一个 cors 拦截器 CorsInterceptor，内部也是 DefaultCorsProcessor 处理的 </li>
</ol>
<p>接下来，子类各自实现 getHandlerInternal 方法就可以了<br>下面一层有两个子类 </p>
<ol>
<li>AbstractUrlHandlerMapping 这个是基于处理 url 的</li>
<li>AbstractHandlerMethodMapping  </li>
</ol>
<p>AbstractUrlHandlerMapping 里面又添加了一个 rootHandler ，外部设置，用来处理 / 的请求，这里的 getHandlerInternal 处理流程是</p>
<ol>
<li>根据 request 获取 url：lookupPath</li>
<li>使用这个 lookupPath 获取 handler ，调用的是 lookupHandler 方法</li>
<li>如果没找到，判断 URL 是否为 /,如果是，就使用 rootHandler </li>
<li>如果还是 null  就使用 defaultHandler</li>
<li>如果存在了 ，判断是否为 string，如果是，则认为是 beanName，直接在容器里根据 beanName 获取，这里没捉异常，没获取到就异常出去了</li>
<li>validateHandler 验证一下，这个留给子类实现</li>
<li>构建 HandlerExecutionChain，这里构建的 chain 里面添加了 PathExposingHandlerInterceptor 拦截器，可能添加 UriTemplateVariablesHandlerInterceptor 拦截器 这两个拦截器的作用就是在 request 里面设置一些属性，还有 第二步，如果找到 handler 后，构建步骤跟这里的一样</li>
</ol>
<p>这个类有一个 map 存放 url -&gt; handler  有一个方法 registerHandler 给子类往里面注册 handler  </p>
<p>这个抽象类下面，就有2个直接实现了<br>WelcomePageHandlerMapping<br>这个类重写了 getHandlerInternal 方法，根据 request 的 accept ，来判断，如果包含 text/html 那就调用父类，也就是上面的查找流程，否则返回null，也就是，这里只处理 html 请求，不过看名字也就清楚了</p>
<p>SimpleUrlHandlerMapping<br>这个类就是注册处理 handler 或者 handler 的 beanName<br>在本类初始化的过程中，会根据注册的信息完成初始化，简单的说，就是这个对象有一个 Map<String,Object> 左边是 url 右边是 handler 或者 beanName，在初始化过程中，如果是 beanName 那么就会从容器里面获取 handler<br>另外，如果注册的 url 是 / 那么本 handler 就是 rootHandler ，如果 url 是 /* 那么 handler 就是 defaultHandler 注意一点的是 </p>
<p>除了上面有个直接实现，还有一个抽象子类 AbstractDetectingUrlHandlerMapping</p>
<p>AbstractDetectingUrlHandlerMapping<br>这个抽象类，也是在初始化的时候寻找 handler，过程是获取容器里的所有 beanName，使用 determineUrlsForHandler 传入参数是 beanName 来获取 url 数组，如果获取到了，就注册 handler<br>determineUrlsForHandler 这个方法是一个抽象方法，子类实现</p>
<p>接下来的实现类是<br>BeanNameUrlHandlerMapping</p>
<p>那么这个类主要功能就是判断 beanName 是不是 / 开头的，如果是，那么就代表，本类是 handler 类，处理的url 就是 beanName， 如果 beanName 没有 / 开头，继续看别名</p>
<p>这里是分割线，接下来换另一个继承分支,这个分支才是正常流程常走的地方<br>AbstractHandlerMethodMapping<br>这里面重要的属性是 MappingRegistry 就是 handler 注册的地方，在初始化的时候做一些事情<br>首先，获取所有 beanName， 然后排除一部分代理 也就是 beanName 以 scopedTarget. 开头的，排除后，就获取 beanName 对应的 class ，判断是否为 hander ，如果是，就找里面的 method 然后注册 handler<br>这里的 handler 类型都是 HandleMehtod ，是根据方法划分的，上面的 AbstractUrlHandlerMapping 是一个 bean 就是 handler<br>判断是否为 handler 类型方法 isHandler 由子类实现，<br>获取 handlemethod 的方法 detectHandlerMethods 逻辑为</p>
<ol>
<li>获取具体类型,如果是代理，就找到具体类</li>
<li>过滤方法的具体逻辑是 getMappingForMethod ，这个也是子类实现，方法包含了类型的所有接口</li>
<li>找到后就注册 handler ，三个参数 mapping, handler, method  其中 mapping 是泛型的，handler 就是处理的 beanName 或者 handler 对象，method 就是找到的方法</li>
<li>使用 handlerMethodsInitialized 方法处理已经注册的 handler ，空方法，留给子类覆盖</li>
</ol>
<p>上面是初始化的过程，后面要具体看看 MappingRegistry 的注册和逻辑<br>这个类有一个注册方法 register ，里面会 initCorsConfiguration 初始化自定义 cors 跨域配置，这是一个抽象方法</p>
<p>这个类的 getHandlerInternal 逻辑</p>
<ol>
<li>处理 url 获取 lookupPath</li>
<li>根据 url 找 HandlerMethod  方法是 lookupHandlerMethod<br>怎么找的，就是根据 url 找 mapping 如果没找到 mapping  如果有 mapping（列表） 那就遍历 根据 mapping 和 request 找匹配的 mapping 方法是 getMatchingMapping  子类实现<br>如果没有匹配的，那就使用所有的 mapping 都试着匹配一次<br>如果没匹配到 handleNoMatch 默认返回 null<br>匹配到的话，getMappingComparator 根据 request 获取排序器，将匹配到的 mapping 进行排序，然后找到里面最匹配的一个，最匹配的一个就是第一个，实际上排序就完成了选择了，如果多个匹配，则异常<br>执行 handleMatch 匹配成功方法，这里只是设置一个 request 属性<br>返回 HandlerMethod</li>
</ol>
<p>接下来继续看下面的子类<br>RequestMappingInfoHandlerMapping<br>这里，泛型已经具体了 RequestMappingInfo  很多匹配逻辑都在里面，后面可以看看<br>这个抽象类实现了一些方法  </p>
<ol>
<li>getMatchingMapping  找到匹配的方法 ，具体是 RequestMappingInfo.getMatchingCondition（request）</li>
<li>getMappingComparator 获取排序器，实际上是 RequestMappingInfo 有 compareTo 方法了，直接比较就行了</li>
<li>handleMatch 在匹配成功后做的一些操作，继续设置一些 request 属性，譬如 mediatype uri 参数</li>
<li>handleNoMatch 在没匹配后做的一些操作，具体就是，看到底是什么不匹配，抛出对应异常，譬如 HttpRequestMethodNotSupportedException ,HttpMediaTypeNotSupportedException 等</li>
</ol>
<p>接下来就到最终实现类了<br>RequestMappingHandlerMapping<br>首先，他要实现的是 isHandler ，判断 bean 是否为处理类，逻辑是类上有注解 @Controller 或者 @RequestMapping ，注解上的注解也行<br>接下来是 getMappingForMethod 这个方法是判断 method 是否为处理方法的。逻辑是看有没有 @RequestMapping 注解，注解上的注解也行，譬如 @GetMapping<br>然后 initCorsConfiguration 方法，重写了，处理类上和方法上的 @CrossOrigin 注解，自定义 cors 跨域配置<br>最后有一个 match 方法，是 MatchableHandlerMapping 接口定义的，使用 request 和 pattern 进行匹配</p>
<p>上面留了两个坑，AbstractHandlerMethodMapping 类里面的 MappingRegistry 和 RequestMappingInfoHandlerMapping 类里面的 RequestMappingInfo<br>这两个涉及到注册 handler 和 判断是否匹配，待填</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/spring-mvc-HandlerAdapter%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/27/spring-mvc-HandlerAdapter%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">spring-mvc-HandlerAdapter详解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-07-27 00:32:35 / 修改时间：00:47:36" itemprop="dateCreated datePublished" datetime="2019-07-27T00:32:35+08:00">2019-07-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>HandlerAdapter<br>这个主要是适配器，来调用 handler 的，在之前和之后做一些增强处理，每个 adapter 类型，支持对应的 handler 类型<br>三个方法</p>
<ol>
<li>boolean supports(Object handler);</li>
<li>ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;</li>
<li>long getLastModified(HttpServletRequest request, Object handler);</li>
</ol>
<p>主要有 4 中 adapter</p>
<ol>
<li>HttpRequestHandlerAdapter 这个处理 handler 的类型为 HttpRequestHandler </li>
<li>SimpleServletHandlerAdapter 这个处理 handler 的类型为 Servlet 调用 service 方法</li>
<li>SimpleControllerHandlerAdapter 这个处理 handler 的类型为 Controller </li>
<li>RequestMappingHandlerAdapter 这个是大部分逻辑走的地方，上面3个一般是 spring 自己用的，这个处理的 handler 类型是 HandlerMethod </li>
</ol>
<p>重点关注 RequestMappingHandlerAdapter 其他3个很简单</p>
<p>有一个继承 AbstractHandlerMethodAdapter<br>这里实现 supports 方法 支持 HandlerMethod  并且要满足 supportsInternal 返回true 这是一个抽象方法<br>实现 handle 方法，将 handler 转型为 HandlerMethod ，调用 handleInternal 也是一个抽象方法<br>实现 getLastModified 方法，将 handler 转型为 HandlerMethod ，调用 getLastModifiedInternal 也是一个抽象方法<br>。。。</p>
<p>直接看 RequestMappingHandlerAdapter<br>这个里面的东西就很多了，重点要关注的是初始化方法，这个类实现了 InitializingBean 所以会触发初始化方法 afterPropertiesSet 在这个方法里面，就可以看到它有哪些扩展组件了<br>初始化主要做4件事</p>
<ol>
<li><p>initControllerAdviceCache<br>看名字就知道了 找 @ControllerAdvice 注解的 bean ，<br>然后找里面带 @RequestMapping &amp;&amp; @ModelAttribute 注解的方法，丢到 modelAttributeAdviceCache 里面<br>找带 @InitBinder 注解的方法丢到 initBinderAdviceCache 里面<br>然后处理 RequestBodyAdvice 和 ResponseBodyAdvice</p>
</li>
<li><p>argumentResolvers<br>这里就是请求参数处理的地方，参数处理接口是 HandlerMethodArgumentResolver<br>获取所有默认的参数处理，和自定义的参数处理，默认的优先<br>然后用 HandlerMethodArgumentResolverComposite 对象组合</p>
</li>
<li><p>initBinderArgumentResolvers<br>其实跟上面一样的，只是默认添加的东西不一样，自定义的还是在这里<br>一样是 HandlerMethodArgumentResolver 用 HandlerMethodArgumentResolverComposite 对象组合</p>
</li>
<li><p>returnValueHandlers<br>这个是处理返回结果的 HandlerMethodReturnValueHandler<br>使用 HandlerMethodReturnValueHandlerComposite 对象组合</p>
</li>
</ol>
<p>这里面重要的是要实现3个抽象方法 </p>
<ol>
<li>supportsInternal 这个固定返回 true</li>
<li>getLastModifiedInternal 返回 -1 ，到这里的请求，通常是业务处理，不用 http 缓存</li>
<li>handleInternal<br>就是业务处理了，其实是做业务处理前后的一些事情，具体业务处理是 HanderMethod 完成的</li>
</ol>
<p>这里的逻辑</p>
<ol>
<li>检查 request http 方法这里是否支持，如果需要 session ，则判断 session 是否存在</li>
<li>调用 invokeHandlerMethod 虽然有判断，本质还是调用这个方法<br> 里面的细节不详细看了，看初始化的东西，就知道里面是要干啥了。<br> invokeHandlerMethod 还是要说几句关键步骤<ol>
<li>根据 handler 的参数列表，使用 HandlerMethodArgumentResolver 看看能不能处理该参数，设置对应值，如果有处理不了的就异常了</li>
<li>使用参数，调用 handler 方法，获取返回结果</li>
<li>处理响应码，响应码和原因可以使用注解自定义 @ResponseStatus(code = HttpStatus.ACCEPTED, reason = “test”) 如果没自定义，那就spring 自己处理了，大部分都是 200</li>
<li>然后只用 HandlerMethodReturnValueHandler ，看能不能处理返回类型的东西，譬如我们常用 @RestController 或者 @ResponseBody 返回对象或者字符串的，都会在这里就处理了，写入 response，然后后面就跑流程了</li>
</ol>
</li>
<li>getModelAndView 这里的方法，如果响应结果有人处理了，这里就返回 null 了，如果没处理，可能就是返回的 modelandview 或者 view ，构造返回</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/spring-webmvc-%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/27/spring-webmvc-%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">spring-webmvc 分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-07-27 00:31:00 / 修改时间：00:47:51" itemprop="dateCreated datePublished" datetime="2019-07-27T00:31:00+08:00">2019-07-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ApplicationContextInitializer"><a href="#ApplicationContextInitializer" class="headerlink" title="ApplicationContextInitializer"></a>ApplicationContextInitializer</h2><ol>
<li>class org.springframework.boot.context.config.DelegatingApplicationContextInitializer</li>
<li>class org.springframework.boot.context.ContextIdApplicationContextInitializer</li>
<li>class org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer</li>
<li>class org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer</li>
<li>class org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer</li>
<li>class org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</li>
</ol>
<h2 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h2><ol>
<li>class org.springframework.boot.context.config.ConfigFileApplicationListener</li>
<li>class org.springframework.boot.context.config.AnsiOutputApplicationListener</li>
<li>class org.springframework.boot.context.logging.LoggingApplicationListener</li>
<li>class org.springframework.boot.context.logging.ClasspathLoggingApplicationListener</li>
<li>class org.springframework.boot.autoconfigure.BackgroundPreinitializer</li>
<li>class org.springframework.boot.context.config.DelegatingApplicationListener</li>
<li>class org.springframework.boot.builder.ParentContextCloserApplicationListener</li>
<li>class org.springframework.boot.ClearCachesApplicationListener</li>
<li>class org.springframework.boot.context.FileEncodingApplicationListener</li>
<li>class org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener</li>
</ol>
<p>org.springframework.boot.SpringApplicationRunListener</p>
<p>org.springframework.boot.context.event.EventPublishingRunListener</p>
<p>使用的 ApplicationContext<br>org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext</p>
<p>继承下面的<br>ServletWebServerApplicationContext</p>
<p>先放一张图<br><img src="/2019/07/27/spring-webmvc-%E5%88%86%E6%9E%90/spring-mvc.png" class="" title="This is an example image"></p>
<h2 id="9大组件"><a href="#9大组件" class="headerlink" title="9大组件"></a>9大组件</h2><p>编号后面是接口，下面是默认实现</p>
<ol>
<li>MultipartResolver<br>class org.springframework.web.multipart.support.StandardServletMultipartResolver<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MultipartResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isMultipart</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">MultipartHttpServletRequest <span class="title">resolveMultipart</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> MultipartException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cleanupMultipart</span><span class="params">(MultipartHttpServletRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>顾名思义，这里就是处理文件上传的地方，做三件事，判断请求是不是文件上传，将 request 转换成 文件上传 request，以及清理工作<br><code>StandardServletMultipartResolver</code> 标准解析，其实只是从标准 request 解析part 出来，所谓转行 request，实际上是让内部知道是否为文件上传请求，接收一个参数，用来控制是否立即解析，<br>默认是立即解析，非立即就是在第一次调用 getMultipart 的时候触发解析</p>
<ol>
<li>LocaleResolver<br>class org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LocaleResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Locale <span class="title">resolveLocale</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setLocale</span><span class="params">(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable Locale locale)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语言解析，两个方法，解析使用的语言，设置语言。<code>AcceptHeaderLocaleResolver</code> 这个就是从请求头里面解析，但是没法设置   </p>
<ol>
<li>ThemeResolver<br>class org.springframework.web.servlet.theme.FixedThemeResolver<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThemeResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">resolveThemeName</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setThemeName</span><span class="params">(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable String themeName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>主题解析和设置</p>
<ol>
<li>HandlerMapping<br>class org.springframework.web.servlet.handler.SimpleUrlHandlerMapping<br>class org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping<br>class org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping<br>class org.springframework.boot.autoconfigure.web.servlet.WelcomePageHandlerMapping</li>
</ol>
<p>重头戏，这里很重要<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMapping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + ".pathWithinHandlerMapping";</span><br><span class="line"></span><br><span class="line">	String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + ".bestMatchingPattern";</span><br><span class="line"></span><br><span class="line">	String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + ".introspectTypeLevelMapping";</span><br><span class="line"></span><br><span class="line">	String URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + ".uriTemplateVariables";</span><br><span class="line"></span><br><span class="line">	String MATRIX_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + ".matrixVariables";</span><br><span class="line"></span><br><span class="line">	String PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.class.getName() + ".producibleMediaTypes";</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只有一个方法，返回 <code>HandlerExecutionChain</code>,这里面将有 handler 实例（controller 里面的方法）还有拦截器，里面是具体执行的业务逻辑<br>列出里面关键字段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerInterceptor&gt; interceptorList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> interceptorIndex = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>上面关键的是 RequestMappingHandlerMapping 大部分业务处理在这里</p>
<ol>
<li>HandlerAdapter<br>class org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter<br>class org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter<br>class org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter</li>
</ol>
<p>为什么会有 adapter 呢，是为了增强，需要在业务逻辑前后做一些处理，譬如参数注入，返回数据处理等    </p>
<p><code>RequestMappingHandlerAdapter</code> 处理的 handler 为 <code>HandlerMethod</code><br><code>HttpRequestHandlerAdapter</code> 处理的 handler 为 <code>HttpRequestHandler</code><br><code>SimpleControllerHandlerAdapter</code> 处理的 handler 为 <code>Controller</code> 这里的 controler 是一个接口，不是常用的注解  </p>
<p>从 debug 路径来看，大部分的 handler 都是 <code>HandlerMethod</code>, 也就是说，使用的代理是 <code>RequestMappingHandlerAdapter</code><br>除了上面默认的几个外，还有一个实现 <code>SimpleServletHandlerAdapter</code> 这个是处理 <code>Servlet</code> 的  </p>
<p>接下来重点关照 <code>RequestMappingHandlerAdapter</code>    </p>
<p>首先，要看一下调用流程,下面是 <code>doDispatch</code> 方法里面的片段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">String method = request.getMethod();</span><br><span class="line"><span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line"><span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">	<span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></pre></td></tr></table></figure><br>可以看到在获取到对应的 adapter 后，先触发前置拦截器，这里说明一下 <code>mappedHandler</code> 是 <code>HandlerExecutionChain</code> 类型，可以通过调用其 <code>getHandler</code> 方法获取处理类，<code>mappedHandler</code> 里面还有拦截器等其他信息.<br>然后就是 adapter 执行 handler 了，注意传入的参数，请求，响应，以及处理 handler，这个handler 是 adapter 支持的 handler    </p>
<p>看看里面的处理逻辑,很长，又是代码了    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">			HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	ModelAndView mav;</span><br><span class="line">	<span class="comment">// 检查 http method 是否支持，如果需要 session 则判断是否存在 session</span></span><br><span class="line">	checkRequest(request);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">		HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">			Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line">			<span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">				mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// No HttpSession available -&gt; no mutex necessary</span></span><br><span class="line">			mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// No synchronization on session demanded at all...</span></span><br><span class="line">		mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">			applyCacheSeconds(response, <span class="keyword">this</span>.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			prepareResponse(response);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然多，核心方法是 <code>invokeHandlerMethod</code>,其他的是控制代码，后面有兴趣可以仔细看看<br>这个方法又是一个很复杂的方法，需要细看，里面有很多请求处理相关的，譬如参数是如果映射的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">			HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// 包装一下 request，这个就是内部常用到的 WebRequest 的实现类了</span></span><br><span class="line">	ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 处理 @InitBinder 注解的，很少用到，跳过，全局的可以通过 @ControllerAdvice 注解的类定义，全局优先</span></span><br><span class="line">		WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line">		<span class="comment">// @RequestMapping &amp;&amp; @ModelAttribute 注解同时标记的，同上，全局优先,  PS: 这个注解也用的比较少，后面可以瞅瞅</span></span><br><span class="line">		ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line">		<span class="comment">// 这个类继承 HandlerMethod ，new 一个，就是把原来的属性全部赋值给新的对象了</span></span><br><span class="line">		ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">		<span class="comment">// 设置 参数解析，这里就应该熟悉了，比如常用的 @RequestParam 注解等，都是这里处理的，也可以自己定义添加 HandlerMethodArgumentResolver</span></span><br><span class="line">		<span class="comment">// 这里是 HandlerMethodArgumentResolverComposite 里面组合所有的实际解析类</span></span><br><span class="line">		<span class="comment">// 在 getDefaultArgumentResolvers 方法里面，有默认清单</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 设置响应解析，基本同上，接口是 HandlerMethodReturnValueHandler</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			invocableMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">		&#125;</span><br><span class="line">		invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">		invocableMethod.setParameterNameDiscoverer(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这里填充 一些属性 主要是围绕 @ModelAttribute 注解</span></span><br><span class="line">		ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</span><br><span class="line">		mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">		modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">		mavContainer.setIgnoreDefaultModelOnRedirect(<span class="keyword">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// servlet3.0 的异步请求</span></span><br><span class="line">		AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">		asyncWebRequest.setTimeout(<span class="keyword">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">		asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</span><br><span class="line">		asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">		asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</span><br><span class="line">		asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">			Object result = asyncManager.getConcurrentResult();</span><br><span class="line">			mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">			asyncManager.clearConcurrentResult();</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Found concurrent result value ["</span> + result + <span class="string">"]"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 上面都是异步相关，一般都是跳过，这里才是调用，之前的一些字段已经设置到 invocableMethod 里面了 mavContainer 里面包含 session 属性</span></span><br><span class="line">		invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">		<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取响应结果</span></span><br><span class="line">		<span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		webRequest.requestCompleted();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续重点方法分析 <code>invokeAndHandle</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">			Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 调用，获取返回结果，里面涉及到 参数注入，记住一点，处理方法的参数，一定是要 HandlerMethodArgumentResolver 可以处理的</span></span><br><span class="line">	Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置 http 响应状态码，大部分时候，这里是没设置的，除非使用注解 @ResponseStatus 标记</span></span><br><span class="line">	setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于没有返回值的情况，如果是 请求资源没变（http 缓存），或者自定义响应状态码了（譬如204），或者已经被标记处理过了，那么标记处理完成</span></span><br><span class="line">	<span class="comment">// 如果有状态说明原因，也处理完成</span></span><br><span class="line">	<span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">			mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">		mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 否则，接下来就处理响应结果，这是大部分时候走的地方，关于请求参数和响应结果的处理，可以详细看看初始化的时候，spring 默认设置了哪些，这里就不往下看了</span></span><br><span class="line">	mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line">	Assert.state(<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>, <span class="string">"No return value handlers"</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">				returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(getReturnValueHandlingErrorMessage(<span class="string">"Error handling return value"</span>, returnValue), ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取最终结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ModelAndView <span class="title">getModelAndView</span><span class="params">(ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">			ModelFactory modelFactory, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	modelFactory.updateModel(webRequest, mavContainer);</span><br><span class="line">	<span class="keyword">if</span> (mavContainer.isRequestHandled()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ModelMap model = mavContainer.getModel();</span><br><span class="line">	ModelAndView mav = <span class="keyword">new</span> ModelAndView(mavContainer.getViewName(), model, mavContainer.getStatus());</span><br><span class="line">	<span class="keyword">if</span> (!mavContainer.isViewReference()) &#123;</span><br><span class="line">		mav.setView((View) mavContainer.getView());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (model <span class="keyword">instanceof</span> RedirectAttributes) &#123;</span><br><span class="line">		Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();</span><br><span class="line">		HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line">			RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>HandlerExceptionResolver<br>class org.springframework.boot.web.servlet.error.DefaultErrorAttributes<br>class org.springframework.web.servlet.handler.HandlerExceptionResolverComposite</li>
</ol>
<p>异常处理,处理的是 adpeter 调用 handle 方法可能出现的异常<br>在 processDispatchResult 方法里面处理了<br>有一个 HandlerExceptionResolver 列表，处理异常</p>
<ol>
<li>RequestToViewNameTranslator<br>class org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</li>
</ol>
<p>处理响应结果和异常，没有返回 mv 的时候，尝试获取对应的view<br>这里只在 getDefaultViewName 方法里面使用，从 request 的url 找到对应的模版</p>
<ol>
<li>ViewResolver<br>class org.springframework.web.servlet.view.ContentNegotiatingViewResolver<br>class org.springframework.web.servlet.view.BeanNameViewResolver<br>class org.springframework.web.servlet.view.ViewResolverComposite<br>class org.springframework.web.servlet.view.InternalResourceViewResolver</li>
</ol>
<p>视图渲染<br>根据 view name 找到对应的视图<br>一个 ViewResolver 列表，遍历</p>
<ol>
<li>FlashMapManager<br>class org.springframework.web.servlet.support.SessionFlashMapManager</li>
</ol>
<p>用来保存上一次请求设置的数据，这样在本次请求就可以获取了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/spring-tx-%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/27/spring-tx-%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">spring-tx 分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-07-27 00:29:10 / 修改时间：00:30:01" itemprop="dateCreated datePublished" datetime="2019-07-27T00:29:10+08:00">2019-07-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><p>稍微想一下，大概就可以猜到，事务是通过 aop 实现的，在前后增强，类似 @Around<br>但是，在 aop 里面就说过了，我们自定义的 aop 才使用 @Around ，框架内部使用的是直接的 Advisor<br>tx 的配置类是 <code>ProxyTransactionManagementConfiguration</code> 里面注册了3个 bean<br><code>BeanFactoryTransactionAttributeSourceAdvisor</code>,  这个后面要详细说，aop 找的就是这个类，这个类使用了下面两个<br><code>TransactionAttributeSource</code>, 这个是用来判断是否有事务的<br><code>TransactionInterceptor</code> 具体做事的地方，Advice 的另一个分支 intercept 的实现，也使用了 <code>TransactionAttributeSource</code>  </p>
<p>我们先看看 <code>TransactionAttributeSource</code> 是干啥的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionAttributeSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">TransactionAttribute <span class="title">getTransactionAttribute</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>看一眼就知道，从方法和类型里面读取事务信息的，估计如果没有读取到，那就不走事务，没有事务 aop<br>使用的具体实现是  <code>AnnotationTransactionAttributeSource</code> 可以进去看看，分为3中类型，ejb，jta，springtx，现在只关注最有一个<br>spring 的使用 <code>@Transactional</code> 注解 </p>
<p>然后看看 <code>TransactionInterceptor</code> 这里是具体做事的地方，细节很复杂，详细看看，对以后配置事务，数据源有帮助<br>实际类型是 <code>TransactionInterceptor</code>  实现了 <code>MethodInterceptor</code> 接口，这个接口是 <code>Advice</code> 的扩展接口<br>里面，invoke 方法直接调用父类的 <code>invokeWithinTransaction</code> 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">	<span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span></span><br><span class="line">	TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">	Object retVal = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line">		<span class="comment">// This will normally result in a target object being invoked.</span></span><br><span class="line">		retVal = invocation.proceedWithInvocation();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="comment">// target invocation exception</span></span><br><span class="line">		completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		cleanupTransactionInfo(txInfo);</span><br><span class="line">	&#125;</span><br><span class="line">	commitTransactionAfterReturning(txInfo);</span><br><span class="line">	<span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>虽然有 else 的逻辑，但是，大部分走的是这里，逻辑很清晰，这里就不多讲了，直接看细节。<br>首先是创建事务，这里可能创建新事务，具体需要看配置（spring 的事务传播级别）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">createTransactionIfNecessary</span><span class="params">(@Nullable PlatformTransactionManager tm,</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nullable TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If no name specified, apply method identification as transaction name.</span></span><br><span class="line">	<span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; txAttr.getName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">		txAttr = <span class="keyword">new</span> DelegatingTransactionAttribute(txAttr) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TransactionStatus status = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tm != <span class="keyword">null</span>) &#123;</span><br><span class="line">			status = tm.getTransaction(txAttr);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Skipping transactional joinpoint ["</span> + joinpointIdentification +</span><br><span class="line">						<span class="string">"] because no transaction manager has been configured"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实，这里只是调用了 <code>PlatformTransactionManager</code> 的 getTransaction 方法，在这里面处理了传播级别，我们过会看里面的细节，<br>还是看事务的拦截器那里，获取事务，方法调用，异常处理，事务完成<br>我们接下来看看异常处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">completeTransactionAfterThrowing</span><span class="params">(@Nullable TransactionInfo txInfo, Throwable ex)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (txInfo != <span class="keyword">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Completing transaction for ["</span> + txInfo.getJoinpointIdentification() +</span><br><span class="line">					<span class="string">"] after exception: "</span> + ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (txInfo.transactionAttribute != <span class="keyword">null</span> &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">				logger.error(<span class="string">"Application exception overridden by rollback exception"</span>, ex);</span><br><span class="line">				ex2.initApplicationException(ex);</span><br><span class="line">				<span class="keyword">throw</span> ex2;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (RuntimeException | Error ex2) &#123;</span><br><span class="line">				logger.error(<span class="string">"Application exception overridden by rollback exception"</span>, ex);</span><br><span class="line">				<span class="keyword">throw</span> ex2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// We don't roll back on this exception.</span></span><br><span class="line">			<span class="comment">// Will still roll back if TransactionStatus.isRollbackOnly() is true.</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">				logger.error(<span class="string">"Application exception overridden by commit exception"</span>, ex);</span><br><span class="line">				ex2.initApplicationException(ex);</span><br><span class="line">				<span class="keyword">throw</span> ex2;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (RuntimeException | Error ex2) &#123;</span><br><span class="line">				logger.error(<span class="string">"Application exception overridden by commit exception"</span>, ex);</span><br><span class="line">				<span class="keyword">throw</span> ex2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一大坨代码，实际上做了两件事，如果抛出的异常是需要回滚的，那就回滚，否则提交，还是使用 <code>PlatformTransactionManager</code> 的方法<br>提交事务一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">commitTransactionAfterReturning</span><span class="params">(@Nullable TransactionInfo txInfo)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (txInfo != <span class="keyword">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Completing transaction for ["</span> + txInfo.getJoinpointIdentification() + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么，我们就可以把注意力转移到 <code>PlatformTransactionManager</code> 的实现了，我们先看看这个接口，也就3个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>外部也只调用了这3个方法<br>下面的继承关系也很简单，只有一个抽象类 <code>AbstractPlatformTransactionManager</code> ，然后下面的都是具体实现了<br>先看  <code>getTransaction</code> 方法,先简单说一下逻辑，代码贴的太多了，<br>首先调用 <code>doGetTransaction</code> 方法获取事务对象，事务对象的具体类型是子类确定的<br>判断事务是否已经存在（方法外部已经有事务了） <code>isExistingTransaction</code> 这个子类实现，<br>如果存在了，那就调用 <code>handleExistingTransaction</code> 方法返回<br>这里就需要判断事务传播级别了，这里先说说传播级别</p>
<ol>
<li>PROPAGATION_REQUIRED  支持当前事务，如果没有，就新建事务，这个是默认的</li>
<li>PROPAGATION_SUPPORTS  支持当前事务，如果没有，那本方法不走业务</li>
<li>PROPAGATION_MANDATORY  支持当前事务，如果没有，就抛异常</li>
<li>PROPAGATION_REQUIRES_NEW  本方法使用新事务，如果当前存在事务了，就暂停当前的事务</li>
<li>PROPAGATION_NOT_SUPPORTED  不支持当前事务，总是以非事务运行</li>
<li>PROPAGATION_NEVER  不支持当前事务，如果存在，抛异常</li>
<li>PROPAGATION_NESTED 如果存在当前事务，本方法就以内部事务运行</li>
</ol>
<p>清楚传播级别后，代码可以自己细看了<br>这里说说新建事务相关的方法 </p>
<ol>
<li>newTransactionStatus 新建事务，这方方法的返回值，就是 getTransaction 的返回值</li>
<li>doBegin 这里才是开始事务，如果没有执行这个方法，实际上是使用当前事务，调用了这个，就是新建事务</li>
<li>prepareSynchronization 这个方法应该是在 doBegin 后面执行的，设置一些线程上下文</li>
<li>prepareTransactionStatus 这个方法包含 newTransactionStatus 和 prepareSynchronization</li>
</ol>
<p>如果是使用当前事务，那么新建的事务对象里面 <code>newTransaction</code> 属性是 false<br>再说 commit 方法，只有当当前的事务对象 <code>newTransaction</code> 是 true 的时候，才调用 <code>doCommit</code> 方法做真正的提交<br>rollback 方法，同样，只有当当前的事务对象 <code>newTransaction</code> 是 true 的时候，才调用 <code>doRollback</code> 方法做回滚<br>除了上面的关键逻辑，还有一些其他的，譬如事务释放只回滚（test的时候用的）,触发一些事件  </p>
<p>那么子类需要实现的方法就有如下方法了  </p>
<ol>
<li>doGetTransaction 获取事务对象，返回的对象是自己定义的类型</li>
<li>isExistingTransaction  当前事务是否存在，参数就是事务对象，自己定义的对象要能够分辨出来事务是否存在</li>
<li>doBegin 开始事务，通常，调用了这个方法，事务才被激活，才能说事务存在</li>
<li>doSuspend 暂停当前事务，返回值会传递给恢复方法 doResume</li>
<li>doResume 恢复事务</li>
<li>doCommit 实际的事务提交</li>
<li>doRollback 实际的事务回滚</li>
<li>doCleanupAfterCompletion 事务结束后的清尾操作</li>
</ol>
<p>上面是必须的，其他的方法，可以覆盖父类，或者自定义方法  </p>
<p>需要看看 <code>DataSourceTransactionManager</code> 管理 jdbc 事务<br>所谓事务，就是当前线程中，执行的方法，要使用同一个数据库连接对象 <code>Connection</code><br>很自然的想要，要使用线程对象来存储，spring 也是这样做的，在 doBegin 的时候，才需要获取数据库连接，存到线程对象中<br>忽略其他细节<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());</span><br></pre></td></tr></table></figure><br>详细的可以看看 <code>TransactionSynchronizationManager</code> 这个类，里面有一堆线程对象<br>顺便说一句，我们可以看到 <code>bindResource</code> 方法第一个对象是key 第二个对象是value，key 是数据库连接池对象<br>我们可以使用 aop 在运行过程中确定使用哪个数据库连接池(数据库),再设置一个默认的数据库连接池，就可以使用多数据库了，不过不支持分布式事务，但是可以做读写分离<br>具体的可以使用 <code>AbstractRoutingDataSource</code><br>事务和连接池的就分析到这里了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/25/spring%E5%88%86%E6%9E%90-BeanPostProcessor%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/25/spring%E5%88%86%E6%9E%90-BeanPostProcessor%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">spring分析-BeanPostProcessor分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-25 23:44:47" itemprop="dateCreated datePublished" datetime="2019-07-25T23:44:47+08:00">2019-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-27 00:40:55" itemprop="dateModified" datetime="2019-07-27T00:40:55+08:00">2019-07-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>BeanFactory</code> 相关的扩展接口<br></p>
<p>这里主要分析 spring 内部注册的 BeanPostProcessor，看看 spring 是怎么处理的<br>先贴上实例化的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="comment">// 这里再注释一遍，args 大部分时候为 null</span></span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// factoryBeanInstanceCache 的注释，如果 beanName 对应的不是 FactoryBean 忽略这里</span></span><br><span class="line">    <span class="comment">// Cache of unfinished FactoryBean instances: FactoryBean name --&gt; BeanWrapper</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不是 FactoryBean ，或者 FactoryBean 是已经完成创建的</span></span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里创建实例，就是构建一个对象出来，不过有 构造方法注入，所以需要处理，这个后面再看</span></span><br><span class="line">        <span class="comment">// 实例可以 factoryBean ，factoryMethod，构造方法</span></span><br><span class="line">        <span class="comment">// 创建过程老复杂了，后面可以详细看看</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里先获取一些基本信息，设置解析出来的类型</span></span><br><span class="line">    <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始要执行 BeanPostProcessor 了，先上锁</span></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="comment">// 判断是否处理过了</span></span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 处理 MergedBeanDefinitionPostProcessor （BeanPostProcessor 的子接口）的 postProcessMergedBeanDefinition 方法</span></span><br><span class="line">                <span class="comment">// 这里给个机会修改一下 BeanDefinition，但是 beanType 没法变了，实例已经创建好了，后面挺多设置一下 properties 或者依赖设置吧</span></span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 标记处理过类</span></span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是可以运行循环依赖的处理</span></span><br><span class="line">    <span class="comment">// 当 A 创建一半，发现需要先创建 B，然后去创建 B，然而 B 也依赖 A了，这个时候，虽然 A 还没创建完</span></span><br><span class="line">    <span class="comment">// 这里就允许这种情况，因为 A 的实例已经创建好了，只是一些属性还没设置完全，依赖只是有一个引用</span></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">                    <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加 对象工厂</span></span><br><span class="line">        <span class="comment">// 处理 SmartInstantiationAwareBeanPostProcessor 接口（getEarlyBeanReference 方法）</span></span><br><span class="line">        <span class="comment">// 当有循环依赖，需要获取早期引用的时候，会调用 getEarlyBeanReference 方法（SmartInstantiationAwareBeanPostProcessor 的方法）</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里依赖注入</span></span><br><span class="line">        <span class="comment">// 老复杂了</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 初始化方法，BeanPostProcessor 接口</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要提前暴露出去</span></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 不为 null，才处理，因为不为 null，代表还没有其他对象引用</span></span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里是代表，经过 BeanPostProcessor 的处理，bean 的引用地址没有改变</span></span><br><span class="line">            <span class="comment">// 也就是说，如果 BeanPostProcessor 没有处理，或者处理的时候 new 新对象，是直接用之前的 bean = new ，而不是直接返回 new，那引用就没有变化</span></span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下面检查是否有依赖了旧版本的 bean</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                            <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                            <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">                            <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">                            <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">                            <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 disposable bean，这样，当 容器关闭之前，先调用这些bean 的 destroy方法</span></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>这个是 spring 框架扩展的核心接口，其他众所周知的各种 *Aware 接口，都是基于这个接口实现的<br>譬如 <code>ApplicationContextAwareProcessor</code> 类，就是处理 <code>EnvironmentAware</code>, <code>EmbeddedValueResolverAware</code>, <code>ResourceLoaderAware</code>, <code>ApplicationEventPublisherAware</code>, <code>MessageSourceAware</code>, <code>ApplicationContextAware</code> 接口的<br>PS: 不是所有 Aware 都是通过这个接口扩展的，还有一些譬如 BeanClassloaderAware 之类的，只在初始化过程中触发的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(<span class="keyword">final</span> Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    AccessControlContext acc = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (bean <span class="keyword">instanceof</span> EnvironmentAware || bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware ||</span><br><span class="line">                    bean <span class="keyword">instanceof</span> ResourceLoaderAware || bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware ||</span><br><span class="line">                    bean <span class="keyword">instanceof</span> MessageSourceAware || bean <span class="keyword">instanceof</span> ApplicationContextAware)) &#123;</span><br><span class="line">        acc = <span class="keyword">this</span>.applicationContext.getBeanFactory().getAccessControlContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (acc != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            invokeAwareInterfaces(bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, acc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        invokeAwareInterfaces(bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">            ((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">            ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">            ((ResourceLoaderAware) bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">            ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">            ((MessageSourceAware) bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">            ((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>BeanPostProcessor</code> 这个接口有两个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法代表初始化之前</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法在初始化之后</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>什么是初始化前，什么是初始化后，我们再瞅一下 bean 的实例化代码实现<br>当一个 bean 创建完毕，依赖注入完毕后，才会开始 <code>BeanPostProcessor</code> 的处理，处理的方法是 <code>AbstractAutowireCapableBeanFactory.initializeBean</code> 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这里依赖注入</span></span><br><span class="line">    <span class="comment">// 老复杂了</span></span><br><span class="line">    populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">    <span class="comment">// 初始化方法，BeanPostProcessor 接口</span></span><br><span class="line">    exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面至少发一下调用的地方</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发 Aware 接口</span></span><br><span class="line">    <span class="comment">// BeanNameAware  BeanClassLoaderAware  BeanFactoryAware</span></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// postProcessBeforeInitialization</span></span><br><span class="line">        <span class="comment">// 这里就是初始化之前 postProcessBeforeInitialization 方法调用</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用初始化方法 InitializingBean （afterPropertiesSet 方法） 注意，@PostConstruct 注解不在这里处理 </span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">                beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// postProcessAfterInitialization 处理</span></span><br><span class="line">        <span class="comment">// 这里就是初始化之后 postProcessAfterInitialization 方法调用</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通常这两个扩展方法，如果实现类不需要处理，原样返回就可以了，默认方法（jdk8 的接口默认方法）就是这样的</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        Object current = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        result = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        Object current = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        result = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面也可以看到 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用初始化方法 InitializingBean （afterPropertiesSet 方法）  自定义的初始化方法</span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br></pre></td></tr></table></figure>
<p>bean 的初始化方法，是在这两个扩展调用之间的</p>
<h2 id="MergedBeanDefinitionPostProcessor"><a href="#MergedBeanDefinitionPostProcessor" class="headerlink" title="MergedBeanDefinitionPostProcessor"></a>MergedBeanDefinitionPostProcessor</h2><p>这个接口是 <code>BeanPostProcessor</code> 的子接口，多了一个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Post-process the given merged bean definition for the specified bean.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanDefinition the merged bean definition for the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanType the actual type of the managed bean instance</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>首先，什么是 <code>MergedBeanDefinition</code>? 因为 <code>BeanDefinition</code> 是可以继承的,因此，以 <code>BeanDefinition</code> 为模板构建实例的时候，首先要从父 <code>BeanDefinition</code> 拿到所有信息之后才开始构建<br>然后，这个方法的触发在什么时候呢？答案是在 <code>BeanPostProcessor</code> 的两个方法之前，在spring 创建好实例之后，没依赖注入（非构造注入）之前,允许修改 <code>BeanDefinition</code><br>我们看看发生的地方<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始要执行 BeanPostProcessor 了，先上锁</span></span><br><span class="line"><span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">    <span class="comment">// 判断是否处理过了</span></span><br><span class="line">    <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 处理 MergedBeanDefinitionPostProcessor （BeanPostProcessor 的子接口）的 postProcessMergedBeanDefinition 方法</span></span><br><span class="line">            <span class="comment">// 这里给个机会修改一下 BeanDefinition，但是 beanType 没法变了，实例已经创建好了，后面挺多设置一下 properties 或者依赖设置吧</span></span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标记处理过类</span></span><br><span class="line">        mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里，上面已经说明了，允许修改 <code>BeanDefinition</code><br>那么，一个具体的应用实例，就是 spring 自己的 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解的处理<br>在类 <code>InitDestroyAnnotationBeanPostProcessor</code> 中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">    LifecycleMetadata metadata = findLifecycleMetadata(beanType);</span><br><span class="line">    metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkConfigMembers</span><span class="params">(RootBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">    Set&lt;LifecycleElement&gt; checkedInitMethods = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.initMethods.size());</span><br><span class="line">    <span class="keyword">for</span> (LifecycleElement element : <span class="keyword">this</span>.initMethods) &#123;</span><br><span class="line">        String methodIdentifier = element.getIdentifier();</span><br><span class="line">        <span class="keyword">if</span> (!beanDefinition.isExternallyManagedInitMethod(methodIdentifier)) &#123;</span><br><span class="line">            <span class="comment">// 这里注册 init</span></span><br><span class="line">            beanDefinition.registerExternallyManagedInitMethod(methodIdentifier);</span><br><span class="line">            checkedInitMethods.add(element);</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Registered init method on class ["</span> + <span class="keyword">this</span>.targetClass.getName() + <span class="string">"]: "</span> + element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;LifecycleElement&gt; checkedDestroyMethods = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.destroyMethods.size());</span><br><span class="line">    <span class="keyword">for</span> (LifecycleElement element : <span class="keyword">this</span>.destroyMethods) &#123;</span><br><span class="line">        String methodIdentifier = element.getIdentifier();</span><br><span class="line">        <span class="keyword">if</span> (!beanDefinition.isExternallyManagedDestroyMethod(methodIdentifier)) &#123;</span><br><span class="line">            <span class="comment">// 这里注册 destroy</span></span><br><span class="line">            beanDefinition.registerExternallyManagedDestroyMethod(methodIdentifier);</span><br><span class="line">            checkedDestroyMethods.add(element);</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Registered destroy method on class ["</span> + <span class="keyword">this</span>.targetClass.getName() + <span class="string">"]: "</span> + element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.checkedInitMethods = checkedInitMethods;</span><br><span class="line">    <span class="keyword">this</span>.checkedDestroyMethods = checkedDestroyMethods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>他在这里注册了一些 <code>@PostConstruct</code> 注解标记的初始化方法，那么是在什么时候调用的呢？答案是在 <code>postProcessBeforeInitialization</code> 这个方法里面<br>而我们之前说过了，这个扩展的调用是在 <code>InitializingBean</code> 接口 和 指定初始化方法（使用 <code>@Bean</code> 注解就可以指定）之前的。<br>因此，很显然，调用顺序是 1. <code>@PostConstruct</code> 2. <code>InitializingBean</code> 3. init-method   </p>
<h2 id="InstantiationAwareBeanPostProcessor"><a href="#InstantiationAwareBeanPostProcessor" class="headerlink" title="InstantiationAwareBeanPostProcessor"></a>InstantiationAwareBeanPostProcessor</h2><p>这个接口里面多了3个方法，实例化之前，实例化之后，处理 properties。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是这里的方法名 <code>Instantiation</code> 跟 <code>BeanPostFactory</code> 的方法名 <code>Initialization</code> 是不一样的<br>我们要注意到，在 <code>BeanPostFactory</code> 接口的两个方法中，参数都是一个 <code>Object</code> 对象，这说明，在调用这里的时候，对象已经是创建好的。<br>但是 <code>InstantiationAwareBeanPostProcessor</code> 的接口方法 before，参数只是 class，所以，大概就猜到这个接口是在 <code>BeanPostFactory</code> 之前触发了，去源码确认一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 在生成实例之前，这里有一个机会，给对应 BeanPostProcessor 直接生成实例的地方，如果没人处理，就走 spring 下面的创建流程</span></span><br><span class="line">        <span class="comment">// 只有有实现 InstantiationAwareBeanPostProcessor （ BeanPostProcessor 的子接口），才进行处理</span></span><br><span class="line">        <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里就是 spring 默认的创建流程，如果一个类型的bean，没有被 BeanProcessor 提前处理，那就会到这里</span></span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">        <span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">        <span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbdToUse.getResourceDescription(), beanName, <span class="string">"Unexpected exception during bean creation"</span>, ex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，正常的流程是 <code>Object beanInstance = doCreateBean(beanName, mbdToUse, args);</code>  这一行<br>但是，如果 <code>InstantiationAwareBeanPostProcessor</code> 的一个实现，在方法 <code>postProcessBeforeInstantiation</code> 执行后，返回了一个非 null ，那么就不走后面的流程了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    Object bean = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">        <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">        <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">            Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line">            <span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用的 InstantiationAwareBeanPostProcessor， 依次调用，谁处理了，就返回 bean 不处理的返回null</span></span><br><span class="line">                bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 创建后，如果要处理，就返回新的 bean，不处理就返回原来的bean，要是 返回了 null，那就忽略后面的 处理类了</span></span><br><span class="line">                    bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// bean 不为null，那就是处理过了</span></span><br><span class="line">        mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里只触发了 <code>BeanPostFactory</code> 的 <code>postProcessAfterInitialization</code> 方法<br><code>InstantiationAwareBeanPostProcessor</code> 的另外两个方法是在依赖注入的时候使用的</p>
<h2 id="DestructionAwareBeanPostProcessor"><a href="#DestructionAwareBeanPostProcessor" class="headerlink" title="DestructionAwareBeanPostProcessor"></a>DestructionAwareBeanPostProcessor</h2><p>这个接口也是 <code>BeanPostProcessor</code> 的子接口，有两个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DestructionAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postProcessBeforeDestruction</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">requiresDestruction</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很明显，这两个方法是 bean 销毁时候的回调。<br>先说回调顺序，首先是 <code>@PreDestroy</code> 然后是 <code>DisposableBean</code> 最后是指定的 destroy-Method<br>为啥捏？<br>直接上销毁的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="keyword">this</span>.beanPostProcessors)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (DestructionAwareBeanPostProcessor processor : <span class="keyword">this</span>.beanPostProcessors) &#123;</span><br><span class="line">            processor.postProcessBeforeDestruction(<span class="keyword">this</span>.bean, <span class="keyword">this</span>.beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.invokeDisposableBean) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Invoking destroy() on bean with name '"</span> + <span class="keyword">this</span>.beanName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    ((DisposableBean) bean).destroy();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, acc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ((DisposableBean) bean).destroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            String msg = <span class="string">"Invocation of destroy method failed on bean with name '"</span> + <span class="keyword">this</span>.beanName + <span class="string">"'"</span>;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.warn(msg, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(msg + <span class="string">": "</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        invokeCustomDestroyMethod(<span class="keyword">this</span>.destroyMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethodName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Method methodToCall = determineDestroyMethod(<span class="keyword">this</span>.destroyMethodName);</span><br><span class="line">        <span class="keyword">if</span> (methodToCall != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invokeCustomDestroyMethod(methodToCall);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>很明显的一个顺序，至于销毁在哪里发生的，可以查看这个 destroy 在哪里调用的。。</p>
<h2 id="SmartInstantiationAwareBeanPostProcessor"><a href="#SmartInstantiationAwareBeanPostProcessor" class="headerlink" title="SmartInstantiationAwareBeanPostProcessor"></a>SmartInstantiationAwareBeanPostProcessor</h2><p>这个接口继承 <code>InstantiationAwareBeanPostProcessor</code>， 也有3个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">default</span> Class&lt;?&gt; predictBeanType(Class&lt;?&gt; beanClass, String beanName) <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法只用来选择构造方法用的</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">default</span> Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, String beanName)</span><br><span class="line">			<span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/25/spring%E5%88%86%E6%9E%90-BeanFactoryPostProcessor%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/25/spring%E5%88%86%E6%9E%90-BeanFactoryPostProcessor%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">spring分析-BeanFactoryPostProcessor分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-07-25 23:43:24 / 修改时间：23:43:59" itemprop="dateCreated datePublished" datetime="2019-07-25T23:43:24+08:00">2019-07-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇，看看sprnig内部注册的 BeanFactoryPostProcessor 做了些什么<br>主要是 BeanDefinition 的读取注册等<br>主要是 ConfigurationClassPostProcessor 这个类</p>
<h2 id="ConfigurationClassPostProcessor"><a href="#ConfigurationClassPostProcessor" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h2><p>这个类实现的接口是 BeanDefinitionRegistryPostProcessor 排序是 PriorityOrdered<br>因此，先调用的方法是 BeanDefinitionRegistryPostProcessor 接口的，然后是 BeanFactoryPostProcessor 接口的</p>
<h3 id="postProcessBeanDefinitionRegistry"><a href="#postProcessBeanDefinitionRegistry" class="headerlink" title="postProcessBeanDefinitionRegistry"></a>postProcessBeanDefinitionRegistry</h3><p>不做仔细分析，功能就是解析出所有 BeanDefinition，然后注册<br>下面一坨代码就是整个方法的调用过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> registryId = System.identityHashCode(registry);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"postProcessBeanDefinitionRegistry already called on this post-processor against "</span> + registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"postProcessBeanFactory already called on this post-processor against "</span> + registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line">    <span class="comment">// 处理 BeanDefinition</span></span><br><span class="line">    processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 从已有的 BeanDefinition 中，找到配置类，然后解析出更多 BeanDefinition</span></span><br><span class="line"><span class="comment">* Build and validate a configuration model based on the registry of</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> Configuration&#125; classes.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取所有 BeanDefinition，这里的 BeanDefinition 构建 Context 的时候注册的，或者 scan 扫描到的部分 BeanDefinition</span></span><br><span class="line">    String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">        BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line">        <span class="comment">// 被解析过了，会有特殊属性，完全配置 还是 部分配置</span></span><br><span class="line">        <span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||</span><br><span class="line">                ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Bean definition has already been processed as a configuration class: "</span> + beanDef);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 BeanDefinition 是配置类（可解析的） 2个条件或</span></span><br><span class="line">        <span class="comment">// 1. Configuration 注解 全配置</span></span><br><span class="line">        <span class="comment">// 2. Component  ComponentScan Import ImportResource 注解或者有带 Bean 注解带方法  部分配置对应上面的 full 和 lite，这里会在 BeanDefinition 上标记 full 和 lite 代表解析到了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">            configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return immediately if no @Configuration classes were found</span></span><br><span class="line">    <span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先排序，从属性里面获得排序字段进行排序</span></span><br><span class="line">    <span class="comment">// Sort by previously determined @Order value, if applicable</span></span><br><span class="line">    configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">        <span class="keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是设置 bean name 生成器，如果其他模块重新了，就用新的，否则用默认的，作为spring的使用者，通常不会覆盖这里的，只可能是spring自己的其他模块</span></span><br><span class="line">    <span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line">    SingletonBeanRegistry sbr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">        sbr = (SingletonBeanRegistry) registry;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line">            BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">            <span class="keyword">if</span> (generator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">                <span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 environment 为 null，就用标准环境</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析类</span></span><br><span class="line">    <span class="comment">// Parse each @Configuration class</span></span><br><span class="line">    ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line">            <span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line">            <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line">    Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 解析</span></span><br><span class="line">        parser.parse(candidates);</span><br><span class="line">        <span class="comment">// 校验</span></span><br><span class="line">        parser.validate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得解析出来的 configClass</span></span><br><span class="line">        Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">        <span class="comment">// 移除已经解析过的</span></span><br><span class="line">        configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line">                    registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line">                    <span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读取 BeanDefinition</span></span><br><span class="line">        <span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">        <span class="comment">// 标记为已经解析过类</span></span><br><span class="line">        alreadyParsed.addAll(configClasses);</span><br><span class="line">        <span class="comment">// 可以清空类</span></span><br><span class="line">        candidates.clear();</span><br><span class="line">        <span class="comment">// 这个判断，代表真解析出来 BeanDefinition 了</span></span><br><span class="line">        <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">            String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">            Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">            Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 主要是判断，解析出来的配置类，还有没有遗漏的配置类没有解析</span></span><br><span class="line">            <span class="comment">// 主要可能是从其他配置（xml）读取的</span></span><br><span class="line">            <span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">                    BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line">                    <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="keyword">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">                            !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">                        candidates.add(<span class="keyword">new</span> BeanDefinitionHolder(bd, candidateName));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            candidateNames = newCandidateNames;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 ImportRegistry</span></span><br><span class="line">    <span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line">    <span class="keyword">if</span> (sbr != <span class="keyword">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">        sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空缓存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">        <span class="comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span></span><br><span class="line">        <span class="comment">// for a shared cache since it'll be cleared by the ApplicationContext.</span></span><br><span class="line">        ((CachingMetadataReaderFactory) <span class="keyword">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.deferredImportSelectors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">        BeanDefinition bd = holder.getBeanDefinition();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 注解配置的走这里</span></span><br><span class="line">            <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 其他配置的（xml）走这里</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 扩展走这里</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                    <span class="string">"Failed to parse configuration class ["</span> + bd.getBeanClassName() + <span class="string">"]"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理延时导入的</span></span><br><span class="line">    processDeferredImportSelectors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(AnnotationMetadata metadata, String beanName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    processConfigurationClass(<span class="keyword">new</span> ConfigurationClass(metadata, beanName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 配置上有 @Condition 注解，那就判断条件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ConfigurationClass existingClass = <span class="keyword">this</span>.configurationClasses.get(configClass);</span><br><span class="line">    <span class="comment">// 如果已经解析过了</span></span><br><span class="line">    <span class="keyword">if</span> (existingClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// configClass 是被其他配置类通过 Import 导入进来的，就结束类</span></span><br><span class="line">        <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">                existingClass.mergeImportedBy(configClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则的话，就是重复配置类，取后一个</span></span><br><span class="line">            <span class="comment">// Explicit bean definition found, probably replacing an import.</span></span><br><span class="line">            <span class="comment">// Let's remove the old one and go with the new one.</span></span><br><span class="line">            <span class="keyword">this</span>.configurationClasses.remove(configClass);</span><br><span class="line">            <span class="keyword">this</span>.knownSuperclasses.values().removeIf(configClass::equals);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统一用 SourceClass 包装一层</span></span><br><span class="line">    <span class="comment">// Recursively process the configuration class and its superclass hierarchy.</span></span><br><span class="line">    SourceClass sourceClass = asSourceClass(configClass);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (sourceClass != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 搜集配置类</span></span><br><span class="line">    <span class="keyword">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先处理内部类</span></span><br><span class="line">    <span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">    processMemberClasses(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 @PropertySource PropertySources 注解</span></span><br><span class="line">    <span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">            sourceClass.getMetadata(), PropertySources<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">            <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">context</span>.<span class="title">annotation</span>.<span class="title">PropertySource</span>.<span class="title">class</span>)) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">            processPropertySource(propertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(<span class="string">"Ignoring @PropertySource annotation on ["</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">                    <span class="string">"]. Reason: Environment must implement ConfigurableEnvironment"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 ComponentScans ComponentScan 注解</span></span><br><span class="line">    <span class="comment">// Process any @ComponentScan annotations</span></span><br><span class="line">    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">            sourceClass.getMetadata(), ComponentScans<span class="class">.<span class="keyword">class</span>, <span class="title">ComponentScan</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 由注解，条件满足</span></span><br><span class="line">    <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">            !<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">            <span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">            <span class="comment">// 扫描包，解析出 BeanDefinition</span></span><br><span class="line">            <span class="comment">// 这里扫出来的 BeanDefinition 全部注册了</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">                    <span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">            <span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">                <span class="keyword">if</span> (bdCand == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    bdCand = holder.getBeanDefinition();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果其中有需要解析的配置类，就解析</span></span><br><span class="line">                <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                    parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 Import 注解</span></span><br><span class="line">    <span class="comment">// Process any @Import annotations</span></span><br><span class="line">    processImports(configClass, sourceClass, getImports(sourceClass), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 ImportResource 注解</span></span><br><span class="line">    <span class="comment">// Process any @ImportResource annotations</span></span><br><span class="line">    AnnotationAttributes importResource =</span><br><span class="line">            AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (importResource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String[] resources = importResource.getStringArray(<span class="string">"locations"</span>);</span><br><span class="line">        Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">"reader"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">            String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">            configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 @Bean 注解的方法</span></span><br><span class="line">    <span class="comment">// Process individual @Bean methods</span></span><br><span class="line">    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">    <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">        configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理本类实现的接口里面默认方法中带 @Bean 注解带方法</span></span><br><span class="line">    <span class="comment">// Process default methods on interfaces</span></span><br><span class="line">    processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有父类</span></span><br><span class="line">    <span class="comment">// Process superclass, if any</span></span><br><span class="line">    <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">        String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">        <span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; !superclass.startsWith(<span class="string">"java"</span>) &amp;&amp;</span><br><span class="line">                !<span class="keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">            <span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">            <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有父类，就处理完毕类</span></span><br><span class="line">    <span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h3><p>这里就是增强配置类，添加一个 ImportAwareBeanPostProcessor，这个类用来处理 ImportAware 接口实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> factoryId = System.identityHashCode(beanFactory);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"postProcessBeanFactory already called on this post-processor against "</span> + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.factoriesPostProcessed.add(factoryId);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.registriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">        <span class="comment">// BeanDefinitionRegistryPostProcessor hook apparently not supported...</span></span><br><span class="line">        <span class="comment">// Simply call processConfigurationClasses lazily at this point then.</span></span><br><span class="line">        processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用cglib 增强配置类</span></span><br><span class="line">    enhanceConfigurationClasses(beanFactory);</span><br><span class="line">    <span class="comment">//添加一个 BeanPostProcessor 处理类</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ImportAwareBeanPostProcessor(beanFactory));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enhanceConfigurationClasses</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">        BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">        <span class="comment">// 使用 @Configuration 注解标记的类</span></span><br><span class="line">        <span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(beanDef <span class="keyword">instanceof</span> AbstractBeanDefinition)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Cannot enhance @Configuration bean definition '"</span> +</span><br><span class="line">                        beanName + <span class="string">"' since it is not stored in an AbstractBeanDefinition subclass"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (logger.isWarnEnabled() &amp;&amp; beanFactory.containsSingleton(beanName)) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Cannot enhance @Configuration bean definition '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' since its singleton instance has been created too early. The typical cause "</span> +</span><br><span class="line">                        <span class="string">"is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor "</span> +</span><br><span class="line">                        <span class="string">"return type: Consider declaring such methods as 'static'."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configBeanDefs.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// nothing to enhance -&gt; return immediately</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ConfigurationClassEnhancer enhancer = <span class="keyword">new</span> ConfigurationClassEnhancer();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;</span><br><span class="line">        AbstractBeanDefinition beanDef = entry.getValue();</span><br><span class="line">        <span class="comment">// If a @Configuration class gets proxied, always proxy the target class</span></span><br><span class="line">        beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用增强的子类</span></span><br><span class="line">            <span class="comment">// 增强的效果激素实现 EnhancedConfiguration 接口，这个接口继承 BeanFactoryAware</span></span><br><span class="line">            <span class="comment">// Set enhanced subclass of the user-specified bean class</span></span><br><span class="line">            Class&lt;?&gt; configClass = beanDef.resolveBeanClass(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">            <span class="keyword">if</span> (configClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">                <span class="keyword">if</span> (configClass != enhancedClass) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(String.format(<span class="string">"Replacing bean definition '%s' existing class '%s' with "</span> +</span><br><span class="line">                                <span class="string">"enhanced class '%s'"</span>, entry.getKey(), configClass.getName(), enhancedClass.getName()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    beanDef.setBeanClass(enhancedClass);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot load configuration class: "</span> + beanDef.getBeanClassName(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目前来说，单纯的 spring 启动，内部只有这个 BeanFactoryPostProcessor 用来解析 BeanDefinition 用的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/25/spring%E5%88%86%E6%9E%90-aop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/25/spring%E5%88%86%E6%9E%90-aop/" class="post-title-link" itemprop="url">spring分析-aop</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-07-25 23:41:44 / 修改时间：23:44:26" itemprop="dateCreated datePublished" datetime="2019-07-25T23:41:44+08:00">2019-07-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h2><p>AOP 的注解核心配置类是 <code>AnnotationAwareAspectJAutoProxyCreator</code><br>现在不考虑 xml 的配置方式   </p>
<p>一直向上，找继承链到 <code>AbstractAutoProxyCreator</code>, 这个类实现 <code>SmartInstantiationAwareBeanPostProcessor</code> 接口<br>而 <code>SmartInstantiationAwareBeanPostProcessor</code> 接口是 <code>BeanPostProcessor</code> 的子接口，作用是在 bean 实例化过程中做些扩展具体的在实例化里面可以看<br>重点方法是 <code>postProcessAfterInitialization</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">		Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">			<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        Object proxy = createProxy(</span><br><span class="line">                bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一步就是找到拦截器，也就是通知器，然后就是创建代理    </p>
<h3 id="获取拦截-Advisor"><a href="#获取拦截-Advisor" class="headerlink" title="获取拦截 Advisor"></a>获取拦截 Advisor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">        Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到所有的 Advisor，这里就是直接在容器里面找 Advisor 类型</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="comment">// 过滤一下，找到匹配的 Advisor</span></span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">    <span class="comment">// 给子类扩展扩展一下匹配的集合</span></span><br><span class="line">    extendAdvisors(eligibleAdvisors);</span><br><span class="line">    <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看看  <code>AnnotationAwareAspectJAutoProxyCreator.findCandidateAdvisors</code> 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Add all the Spring advisors found according to superclass rules.</span></span><br><span class="line">    <span class="comment">// 这里直接在容器里面找 Advisor 的实现</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line">    <span class="comment">// Build Advisors for all AspectJ aspects in the bean factory.</span></span><br><span class="line">    <span class="comment">// 不出意外，上面是空（spring boot 注解情况下）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorsBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里是看 @Aspect 注解的 bean</span></span><br><span class="line">        advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">buildAspectJAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line">            <span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">                List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                aspectNames = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                <span class="comment">// 遍历所有 beanNames</span></span><br><span class="line">                String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">                        <span class="keyword">this</span>.beanFactory, Object<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">                <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!isEligibleBean(beanName)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// We must be careful not to instantiate beans eagerly as in this case they</span></span><br><span class="line">                    <span class="comment">// would be cached by the Spring container but would not have been weaved.</span></span><br><span class="line">                    Class&lt;?&gt; beanType = <span class="keyword">this</span>.beanFactory.getType(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 看是否有 @Aspect 注解，或者有字段是 aspect 类型,通常是 @Aspect，第二个条件无视</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">                        aspectNames.add(beanName);</span><br><span class="line">                        AspectMetadata amd = <span class="keyword">new</span> AspectMetadata(beanType, beanName);</span><br><span class="line">                        <span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">                            <span class="comment">// 一般是这里</span></span><br><span class="line">                            MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">                                    <span class="keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">                            <span class="comment">// 找到 advisor。。。，这里，看怎么从 Aspect 里面获取 Advisor</span></span><br><span class="line">                            List&lt;Advisor&gt; classAdvisors = <span class="keyword">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line">                            <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                                <span class="keyword">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">                            &#125;</span><br><span class="line">                            advisors.addAll(classAdvisors);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// Per target or per this.</span></span><br><span class="line">                            <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Bean with name '"</span> + beanName +</span><br><span class="line">                                        <span class="string">"' is a singleton, but aspect instantiation model is not singleton"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">                                    <span class="keyword">new</span> PrototypeAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">                            <span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">                            advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.aspectBeanNames = aspectNames;</span><br><span class="line">                <span class="keyword">return</span> advisors;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aspectNames.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String aspectName : aspectNames) &#123;</span><br><span class="line">        List&lt;Advisor&gt; cachedAdvisors = <span class="keyword">this</span>.advisorsCache.get(aspectName);</span><br><span class="line">        <span class="keyword">if</span> (cachedAdvisors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            advisors.addAll(cachedAdvisors);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            MetadataAwareAspectInstanceFactory factory = <span class="keyword">this</span>.aspectFactoryCache.get(aspectName);</span><br><span class="line">            advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">getAdvisors</span><span class="params">(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">    String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();</span><br><span class="line">    validate(aspectClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need to wrap the MetadataAwareAspectInstanceFactory with a decorator</span></span><br><span class="line">    <span class="comment">// so that it will only instantiate once.</span></span><br><span class="line">    MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =</span><br><span class="line">            <span class="keyword">new</span> LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);</span><br><span class="line"></span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 这里的方法 getAdvisorMethods 是找除了 @Pointcut 注解标记外的所有方法</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;</span><br><span class="line">        <span class="comment">// 只要不是切入点，其他方法都可能是 Advice ，使用 这个method 构建 通知器 Advisor</span></span><br><span class="line">        Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);</span><br><span class="line">        <span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            advisors.add(advisor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If it's a per target aspect, emit the dummy instantiating aspect.</span></span><br><span class="line">    <span class="keyword">if</span> (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line">        Advisor instantiationAdvisor = <span class="keyword">new</span> SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);</span><br><span class="line">        advisors.add(<span class="number">0</span>, instantiationAdvisor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find introduction fields.</span></span><br><span class="line">    <span class="comment">// 字段有 @DeclareParents 注解</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;</span><br><span class="line">        Advisor advisor = getDeclareParentsAdvisor(field);</span><br><span class="line">        <span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            advisors.add(advisor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Advisor <span class="title">getAdvisor</span><span class="params">(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> declarationOrderInAspect, String aspectName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line"></span><br><span class="line">    AspectJExpressionPointcut expressionPointcut = getPointcut(</span><br><span class="line">            candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line">    <span class="keyword">if</span> (expressionPointcut == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 都是 InstantiationModelAwarePointcutAdvisorImpl 实例了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,</span><br><span class="line">            <span class="keyword">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 创建代理   </span><br><span class="line">创建代理的流程就是动态代理的过程，也就是网上 spring aop 原理讲的最多的 jdk 和 cglig 动态代理    </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, @Nullable String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理工厂，正常的创建代理的流程</span></span><br><span class="line">    ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isProxyTargetClass 就是用来判断使用 cglib 还是 jdk 的动态代理</span></span><br><span class="line">    <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">            proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Advisor 通知器数组</span></span><br><span class="line">    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">    <span class="comment">// 设置</span></span><br><span class="line">    proxyFactory.addAdvisors(advisors);</span><br><span class="line">    proxyFactory.setTargetSource(targetSource);</span><br><span class="line">    customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">    proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">    <span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">        proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建代理</span></span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">        activate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其中 aopProxyFactory 方法获取的是 DefaultAopProxyFactory</span></span><br><span class="line">    <span class="comment">// createAopProxy 其实就用来判断使用的是哪个代理</span></span><br><span class="line">    <span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">                    <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再看看创建代理方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Creating CGLIB proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; rootClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line">        Assert.state(rootClass != <span class="keyword">null</span>, <span class="string">"Target class must be available for creating a CGLIB proxy"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有实现接口，添加一下</span></span><br><span class="line">        Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line">        <span class="keyword">if</span> (ClassUtils.isCglibProxyClass(rootClass)) &#123;</span><br><span class="line">            proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">            Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line">                <span class="keyword">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">        validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cglib 过程了</span></span><br><span class="line">        <span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">        Enhancer enhancer = createEnhancer();</span><br><span class="line">        <span class="comment">// 类加载器</span></span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            enhancer.setClassLoader(classLoader);</span><br><span class="line">            <span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">                    ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">                enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要代理的对象</span></span><br><span class="line">        enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">        <span class="comment">// 要代理的接口</span></span><br><span class="line">        enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">        <span class="comment">// 生成的代理类名，使用自定义格式</span></span><br><span class="line">        enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">        <span class="comment">// 类加载器处理</span></span><br><span class="line">        enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回调，也就是拦截处理器</span></span><br><span class="line">        Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">        Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">            types[x] = callbacks[x].getClass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">        <span class="comment">// 回调过滤，会根据这个 filter 来选择使用哪个回调</span></span><br><span class="line">        enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(</span><br><span class="line">                <span class="keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">        enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line">        <span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Could not generate CGLIB subclass of "</span> + <span class="keyword">this</span>.advised.getTargetClass() +</span><br><span class="line">                <span class="string">": Common causes of this problem include using a final class or a non-visible class"</span>,</span><br><span class="line">                ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Unexpected AOP exception"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面重点是 callback 的设置，spring 里面的callback有如下几个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些是对应callback 在数组里面的索引，将根据 ProxyCallbackFilter 的返回值来判断使用哪个</span></span><br><span class="line"><span class="comment">// Constants for CGLIB callback array indices</span></span><br><span class="line"><span class="comment">// aop 回调</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AOP_PROXY = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INVOKE_TARGET = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NO_OVERRIDE = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DISPATCH_TARGET = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DISPATCH_ADVISED = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INVOKE_EQUALS = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INVOKE_HASHCODE = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据这个方法的返回值，来判断使用哪个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (AopUtils.isFinalizeMethod(method)) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Found finalize() method - using NO_OVERRIDE"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_OVERRIDE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.isOpaque() &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">            method.getDeclaringClass().isAssignableFrom(Advised<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Method is declared on Advised interface: "</span> + method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DISPATCH_ADVISED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We must always proxy equals, to direct calls to this.</span></span><br><span class="line">    <span class="keyword">if</span> (AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Found 'equals' method: "</span> + method);</span><br><span class="line">        <span class="keyword">return</span> INVOKE_EQUALS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We must always calculate hashCode based on the proxy.</span></span><br><span class="line">    <span class="keyword">if</span> (AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Found 'hashCode' method: "</span> + method);</span><br><span class="line">        <span class="keyword">return</span> INVOKE_HASHCODE;</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt; targetClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line">    <span class="comment">// Proxy is not yet available, but that shouldn't matter.</span></span><br><span class="line">    List&lt;?&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">    <span class="keyword">boolean</span> haveAdvice = !chain.isEmpty();</span><br><span class="line">    <span class="keyword">boolean</span> exposeProxy = <span class="keyword">this</span>.advised.isExposeProxy();</span><br><span class="line">    <span class="keyword">boolean</span> isStatic = <span class="keyword">this</span>.advised.getTargetSource().isStatic();</span><br><span class="line">    <span class="keyword">boolean</span> isFrozen = <span class="keyword">this</span>.advised.isFrozen();</span><br><span class="line">    <span class="keyword">if</span> (haveAdvice || !isFrozen) &#123;</span><br><span class="line">        <span class="comment">// If exposing the proxy, then AOP_PROXY must be used.</span></span><br><span class="line">        <span class="keyword">if</span> (exposeProxy) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Must expose proxy on advised method: "</span> + method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> AOP_PROXY;</span><br><span class="line">        &#125;</span><br><span class="line">        String key = method.toString();</span><br><span class="line">        <span class="comment">// Check to see if we have fixed interceptor to serve this method.</span></span><br><span class="line">        <span class="comment">// Else use the AOP_PROXY.</span></span><br><span class="line">        <span class="keyword">if</span> (isStatic &amp;&amp; isFrozen &amp;&amp; <span class="keyword">this</span>.fixedInterceptorMap.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Method has advice and optimizations are enabled: "</span> + method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// We know that we are optimizing so we can use the FixedStaticChainInterceptors.</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="keyword">this</span>.fixedInterceptorMap.get(key);</span><br><span class="line">            <span class="keyword">return</span> (index + <span class="keyword">this</span>.fixedInterceptorOffset);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Unable to apply any optimizations to advised method: "</span> + method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> AOP_PROXY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// See if the return type of the method is outside the class hierarchy of the target type.</span></span><br><span class="line">        <span class="comment">// If so we know it never needs to have return type massage and can use a dispatcher.</span></span><br><span class="line">        <span class="comment">// If the proxy is being exposed, then must use the interceptor the correct one is already</span></span><br><span class="line">        <span class="comment">// configured. If the target is not static, then we cannot use a dispatcher because the</span></span><br><span class="line">        <span class="comment">// target needs to be explicitly released after the invocation.</span></span><br><span class="line">        <span class="keyword">if</span> (exposeProxy || !isStatic) &#123;</span><br><span class="line">            <span class="keyword">return</span> INVOKE_TARGET;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">        <span class="keyword">if</span> (targetClass != <span class="keyword">null</span> &amp;&amp; returnType.isAssignableFrom(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Method return type is assignable from target type and "</span> +</span><br><span class="line">                        <span class="string">"may therefore return 'this' - using INVOKE_TARGET: "</span> + method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> INVOKE_TARGET;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Method return type ensures 'this' cannot be returned - "</span> +</span><br><span class="line">                        <span class="string">"using DISPATCH_TARGET: "</span> + method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> DISPATCH_TARGET;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>里面重点的是 AOP 的那个回调<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAdvisedInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AdvisedSupport advised;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicAdvisedInterceptor</span><span class="params">(AdvisedSupport advised)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advised = advised;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">        Object target = <span class="keyword">null</span>;</span><br><span class="line">        TargetSource targetSource = <span class="keyword">this</span>.advised.getTargetSource();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这个默认是 false，不需要管</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">                <span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">                oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">                setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Get as late as possible to minimize the time we "own" the target, in case it comes from a pool...</span></span><br><span class="line">            target = targetSource.getTarget();</span><br><span class="line">            Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 看拦截链，一个方法可以触发多个通知</span></span><br><span class="line">            List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">            Object retVal;</span><br><span class="line">            <span class="comment">// Check whether we only have one InvokerInterceptor: that is,</span></span><br><span class="line">            <span class="comment">// no real advice, but just reflective invocation of the target.</span></span><br><span class="line">            <span class="comment">// 没有连接，直接调用</span></span><br><span class="line">            <span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">                <span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span></span><br><span class="line">                <span class="comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span></span><br><span class="line">                <span class="comment">// it does nothing but a reflective operation on the target, and no hot</span></span><br><span class="line">                <span class="comment">// swapping or fancy proxying.</span></span><br><span class="line">                Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">                retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 创建一个 方法调用链</span></span><br><span class="line">                <span class="comment">// We need to create a method invocation...</span></span><br><span class="line">                retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">            &#125;</span><br><span class="line">            retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">            <span class="keyword">return</span> retVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">                targetSource.releaseTarget(target);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">                <span class="comment">// Restore old proxy.</span></span><br><span class="line">                AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == other ||</span><br><span class="line">                (other <span class="keyword">instanceof</span> DynamicAdvisedInterceptor &amp;&amp;</span><br><span class="line">                        <span class="keyword">this</span>.advised.equals(((DynamicAdvisedInterceptor) other).advised)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * CGLIB uses this to drive proxy creation.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.advised.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面的代码是spring对 aop 的处理流程，现在在梳理一遍<br>aop 使用的原理是 动态代理，这句话没毛病，针对接口，使用 jdk 的动态代理，针对类，使用 cglib 的动态代理<br>代理对象的创建，是使用spring 的扩展接口，在bean 实例化过程中切入的<br>切入的过程是 找对有 @Aspect 注解的 bean，排除所有 @Pointcut 注解的方法，其他都可能通知点 Advice<br>使用这些通知点构建通知器 Advisor，通知器作用就是返回 Advice<br>然后根据条件，看该通知器是否跟对应的目标对象匹配，如果匹配，就可以创建代理了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/25/spring%E5%88%86%E6%9E%90-aop%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/25/spring%E5%88%86%E6%9E%90-aop%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">spring分析-aop详解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-07-25 23:39:31 / 修改时间：23:44:20" itemprop="dateCreated datePublished" datetime="2019-07-25T23:39:31+08:00">2019-07-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>总所周知，aop 的核心是动态代理 ，但是 动态代理 是如何跟 ioc 容器结合，是什么时候生成代理对象，怎么生成代理对象，什么情况下才会有 aop ， advice ， advisor， pointcut 这些概念在代码里面的体现?<br>我们需要知道 spring 的 aop 在容器中的运行机制，而不是一句简单的动态代理</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>核心类为 <code>AnnotationAwareAspectJAutoProxyCreator</code> ,为什么一上来就是这个类，可以看 springboot 里面 aop 的自动<br>配置类里面，就可以看到这个类了<br>那么这个类是怎么起作用的，我们知道，aop 的核心就是动态代理，代理，肯定需要代理一个对象，<br>我们也很清楚，被代理的是 spring 容器里面的 bean 实例，那么，需要使用代理对象替换容器里面的对象<br>需要使用 ioc 的扩展接口 <code>BeanPostProcessor</code> 及其子接口，我们往这个类的父类上看看，就可以<br>看到 <code>AbstractAutoProxyCreator</code> 这个类就是实现了 <code>SmartInstantiationAwareBeanPostProcessor</code> 接口</p>
<p>经过简单的测试和 debug 跟踪，发现，代理发生的方式是 <code>postProcessAfterInitialization</code> 这个方法是在<br>bean 实例化之后发生的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">		Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">			<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重点在 <code>wrapIfNecessary</code> 方法，这个地方就是用来判断是否需要使用代理,贴出关键代码片段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create proxy if we have advice.</span></span><br><span class="line"><span class="comment">// 这里就是找代理增强的动作</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">	<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">	<span class="comment">// 创建代理</span></span><br><span class="line">	Object proxy = createProxy(</span><br><span class="line">			bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">	<span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">	<span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，上面就是两个关键动作，找到需要增强的动作，然后创建代理<br>我们先看看怎么找增强动作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 找出增强</span></span><br><span class="line">	List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">	<span class="comment">// 是否可以用在本类型上</span></span><br><span class="line">	List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">	<span class="comment">// 这个留给子类玩</span></span><br><span class="line">	extendAdvisors(eligibleAdvisors);</span><br><span class="line">	<span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">	    <span class="comment">// 排序</span></span><br><span class="line">		eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是在类 AnnotationAwareAspectJAutoProxyCreator 里面的实现</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Add all the Spring advisors found according to superclass rules.</span></span><br><span class="line">	List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line">	<span class="comment">// Build Advisors for all AspectJ aspects in the bean factory.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorsBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">		advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到先调用 super 的，然后调用本类的，找 aspect 相关的<br>实际上，这里处理的是两个类型的，一般增强的动作，概念上就是 Adivce ，而它下面可以分为两个分支<br>一个是 aspect 的 before after around 这一批，另一个是 intercept 这一批<br>第一批通常是我们自定义用的，第二批通常是框架用的，如果是框架用，通常直接就注册 advisor 了<br>这里父类处理的就是 框架的，子类处理的，就是自定义的，我们详细看看<br>先看父类处<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (advisorNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">	<span class="comment">// uninitialized to let the auto-proxy creator apply to them!</span></span><br><span class="line">	advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">			<span class="keyword">this</span>.beanFactory, Advisor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">	<span class="keyword">this</span>.cachedAdvisorBeanNames = advisorNames;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">advisors.add(<span class="keyword">this</span>.beanFactory.getBean(name, Advisor<span class="class">.<span class="keyword">class</span>))</span>;</span><br></pre></td></tr></table></figure><br>这里是在容器里面直接找 <code>Advisor</code> 类型的 bean，我们可以结合自己使用 aop 的方式看<br>我们通常使用 aop 就是定义 aspect 使用 @Aspect 注解 ，定义 pointcut 和 advice<br>基本确定，自己使用的 aop 肯定不是在这里处理的，那么我们再看看子类的处理(只有关键步骤)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">		<span class="keyword">this</span>.beanFactory, Object<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// We must be careful not to instantiate beans eagerly as in this case they</span></span><br><span class="line"><span class="comment">// would be cached by the Spring container but would not have been weaved.</span></span><br><span class="line">Class&lt;?&gt; beanType = <span class="keyword">this</span>.beanFactory.getType(beanName);</span><br><span class="line"><span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">	aspectNames.add(beanName);</span><br><span class="line">	AspectMetadata amd = <span class="keyword">new</span> AspectMetadata(beanType, beanName);</span><br><span class="line">	<span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">		MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">				<span class="keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">		List&lt;Advisor&gt; classAdvisors = <span class="keyword">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">		&#125;</span><br><span class="line">		advisors.addAll(classAdvisors);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Per target or per this.</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Bean with name '"</span> + beanName +</span><br><span class="line">					<span class="string">"' is a singleton, but aspect instantiation model is not singleton"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">				<span class="keyword">new</span> PrototypeAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">		<span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">		advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一般走上面的判断，判断就是看是单例还是原型，重点逻辑是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">		<span class="keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">List&lt;Advisor&gt; classAdvisors = <span class="keyword">this</span>.advisorFactory.getAdvisors(factory);</span><br></pre></td></tr></table></figure></p>
<p>这里获取 Advisor ，但是之前说过了，我们自定使用的 aop 是没有实现 Advisor 的，我们使用的是注解 @Aspect @Pointcut @Before @Around 等<br>那么，里面肯定有一个转换过程，我们进去看看 getAdvisors 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;</span><br><span class="line">	Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);</span><br><span class="line">	<span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">		advisors.add(advisor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// Find introduction fields.</span></span><br><span class="line"><span class="keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;</span><br><span class="line">	Advisor advisor = getDeclareParentsAdvisor(field);</span><br><span class="line">	<span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">		advisors.add(advisor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>里面有两个重点，一个是处理方法，一个是处理字段<br>自己可以进去看看，方法是没有 @Pointcut 注解的，都要处理<br>处理的逻辑就是方法带 Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class 注解的<br>构造 InstantiationModelAwarePointcutAdvisorImpl 返回，我们清楚，这里就有了 Advice 增强动作，pointcut 哪里增强<br>事件上 beforeAdvice 也有哪里增强的逻辑（before），所以真正标识在哪里增强的，应该是 Advisor 实例，这个是 spring 内部帮忙处理的</p>
<p>在看看怎么处理字段的<br>它处理的是带 @DeclareParents 注解的，返回 DeclareParentsAdvisor 实例，具体的，可以看看这个注解的用法，这里就不详看了  </p>
<p>到这里，找到 Advisor 哪里增强，就结束了，接下来就是创建代理的过程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建代理</span></span><br><span class="line">Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br></pre></td></tr></table></figure></p>
<p>传入的参数，class 类型，beanName，这里的 specificInterceptors 就是返回的 Advisor ，保证一下原始对象<br>我们看看创建代理的详细过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, @Nullable String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">			@Nullable Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">		AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">	proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">			proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">	proxyFactory.addAdvisors(advisors);</span><br><span class="line">	proxyFactory.setTargetSource(targetSource);</span><br><span class="line">	customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">	proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">	<span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">		proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看上起很多，事件上逻辑很简单 </p>
<ol>
<li>判断使用 cglib 还是 java 的动态代理</li>
<li>buildAdvisors 其实就是返回之前的参数，里面会添加自定义的（commonInterceptors），但是通常是没有</li>
<li>创建代理<br>重点在创建代理，我们已经知道了，只有两种情况，直接看就行了<br>先看看 cglib 的，先要会 cglib 的基本 api 才行  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">Enhancer enhancer = createEnhancer();</span><br><span class="line"><span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">	enhancer.setClassLoader(classLoader);</span><br><span class="line">	<span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">			((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">		enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</span><br><span class="line"></span><br><span class="line">Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">	types[x] = callbacks[x].getClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(</span><br><span class="line">		<span class="keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line"><span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面重点有两个，一个是设置 callback 一个是 setCallbackFilter<br>callback 是一个数组 ProxyCallbackFilter 里面有一个方法，返回 int 类型，是 callback 数组的下标，对应的 callback 处理<br>重点关注 aop 的 callback 就可以了 DynamicAdvisedInterceptor 使用的是这个<br>里面重点就是一行，其他的可以自己看<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br></pre></td></tr></table></figure></p>
<p>里面的具体调用过程就是代理过程了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//	We start with an index of -1 and increment early.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object interceptorOrInterceptionAdvice =</span><br><span class="line">		<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line"><span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">	<span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line">	<span class="comment">// been evaluated and found to match.</span></span><br><span class="line">	InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">			(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">	<span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">		<span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Dynamic matching failed.</span></span><br><span class="line">		<span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">		<span class="keyword">return</span> proceed();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// It's an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">	<span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">	<span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个调用模式可以学一学<br>到这里，cglib 的实现就看完了，其实大部分时候，就是用的 cglib 动态代理<br>jdk 的动态代理，就是实现 <code>InvocationHandler</code> 然后看看 invoke 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		MethodInvocation invocation;</span><br><span class="line">	Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">	Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">			<span class="comment">// The target does not implement the equals(Object) method itself.</span></span><br><span class="line">			<span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">			<span class="comment">// The target does not implement the hashCode() method itself.</span></span><br><span class="line">			<span class="keyword">return</span> hashCode();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">			<span class="comment">// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span></span><br><span class="line">			<span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">				method.getDeclaringClass().isAssignableFrom(Advised<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">			<span class="comment">// Service invocations on ProxyConfig with the proxy config...</span></span><br><span class="line">			<span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object retVal;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">			<span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">			oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">			setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Get as late as possible to minimize the time we "own" the target,</span></span><br><span class="line">		<span class="comment">// in case it comes from a pool.</span></span><br><span class="line">		target = targetSource.getTarget();</span><br><span class="line">		Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Get the interception chain for this method.</span></span><br><span class="line">		List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check whether we have any advice. If we don't, we can fallback on direct</span></span><br><span class="line">		<span class="comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span></span><br><span class="line">		<span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">			<span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line">			<span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line">			<span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">			Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">			retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// We need to create a method invocation...</span></span><br><span class="line">			invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">			<span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">			retVal = invocation.proceed();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Massage return value if necessary.</span></span><br><span class="line">		Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">		<span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">				returnType != Object<span class="class">.<span class="keyword">class</span> &amp;&amp; <span class="title">returnType</span>.<span class="title">isInstance</span>(<span class="title">proxy</span>) &amp;&amp;</span></span><br><span class="line"><span class="class">				!<span class="title">RawTargetAccess</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line">			<span class="comment">// Special case: it returned "this" and the return type of the method</span></span><br><span class="line">			<span class="comment">// is type-compatible. Note that we can't help if the target sets</span></span><br><span class="line">			<span class="comment">// a reference to itself in another returned object.</span></span><br><span class="line">			retVal = proxy;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line">					<span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">			<span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">			targetSource.releaseTarget(target);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">			<span class="comment">// Restore old proxy.</span></span><br><span class="line">			AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 一大坨代码，自己看了<br> 到此，aop 流程就结束了 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Luo lei"
    src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Luo lei</p>
  <div class="site-description" itemprop="description">主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Luo lei</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  <script src="/js/local-search.js"></script>












    <div id="pjax">

  

  

  


    </div>
</body>
</html>
