<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="Askluolei" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
<meta name="keywords" content="java, js, vue, go, 读书, 笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="Askluolei">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="Askluolei">
<meta property="og:description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Askluolei</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Askluolei</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">个人的学习吐槽网站</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/askluolei" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/MySQL-%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/28/MySQL-%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" class="post-title-link" itemprop="url">MySQL 索引使用的注意事项</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-28 21:20:27" itemprop="dateCreated datePublished" datetime="2019-07-28T21:20:27+08:00">2019-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-10 00:48:00" itemprop="dateModified" datetime="2019-11-10T00:48:00+08:00">2019-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">技术笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>索引能够加快查询速度，但是维护索引和更新索引也会消耗时间，<br>不过通常只要建立合适的索引，从加快查询速度获取的收益是可以忽略掉维护和更新索引的消耗时间的  </p>
<p>创建索引的原则：</p>
<ol>
<li>更新频繁的列不应设置索引</li>
<li>重复数据多的字段不应设为索引</li>
<li>首先应该考虑对where 和 order by 涉及的列上建立索引</li>
</ol>
<p>可以使用 explain 来查看查询是否走索引了。<br>重点是</p>
<ol>
<li><p>type </p>
<ul>
<li>system 表中就一行</li>
<li>const 通过索引一次找到</li>
<li>eq_ref 唯一索引，包括主键索引</li>
<li>ref 索引</li>
<li>range 范围索引</li>
<li>index  只遍历索引树</li>
<li>all 全部扫描</li>
</ul>
<p>顺便说下，走索引不一定查询时间就慢，还有看表里面有多少行数据<br>实际上一条查询语句的快慢是根据扫描行数确定的  </p>
</li>
</ol>
<p>优化语句：</p>
<ol>
<li>不要在 <code>=</code> 左边用函数，例如 where a/2 = 10</li>
<li>不要用 <code>&lt;&gt;</code>, <code>!=</code>, <code>not in</code></li>
<li>不用 null 判断</li>
<li>like 不要用左模糊 %abc</li>
<li>避免用 or ，用 union 代替</li>
<li>exist 代替 in</li>
<li>不要使用类型隐式转换</li>
<li>联合索引的时候条件顺序<br>。。。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/JVM-%E5%8F%82%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/28/JVM-%E5%8F%82%E6%95%B0/" class="post-title-link" itemprop="url">JVM 参数</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-28 21:15:57" itemprop="dateCreated datePublished" datetime="2019-07-28T21:15:57+08:00">2019-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-10 00:47:40" itemprop="dateModified" datetime="2019-11-10T00:47:40+08:00">2019-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">技术笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Trace-跟踪参数"><a href="#Trace-跟踪参数" class="headerlink" title="Trace 跟踪参数"></a>Trace 跟踪参数</h2><h3 id="XX-PrintGC"><a href="#XX-PrintGC" class="headerlink" title="-XX:+PrintGC"></a>-XX:+PrintGC</h3><p>打印GC 的简要信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: <span class="number">975</span>K-&gt;<span class="number">480</span>K(<span class="number">1536</span>K)] <span class="number">14287</span>K-&gt;<span class="number">14016</span>K(<span class="number">15360</span>K), <span class="number">0.0067338</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs]</span><br></pre></td></tr></table></figure></p>
<h3 id="XX-PrintGCTimeStamps"><a href="#XX-PrintGCTimeStamps" class="headerlink" title="-XX:+PrintGCTimeStamps"></a>-XX:+PrintGCTimeStamps</h3><p>打印 GC 发生的时间戳</p>
<h3 id="XX-PrintGCDetails"><a href="#XX-PrintGCDetails" class="headerlink" title="-XX:+PrintGCDetails"></a>-XX:+PrintGCDetails</h3><p>程序运行结束后，打印GC的日志<br>PSYongGen 新生代 包含下面三个<br>eden 对象出生的地方<br>from 幸存 from to 两个对等<br>to<br>ParOldGen 老年代<br>元空间<br>Metaspace<br>JDK 好像没有永久代了<br>JDK 8开始把类的元数据放到本地化的堆内存(native heap)中，这一块区域就叫Metaspace，中文名叫元空间。<br>新增参数<br>-XX:MetaspaceSize是分配给类元数据空间（以字节计）的初始大小(Oracle逻辑存储上的初始高水位，the initial high-water-mark )，此值为估计值。MetaspaceSize的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。<br>-XX:MaxMetaspaceSize是分配给类元数据空间的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。<br>-XX:MinMetaspaceFreeRatio表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最小比例，不够就会导致垃圾回收。<br>-XX:MaxMetaspaceFreeRatio表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最大比例，不够就会导致垃圾回收。<br>后面括号里面<br>分别为 低边界， 当前边界， 最高边界<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen total <span class="number">1536</span>K, used <span class="number">31</span>K [<span class="number">0x00000000ff980000</span>, <span class="number">0x00000000ffb80000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space <span class="number">1024</span>K, <span class="number">3</span>% used [<span class="number">0x00000000ff980000</span>,<span class="number">0x00000000ff987c68</span>,<span class="number">0x00000000ffa80000</span>)</span><br><span class="line">  from space <span class="number">512</span>K, <span class="number">0</span>% used [<span class="number">0x00000000ffa80000</span>,<span class="number">0x00000000ffa80000</span>,<span class="number">0x00000000ffb00000</span>)</span><br><span class="line">  to space <span class="number">512</span>K, <span class="number">0</span>% used [<span class="number">0x00000000ffb00000</span>,<span class="number">0x00000000ffb00000</span>,<span class="number">0x00000000ffb80000</span>)</span><br><span class="line"> ParOldGen total <span class="number">10240</span>K, used <span class="number">8863</span>K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff980000</span>) </span><br><span class="line">  object space <span class="number">10240</span>K, <span class="number">86</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff4a7e68</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line"> Metaspace used <span class="number">2690</span>K, capacity <span class="number">4486</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span> <span class="title">used</span> 297<span class="title">K</span>, <span class="title">capacity</span> 386<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="Xloggc-log-gc-log"><a href="#Xloggc-log-gc-log" class="headerlink" title="-Xloggc:log/gc.log"></a>-Xloggc:log/gc.log</h3><p>指定 GC log 的位置，以文件输出<br>注意一点，上级目录要存在</p>
<h3 id="XX-PrintHeapAtGC"><a href="#XX-PrintHeapAtGC" class="headerlink" title="-XX:+PrintHeapAtGC"></a>-XX:+PrintHeapAtGC</h3><p>每一次GC后，打印堆信息（GC 前后）<br>开发调试的时候可以用一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;Heap before GC invocations=<span class="number">1</span> (full <span class="number">0</span>):</span><br><span class="line"> PSYoungGen total <span class="number">1536</span>K, used <span class="number">975</span>K [<span class="number">0x00000000ff980000</span>, <span class="number">0x00000000ffb80000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space <span class="number">1024</span>K, <span class="number">95</span>% used [<span class="number">0x00000000ff980000</span>,<span class="number">0x00000000ffa73c20</span>,<span class="number">0x00000000ffa80000</span>)</span><br><span class="line">  from space <span class="number">512</span>K, <span class="number">0</span>% used [<span class="number">0x00000000ffb00000</span>,<span class="number">0x00000000ffb00000</span>,<span class="number">0x00000000ffb80000</span>)</span><br><span class="line">  to space <span class="number">512</span>K, <span class="number">0</span>% used [<span class="number">0x00000000ffa80000</span>,<span class="number">0x00000000ffa80000</span>,<span class="number">0x00000000ffb00000</span>)</span><br><span class="line"> ParOldGen total <span class="number">13824</span>K, used <span class="number">13312</span>K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff980000</span>, <span class="number">0x00000000ff980000</span>)</span><br><span class="line">  object space <span class="number">13824</span>K, <span class="number">96</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff9000d0</span>,<span class="number">0x00000000ff980000</span>)</span><br><span class="line"> Metaspace used <span class="number">2682</span>K, capacity <span class="number">4486</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span> <span class="title">used</span> 296<span class="title">K</span>, <span class="title">capacity</span> 386<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line">0.116: [GC (Allocation Failure) 14287K-&gt;14008K(15360K), 0.0011068 secs]</span><br><span class="line">Heap after GC invocations=<span class="number">1</span> (full <span class="number">0</span>):</span><br><span class="line"> PSYoungGen total <span class="number">1536</span>K, used <span class="number">496</span>K [<span class="number">0x00000000ff980000</span>, <span class="number">0x00000000ffb80000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space <span class="number">1024</span>K, <span class="number">0</span>% used [<span class="number">0x00000000ff980000</span>,<span class="number">0x00000000ff980000</span>,<span class="number">0x00000000ffa80000</span>)</span><br><span class="line">  from space <span class="number">512</span>K, <span class="number">96</span>% used [<span class="number">0x00000000ffa80000</span>,<span class="number">0x00000000ffafc040</span>,<span class="number">0x00000000ffb00000</span>)</span><br><span class="line">  to space <span class="number">512</span>K, <span class="number">0</span>% used [<span class="number">0x00000000ffb00000</span>,<span class="number">0x00000000ffb00000</span>,<span class="number">0x00000000ffb80000</span>)</span><br><span class="line"> ParOldGen total <span class="number">13824</span>K, used <span class="number">13512</span>K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff980000</span>, <span class="number">0x00000000ff980000</span>)</span><br><span class="line">  object space <span class="number">13824</span>K, <span class="number">97</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff9320d0</span>,<span class="number">0x00000000ff980000</span>)</span><br><span class="line"> Metaspace used <span class="number">2682</span>K, capacity <span class="number">4486</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span> <span class="title">used</span> 296<span class="title">K</span>, <span class="title">capacity</span> 386<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="XX-TraceClassLoading"><a href="#XX-TraceClassLoading" class="headerlink" title="-XX:+TraceClassLoading"></a>-XX:+TraceClassLoading</h3><p>监控加载的类，每一个类加载都记录<br>同样，在跟踪调试的时候可以用一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Opened C:\Program Files\Java\jre1<span class="number">.8</span><span class="number">.0_161</span>\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.Object from C:\Program Files\Java\jre1<span class="number">.8</span><span class="number">.0_161</span>\lib\rt.jar]</span><br><span class="line">[Loaded java.io.Serializable from C:\Program Files\Java\jre1<span class="number">.8</span><span class="number">.0_161</span>\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.Comparable from C:\Program Files\Java\jre1<span class="number">.8</span><span class="number">.0_161</span>\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.CharSequence from C:\Program Files\Java\jre1<span class="number">.8</span><span class="number">.0_161</span>\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.String from C:\Program Files\Java\jre1<span class="number">.8</span><span class="number">.0_161</span>\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.reflect.AnnotatedElement from C:\Program Files\Java\jre1<span class="number">.8</span><span class="number">.0_161</span>\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.reflect.GenericDeclaration from C:\Program Files\Java\jre1<span class="number">.8</span><span class="number">.0_161</span>\</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h3 id="XX-PrintClassHistogram"><a href="#XX-PrintClassHistogram" class="headerlink" title="-XX:+PrintClassHistogram"></a>-XX:+PrintClassHistogram</h3><p>控制台在运行的时候，按 Ctrl + Break 打印类的信息<br>windows 上好像按不出来<br>就是打印每个类实例的数量，使用空间</p>
<h2 id="堆分配参数"><a href="#堆分配参数" class="headerlink" title="堆分配参数"></a>堆分配参数</h2><h3 id="Xmx-Xms"><a href="#Xmx-Xms" class="headerlink" title="-Xmx -Xms"></a>-Xmx -Xms</h3><p>指定最大堆和最小堆<br>-Xmx20m -Xms5m</p>
<h3 id="Xmn"><a href="#Xmn" class="headerlink" title="-Xmn"></a>-Xmn</h3><p>设置新生代大小<br>-Xmn2m<br>一个 eden 加上两个 survivor 为 2m<br>设置新生代为 2m<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PS E:\study\java\jvm\jvm01&gt; java -Xmx20m -Xms20m -Xmn2m -XX:+PrintGCDetails TestGC</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: <span class="number">974</span>K-&gt;<span class="number">504</span>K(<span class="number">1536</span>K)] <span class="number">18383</span>K-&gt;<span class="number">18160</span>K(<span class="number">19968</span>K), <span class="number">0.0016176</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: <span class="number">504</span>K-&gt;<span class="number">496</span>K(<span class="number">1536</span>K)] <span class="number">18160</span>K-&gt;<span class="number">18160</span>K(<span class="number">19968</span>K), <span class="number">0.0009107</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 496K-&gt;0<span class="title">K</span><span class="params">(<span class="number">1536</span>K)</span>] [ParOldGen: 17664K-&gt;1695<span class="title">K</span><span class="params">(<span class="number">18432</span>K)</span>] 18160K-&gt;1695<span class="title">K</span><span class="params">(<span class="number">19968</span>K)</span>, [Metaspace: 2683K-&gt;2683<span class="title">K</span><span class="params">(<span class="number">1056768</span>K)</span>], 0.0056298 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs]</span><br><span class="line">end</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen total <span class="number">1536</span>K, used <span class="number">31</span>K [<span class="number">0x00000000ffe00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>) </span><br><span class="line">  eden space <span class="number">1024</span>K, <span class="number">3</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe07c68</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  from space <span class="number">512</span>K, <span class="number">0</span>% used [<span class="number">0x00000000fff80000</span>,<span class="number">0x00000000fff80000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">  to space <span class="number">512</span>K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff80000</span>)</span><br><span class="line"> ParOldGen total <span class="number">18432</span>K, used <span class="number">4767</span>K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ffe00000</span>, <span class="number">0x00000000ffe00000</span>) </span><br><span class="line">  object space <span class="number">18432</span>K, <span class="number">25</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff0a7ef0</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line"> Metaspace used <span class="number">2690</span>K, capacity <span class="number">4486</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span> <span class="title">used</span> 297<span class="title">K</span>, <span class="title">capacity</span> 386<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><br>上面可以看到对象都到老年代去了，因为新生代空间不够<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PS E:\study\java\jvm\jvm01&gt; java -Xmx20m -Xms20m -Xmn15m -XX:+PrintGCDetails TestGC</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: <span class="number">11565</span>K-&gt;<span class="number">1504</span>K(<span class="number">13824</span>K)] <span class="number">11565</span>K-&gt;<span class="number">1736</span>K(<span class="number">18944</span>K), <span class="number">0.0012016</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line">end</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen total <span class="number">13824</span>K, used <span class="number">12107</span>K [<span class="number">0x00000000ff100000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space <span class="number">12288</span>K, <span class="number">86</span>% used [<span class="number">0x00000000ff100000</span>,<span class="number">0x00000000ffb5afb8</span>,<span class="number">0x00000000ffd00000</span>)</span><br><span class="line">  from space <span class="number">1536</span>K, <span class="number">97</span>% used [<span class="number">0x00000000ffd00000</span>,<span class="number">0x00000000ffe78040</span>,<span class="number">0x00000000ffe80000</span>)</span><br><span class="line">  to space <span class="number">1536</span>K, <span class="number">0</span>% used [<span class="number">0x00000000ffe80000</span>,<span class="number">0x00000000ffe80000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen total <span class="number">5120</span>K, used <span class="number">232</span>K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff100000</span>, <span class="number">0x00000000ff100000</span>)</span><br><span class="line">  object space <span class="number">5120</span>K, <span class="number">4</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000fec3a000</span>,<span class="number">0x00000000ff100000</span>)</span><br><span class="line"> Metaspace used <span class="number">2690</span>K, capacity <span class="number">4486</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span> <span class="title">used</span> 297<span class="title">K</span>, <span class="title">capacity</span> 386<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><br>调大新生代后，对象在新生代</p>
<h3 id="XX-NewRatio"><a href="#XX-NewRatio" class="headerlink" title="-XX:NewRatio"></a>-XX:NewRatio</h3><p>新生代(eden + 2s) 和老年代的比值<br>4 标识 新生代：老年代= 1：4，即年轻代占堆的 1/5</p>
<h3 id="XX-SurvivorRatio"><a href="#XX-SurvivorRatio" class="headerlink" title="-XX:SurvivorRatio"></a>-XX:SurvivorRatio</h3><p>设置两个 Survivor 区 和 eden 的比<br>8 标识两个 Survivor:eden = 2：8 即，一个 Survivor 占年轻代的 1/10</p>
<h3 id="XX-HeapDumpOnOutOfMemoryError"><a href="#XX-HeapDumpOnOutOfMemoryError" class="headerlink" title="-XX:+HeapDumpOnOutOfMemoryError"></a>-XX:+HeapDumpOnOutOfMemoryError</h3><p>OOM 的时候导出堆到文件</p>
<h3 id="XX-HeapDumpPath"><a href="#XX-HeapDumpPath" class="headerlink" title="-XX:HeapDumpPath"></a>-XX:HeapDumpPath</h3><p>导出文件路径<br>-XX:HeapDumpPath=logs/a.dump</p>
<h3 id="XX-OnOutOfMemoryError"><a href="#XX-OnOutOfMemoryError" class="headerlink" title="-XX:OnOutOfMemoryError"></a>-XX:OnOutOfMemoryError</h3><p>在 OOM 时候，执行一个脚本<br>-XX:OnOutOfMemoryError=”test.bat %p”<br>可以在 OOM 的时候发送邮件，甚至重启程序<br>外面套引号<br>测试了一下，可以执行脚本，但是 %p 进程没有传进去，在windows 上测试的</p>
<h3 id="堆分配总结"><a href="#堆分配总结" class="headerlink" title="堆分配总结"></a>堆分配总结</h3><p>官方推荐<br>新生代占堆的 3/8<br>幸存代占新生代的 1/10<br>OOM的时候记得 Dump 堆，确保可以排查现场问题</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/jvm-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/28/jvm-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">jvm 学习笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-28 12:38:37" itemprop="dateCreated datePublished" datetime="2019-07-28T12:38:37+08:00">2019-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-10 00:47:40" itemprop="dateModified" datetime="2019-11-10T00:47:40+08:00">2019-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">技术笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>深入理解 java 虚拟机</code>  这本书看了也有几遍了，说实话，每次都是面试前看的（我也没面几次试)<br>虽然每次看，感觉都可以多理解一点东西，但还是很虚。。先做个笔记，以后面试看笔记就行  </p>
<h2 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h2><p>这个是面试但时候常问的，也是比较好理解的<br>运行时数据区域分为  </p>
<ol>
<li>程序计数器<br>可以看作当前线程执行字节码的行号指示器，字节码在jvm内部是解释执行的（没 jit 之前）</li>
<li>java 虚拟机栈<br>也是线程私有的，每个方法创建一个栈帧，用于存储 局部变量表，操作数栈，动态链接，方法出口<br>局部变量表存放编译器可知的各种基本数据类型，对象引用，变量表的空间按 slot 分配，一个 slot 4个字节<br>当线程请求的栈深度大于虚拟机所允许的深度抛 StackOverflowError 栈溢出异常，如果是动态扩展栈空间的时候内存不足，则是 OOM 异常</li>
<li>本地方法栈<br>native 方法栈</li>
<li>java 堆<br>这个是最需要关系的区域<br>也是共享的一块内存区域，存放对象实例，也是 垃圾回收的主要区域<br>堆还可以细分为 新生代 老年代，注意是为了方便 gc 可以通过 -Xmx -Xms 控制，这个两个是常用的控制最大最小堆内存空间的jvm参数</li>
<li>方法区，也是元空间<br>通常用于存储已经被虚拟机加载的 类信息，常量信息，静态变量，即使编译器后的代码，也叫 非堆 NonHeap ，也被称为永久代，通常这部分内容很难被回收掉，要回收的条件也比较严格</li>
<li>直接内存<br>也是对外内存，nio 的时候会用到</li>
</ol>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾回收其实可以分为两部分看，一个是怎么判断一个对象已经失效了，另一个才是实际回收内存操作  </p>
<p><strong>对象已死吗</strong></p>
<ol>
<li>引用计数<br>就算对象每被引用一次，就 + 1，释放就 -1 到0 到 0 到时候代表没用了<br>这是一个思路，jvm 内部不使用这种策略，在 netty 中，只用 pooled** 到内存池的时候使用的就是引用计数来判断的</li>
<li>可达性分析<br>这个是主流的方法，根据 GC Root 对象为起点，往下搜索，走过的路径代表引用链，不在引用链上的对象可以认为死对象<br>那么哪些对象是在 GC Root 呢<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中类静态属性引用的变量</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中 JNI 引用的对象<br>这里面其实可以看到后期的一个优化，栈上分配，当方法执行完成后，对象就失效了，因此在方法内部分配的对象，生命周期是短暂的</li>
</ul>
</li>
</ol>
<p><strong>引用</strong><br>java 内部将引用分为4种</p>
<ol>
<li>强引用<br>这也是最常见的，通常 new 出来的都是这种，只要强引用还在，垃圾回收器永远不会回收</li>
<li>软引用<br>提供 SoftReference 来实现软引用，在将要内存溢出的情况下，才去回收这块内存</li>
<li>弱引用<br>提供 WeakReference 来实现弱引用，下次 gc 的时候，就会回收这块内容</li>
<li>虚引用<br>PhantomReference 基本就只是在回收的时候获得一个通知 </li>
</ol>
<p><strong>回收方法区</strong><br>由于在 jdk8 中，字符串常量池已经从方法区（元空间）移到堆了，这里说下类被回收（卸载）<br>满足3个条件</p>
<ol>
<li>类的所有实例已经被回收</li>
<li>类的 classloader 已经被回收</li>
<li>类 class 对象没有被引用</li>
</ol>
<p>就可以被回收了，注意是 可以，并不一定 </p>
<h2 id="垃圾搜集算法"><a href="#垃圾搜集算法" class="headerlink" title="垃圾搜集算法"></a>垃圾搜集算法</h2><ol>
<li><p>标记清除<br>跟名字已有，分为两个过程，标记阶段，标记需要回收的对象，然后统一清除被标记的对象<br>有两个问题，1. 标记和清除的效率不高 2. 会产生很多内存碎片</p>
</li>
<li><p>复制算法<br>将内存分为2块相同的区域，先用一块，用完的时候，将还存活的对象复制到另一半，然后将之前使用过的内存区域一次性清除。<br>问题也很大，内存缩小为原来的一半了</p>
</li>
<li><p>标记整理<br>与标记清除类似，不过后续步骤不是清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界外的内存</p>
</li>
<li><p>分代算法<br>就是将内存划分为几块区域，一般分为新生代和老年代，针对不同区域使用不同的垃圾回收算法</p>
</li>
</ol>
<p><strong>枚举根节点</strong><br>GC Root 的节点主要在全局性的引用和执行上下文中。<br>当在进行可达性分析的时候，需要 GC 停顿，不可以在分析过程中对象关系引用还在不断变化中。  </p>
<p><strong>安全点</strong><br>虚拟机将在特定位置记录协助 GC Root 枚举信息，这些位置称为 Sofapoint 安全点  </p>
<p><strong>安全区域</strong><br>安全区域是指在一段代码片段中国，引用关系不会发生变化</p>
<h2 id="垃圾搜集器"><a href="#垃圾搜集器" class="headerlink" title="垃圾搜集器"></a>垃圾搜集器</h2><p>新生代：Serial，ParNew，Parallel Scavenge<br>老年代：CMS，Serial Old，Parallel Old<br>全部：G1</p>
<p><strong>Serial</strong><br>这是一个单线程的搜集器，在进行垃圾搜集的时候需要进行暂停所有的工作线程。<br>这是在 Client 模式下默认的垃圾搜集器<br>能与老年代的 CMS，Serial Old 共用 </p>
<p><strong>ParNew</strong><br>其实就是 Serial 的多线程版本</p>
<p><strong>Parallel Scavenge</strong><br>目标是达到一个可控制的吞吐量，也就是 cpu 运行用户代码与 cpu 总消耗时间的比值<br>停顿时间越短适合需要与用户交互的程序，高吞吐量则是高效率的利用 cpu 时间 </p>
<p><strong>Serial Old</strong><br>单线程搜集器，使用标记整理算法，也是给 client 模式的虚拟机用的</p>
<p><strong>Parallel Old</strong><br>多线程加标记整理算法</p>
<p><strong>CMS</strong><br>是一种以获取最短回收停顿时间为目标的搜集器<br>使用标记清除算法。整个过程分为4个步骤：</p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除<br>初始标记和重新标记需要 stop the world<br>整个初始标记时间很短<br>整个过程耗时最长的并发标记和并发清除过程，gc 线程可以和用户线程同时工作<br>问题：</li>
<li>cpu 资源敏感，gc 会占用 cpu 资源</li>
<li>无法清除浮动垃圾，也就是在并发清理过程中产生的垃圾要在下次 gc 清除</li>
<li>标记清除，没做整理，可以设置参数</li>
</ol>
<p><strong>G1</strong><br>这个垃圾回收器与之前的都不一样内存划分不同，将堆划分为一个个 Region,默认 512k<br>在逻辑上连续，物理上不连续，同时每个 Regin 被标记为 E，S，O，H，分别表示 Eden，survivor，old，Humongous（大对象）<br>大于等于 region 一半大小的对象为 大对象，分配在老年代 </p>
<p>eden 出生的对象， 经过一次 Minor GC 还存活，如果 Survivor 还能容纳，就进入 Survivor，年龄设置为 1<br>每在 Suvivor 熬过一次 Minor GC，年龄 +1，增加到一定程度 默认 15 晋升老年代。  </p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><ol>
<li>加载</li>
<li>链接<ul>
<li>验证</li>
<li>准备</li>
<li>解析</li>
</ul>
</li>
<li>初始化<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2></li>
<li>取得类的二进制流</li>
<li>转为方法区（元空间）的数据结构</li>
<li>生成 class 对象<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3></li>
<li>文件格式正确<ul>
<li>是否已 0xCAFEBABE 开头</li>
<li>版本号是否合理</li>
<li>。。。</li>
</ul>
</li>
<li>元数据验证<ul>
<li>是否有父类</li>
<li>继承了 final 类？</li>
<li>非抽象实现了所有的抽象方法</li>
<li>。。</li>
</ul>
</li>
<li>字节码验证（很复杂）<ul>
<li>运行检查</li>
<li>栈数据类型和操作码数据参数吻合</li>
<li>跳转指令到合理位置</li>
<li>。。</li>
</ul>
</li>
<li>符号引用验证<ul>
<li>常量池中描述类是否存在</li>
<li>访问的方法或字段是否存在且有足够的权限</li>
<li>。。<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3>分配内存，并为类赋值初值<br>public static int v = 1<br>在 准备阶段 v 会被设置为 0<br>在初始化的<clinit> 中才会设置为1<br>对于 static final 类型，在准备阶段就会被赋值正确的值<br>public static int v = 1<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3>符号引用替换为直接引用<br>符号引用：字符串，引用对象不一定被加载<br>直接引用：指针或者地址便宜，引用对象一定在内存<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2></li>
</ul>
</li>
</ol>
<ul>
<li>执行类构造器 <clinit><ul>
<li>static 变量赋值语句</li>
<li>static {} 语句</li>
</ul>
</li>
<li>子类的 <clinit> 调用前保证父类的 <clinit> 被调用</li>
<li><clinit> 是线程安全的</li>
</ul>
<h2 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h2><p>一堆 JIT 优化，然鹅记不住 </p>
<ol>
<li>公共子表达式消除</li>
<li>数组边界检查消除</li>
<li>方法内联</li>
<li>。。一大堆优化手段 </li>
</ol>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>java 内存模型主要用来屏蔽底层各种硬件和操作系统的差异，给java程序在各个平台都能达到一致的内存访问效果。<br>以下指令是原子的：</p>
<ol>
<li>lock</li>
<li>unlock</li>
<li>read</li>
<li>load</li>
<li>use</li>
<li>assign</li>
<li>store</li>
<li>write</li>
</ol>
<p>要将一个变量从主内存复制到工作内存，需要 read + load<br>将工作内存的变量写回主内存需要 store + write<br>这上面两个是不可拆分使用的<br>volatile 变量将保证可见性 </p>
<p>并发的3个关键特性</p>
<ol>
<li>原子性</li>
<li>可见性</li>
<li>有序性</li>
</ol>
<p>几个先行发生原则，关注几个：</p>
<ol>
<li>单线程的代码顺序性</li>
<li>加锁先于解锁</li>
<li>volatile 写先于读</li>
<li>线程 start 先于每个动作</li>
<li>所有操作先于线程终止</li>
<li>线程中断限于被中断线程的代码检查中断事件发生</li>
<li>对象的初始化完成先于终结（finalize）</li>
<li>a 先于 b，b先于 c 那么 a 先于 c  </li>
</ol>
<p>无论是编译重排序还是cpu 的指令重排序，java 内存模型保证上面的先行发生原则。<br>使用在适当的位置插入内存屏障来实现。  </p>
<p>好吧，上面基本就是一些提纲，没啥具体内容，主要是为了看到这些，想到需要了解的知识  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/redis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/28/redis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">redis 学习笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-28 10:41:03" itemprop="dateCreated datePublished" datetime="2019-07-28T10:41:03+08:00">2019-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-10 00:47:35" itemprop="dateModified" datetime="2019-11-10T00:47:35+08:00">2019-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">技术笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>redis 之前只是会用，经常看一些博客和官网的使用说明，但是还没成体系的学习过<br>最近买了本 <code>Redis 开发与运维</code> ，买这本书对理由是我虽然会用，但是对譬如哨兵，集群方案，<br>内部 redis 之间是怎么通信对等一些细节不是很了解。想要详细了解下   </p>
<p>写这篇笔记，目的是，以后redis 相关等至少看自己等这篇笔记就可以了，不用经常回去翻书<br>其实书早就看完了。感觉要补一篇学习笔记。顺便用耗子哥说的总结归纳方法试一下<br>只归纳以下重点，具体细节就不罗列了</p>
<p>先套下学习模板  </p>
<ol>
<li>这个技术出现的背景，初衷和要达到什么样的目标或者是要解决什么样的问题</li>
<li>这个技术的优势和劣势分别是什么，或者说，这个技术的 trade-off 是什么</li>
<li>这个技术的适用场景</li>
<li>技术的组成部分和关键点</li>
<li>技术的底层原理和关键实现</li>
<li>已有的实现和它之间的对比</li>
</ol>
<h2 id="这个技术出现的背景"><a href="#这个技术出现的背景" class="headerlink" title="这个技术出现的背景"></a>这个技术出现的背景</h2><p><code>redis</code> 的作者实现原因是因为想要实现高性能的队列功能，用传统的 <code>mysql</code> 没办法达到性能要求<br>因此想要做一个专属的 <code>LLOOGG</code> 数据库。<br>这样看起来，简单的来说，<code>redis</code> 的出现背景是针对 传统数据库存储的性能不足 </p>
<h2 id="这个技术的优势和劣势分别是什么"><a href="#这个技术的优势和劣势分别是什么" class="headerlink" title="这个技术的优势和劣势分别是什么"></a>这个技术的优势和劣势分别是什么</h2><ol>
<li>速度快。 读写达到10w/s</li>
<li>基于键值对对数据结构服务器。支持常用的数据结构</li>
<li>丰富的功能。键过期，发布订阅，lua脚本，简单事务，流水线</li>
<li>简单稳定。单线程模型</li>
<li>支持的客户端语言多</li>
<li>支持持久化</li>
<li>主从复制</li>
<li>高可用和分布式</li>
</ol>
<h2 id="这个技术的适用场景"><a href="#这个技术的适用场景" class="headerlink" title="这个技术的适用场景"></a>这个技术的适用场景</h2><ol>
<li>缓存。大部分使用场景都是这个</li>
<li>消息队列系统。简单的消息队列，基于发布订阅或者阻塞队列。这个只针对简单的队列功能，无持久化，重复，等复杂功能</li>
<li>排行榜和计数器应用。。。这是书上说的，感觉其实就是使用 <code>redis</code> 里面的数据结构实现的一些功能。</li>
</ol>
<p>不适用的场景：1. 数据存储。<code>redis</code> 是基于内存的，不应该将全部数据或者冷数据放到 <code>redis</code> </p>
<h2 id="技术的组成部分和关键点"><a href="#技术的组成部分和关键点" class="headerlink" title="技术的组成部分和关键点"></a>技术的组成部分和关键点</h2><p><strong>单线程模型</strong><br>首先，就是单线程模型，这个一定要知道。<br>所谓单线程模型，不代表 redis 进程内部只有一个线程，而是，只用单线程处理客户请求的命令<br>所以从客户端发请求到响应要经过以下过程：</p>
<ol>
<li>命令网络传输</li>
<li>命令队列等待时间</li>
<li>命令处理时间</li>
<li>命令响应网络传输</li>
</ol>
<p>通常 redis 保证命令处理时间很短，当然，在有大量 key 的 redis 使用 keys 命令也是会执行很长时间的</p>
<p><strong>数据结构</strong><br>支持5种数据结构。 string，hash，list，set，zset</p>
<p>string 内部编码是 </p>
<ol>
<li>raw &gt;39个字节的字符串</li>
<li>int 8个字节长整型</li>
<li>embstr &lt;= 39 个字节的字符串<br>hash 的内部编码：</li>
<li>hashtable  不满足下面的情况下使用</li>
<li>ziplist  hash类型元素个数小于 hash-max-ziplist-entries 默认 512 个，这个是一个紧凑的结构，节省内存<br>list 的内部编码是 </li>
<li>linkedlist 不满足下面的条件</li>
<li>ziplist 列表元素个数小于 list-max-ziplist-entries 默认 512 个，同时列表每个元素的值小于 list-max-ziplist-value 默认 64 字节<br>set 的内部编码是 </li>
<li>hashtable 不满足下面</li>
<li>intset 元素是整数，并且数量小于 set-man-intset-entries<br>zset 的内部编码是 </li>
<li>skiplist 不满足下面条件</li>
<li>ziplist 元素个数小于 zet-max-ziplist-entries 默认 128 个 同时元素小于 zset-max-ziplist-value 默认 64 字节</li>
</ol>
<p><strong>键过期</strong><br><code>expire</code> 设置过期时间 和 <code>ttl</code> 查询存活时间，返回 -1 代表没设置过期时间，-2 键不存在<br>键过期有两种方式，一种是惰性的，当访问到 key 到时候检查 key 过期了才移除，另一种是定时抽样检查移除过期的 key，如果比例大于 25%，继续进行抽样，直到运行超时 25ms </p>
<p><strong>pipeline</strong><br>pipeline 简单点说，就是将一批命令，整体打包发送给 redis，这样节省了 客户端与redis 的网络通信时间</p>
<p><strong>持久化</strong><br>主要有两种持久化方式 rdb 和 aof </p>
<ol>
<li><p>rdb<br>rdb 相当于当前 redis 数据的快照，生成文件存放在硬盘<br>分为自动触发和手动触发，手动使用 <code>bgsave</code> 自动就是配置 <code>save m n</code> 标示 m 秒内有 n 次修改触发<br>文件保存 dir 配置的目录下，文件名韦 dbfilename 配置<br>rdb 没办法做到实时持久化，是一个紧凑的 二进制文件，redis 加载 rdb 文件比 aof 快</p>
</li>
<li><p>aof<br>就是以独立日志记录每次写命令，<br>开启需要 appendonly yes 配置开启 文件名为 appendfilename 配置<br>里面关键的是文件同步策略。每次命令是写在缓冲区，什么时候刷盘，需要配置 appendfsync 有 always everysec no 默认是 everysec<br>当 aof 文件很大的时候可以重写，直接使用当前 redis 的数据重写 aof 文件<br>手动触发 使用命令 bgrewriteaof<br>自动触发 根据配置 auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage </p>
</li>
</ol>
<p><strong>事务</strong><br>将一组要执行的命令放在 multi  和 exec 命令中间<br>可以使用 discard 命令停止事务<br>如果命令过程中有语法错误，事务不执行<br>如果命令用错了，譬如 sadd 写成了 zadd ，错误前面的命令会执行。。</p>
<p><strong>支持主从复制</strong><br>主从是高可用的基础<br>启动的时候使用配置 slaveof host port 配置<br>也可以在运行过程中执行命令 slaveof host port<br>查看主从信息，可以 info replication 命令<br>断开主从，可以 slaveof no one 断开主从连接，不会删除已有数据，只是无法接收新的数据变化<br>可以先断开主从，然后切换新的主节点，注意，切换过程中原有数据将删除，重新同步新的主节点数据，slave 默认只读<br>每个 redis 节点根据 运行id 区分，每次启动都会动态分配一个 40 位的运行 id</p>
<p><strong>高可用-哨兵</strong><br>哨兵基于主从复制，在主节点出现故障的时候完成故障转移操作，提升一个从节点为主节点，并将其他从节点修改主节点地址<br>判断主节点故障至少需要 n/2 + 1 个哨兵确认<br>客户端获取主节点地址要通过哨兵获取，每监控一个主键点，其实就是一个 mastername，一套哨兵可以同时监控多个主节点</p>
<p>故障转移的步骤简单说</p>
<ol>
<li>判断主节点故障</li>
<li>选择一个 sentinal 节点完成故障转移功能</li>
<li>选择一个数据最全的从节点作为新的主节点</li>
<li>切换</li>
</ol>
<p>当然，中间有很多细节，就不写了。就算看了也估计就能记一段时间，这些概念还是能够理解的</p>
<p><strong>高可用-集群</strong><br>当数据量过大，单个节点存不下所有数据，需要多个 redis 节点分担的时候，使用 redis 集群方案<br>数据分区规则：<br>根据虚拟槽分区，使用一个 hash 函数，将数据映射到一个 整数集合中，定义为 slot 槽，redis 到 slot 范围为 0 - 16383<br>每个 redis 主节点负责一部分 slot，一个 redis 集群，必须每个 slot 都有节点负责，这个时候 redis 集群才能正常工作  </p>
<p>以集群模式启动 redis 需要配置<br>cluster-enabled yes<br>配置内部配置文件，这个通常是生成的配置<br>cluster-config-file node-port.conf  </p>
<p>然后完成节点握手 通过 gossip 流言协议，达到互相感知<br>cluster meet host port 命令</p>
<p>然后分配 slot<br>cluster addslots {0…5461} </p>
<p>分配了slot 的节点可以认为是主节点，然后配置其他节点复制响应的主节点，根据 nodeid 复制<br>cluster replicate nodeid</p>
<p>当然，手动配置比较复杂，使用 redis-trib.rb 搭建集群简单点 </p>
<p>当有新的节点加入，可以将部分 slot 转移个新节点<br>当有主节点退出，也可以将他负责的 slot 转移给其他节点</p>
<h2 id="已有的实现和它之间的对比"><a href="#已有的实现和它之间的对比" class="headerlink" title="已有的实现和它之间的对比"></a>已有的实现和它之间的对比</h2><p>memcached 多线程模型，只支持 key value<br>好吧，其实我没用过，也没了解过这个东西。。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>除了上面的5个数据结构，还有一些扩展 </p>
<p><strong>位图</strong><br>bitmap<br>事件上是字符串，内部存 0 1<br>命令 setbit key offset value    getbit key offset<br>还有一些其他的命令，用到的时候可以详细看  </p>
<p><strong>hyperloglog</strong><br>这实际上是一个基数算法，可以使用更少的内存空间完成集合运算，当然存在一定误差</p>
<p><strong>pub/sub</strong><br>基于频道的发布订阅，之前高可用内部通信很多都是基于这个<br>可以看着简单的队列<br>命令：<br>publish chennel message<br>subscribe channel<br>unsubscribe channel</p>
<p><strong>geo</strong><br>地理位置信息<br>geoadd key longtitude latitude member 。。。</p>
<p>完成地理位置信息的录入后，可以做些计算。。没用过  </p>
<p><strong>stream</strong><br>redis5 新增的一个消息队列<br>与 kafka 类型，之前的发布订阅，订阅者可以获取全量数据，并且无法获取之前的数据<br>stream 目前会存一份原数据，消费者也分为消费者组，每个组消费全量数据，组内每个消费者竞争获取</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/Rest%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/27/Rest%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Rest学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-27 12:37:55" itemprop="dateCreated datePublished" datetime="2019-07-27T12:37:55+08:00">2019-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-10 00:48:34" itemprop="dateModified" datetime="2019-11-10T00:48:34+08:00">2019-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">技术笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><h3 id="消息（1字头）"><a href="#消息（1字头）" class="headerlink" title="消息（1字头）"></a>消息（1字头）</h3><ul>
<li>100<br>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。    </li>
<li>101<br>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。    </li>
<li>102<br>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。    </li>
</ul>
<h3 id="成功（2字头）"><a href="#成功（2字头）" class="headerlink" title="成功（2字头）"></a>成功（2字头）</h3><ul>
<li>200<br>请求已成功，请求所希望的响应头或数据体将随此响应返回。    </li>
<li>201<br>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。    </li>
<li>202<br>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。<br>返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。    </li>
<li>203<br>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。    </li>
<li>204<br>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。<br>如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。<br>由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。    </li>
<li>205<br>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。    </li>
<li>206<br>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。    </li>
<li>207<br>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。    </li>
</ul>
<h3 id="重定向（3字头）"><a href="#重定向（3字头）" class="headerlink" title="重定向（3字头）"></a>重定向（3字头）</h3><ul>
<li>300<br>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。    </li>
<li>301<br>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。<br>新的永久性的URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。<br>如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。    </li>
<li>302<br>请求的资源临时从不同的 URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。    </li>
<li>303<br>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。    </li>
<li>304<br>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。<br>该响应必须包含以下的头信息：<br>Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。<br>ETag 和/或 Content-Location，假如同样的请求本应返回200响应。<br>Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。    </li>
<li>305<br>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。    </li>
<li>306<br>在最新版的规范中，306状态码已经不再被使用。    </li>
<li>307<br>请求的资源临时从不同的URI 响应请求。    </li>
</ul>
<h3 id="请求错误（4字头）"><a href="#请求错误（4字头）" class="headerlink" title="请求错误（4字头）"></a>请求错误（4字头）</h3><ul>
<li>400<br>语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。    </li>
<li>401<br>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。    </li>
<li>402<br>该状态码是为了将来可能的需求而预留的。    </li>
<li>403<br>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。    </li>
<li>404<br>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。    </li>
<li>405<br>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。<br>鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。    </li>
<li>406<br>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。<br>除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。    </li>
<li>407<br>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。    </li>
<li>408<br>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。    </li>
<li><p>409<br>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。    </p>
</li>
<li><p>410<br>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。<br>410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。    </p>
</li>
<li>411<br>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。    </li>
<li>412<br>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。    </li>
<li>413<br>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。    </li>
<li>414<br>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：<br>本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。<br>重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。    </li>
<li>415<br>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。    </li>
<li>416<br>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。    </li>
<li>417<br>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。    </li>
<li>422<br>请求格式正确，但是由于含有语义错误，无法响应。    </li>
<li>423<br>当前资源被锁定。    </li>
<li>424<br>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。     </li>
<li>425<br>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。    </li>
<li>426<br>客户端应当切换到TLS/1.0。（RFC 2817）</li>
<li>449<br>由微软扩展，代表请求应当在执行完适当的操作后进行重试。    </li>
</ul>
<h3 id="服务器错误（5-6字头）"><a href="#服务器错误（5-6字头）" class="headerlink" title="服务器错误（5,6字头）"></a>服务器错误（5,6字头）</h3><ul>
<li>500<br>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。    </li>
<li>501<br>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。    </li>
<li>502<br>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。    </li>
<li>503<br>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。    </li>
<li>504<br>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。    </li>
<li>505<br>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。    </li>
<li>506<br>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。    </li>
<li>507<br>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。     </li>
<li>509<br>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。    </li>
<li>510<br>获取资源所需要的策略并没有没满足。    </li>
<li>600<br>源站没有返回响应头部，只返回实体内容    </li>
</ul>
<hr>
<h2 id="开发REST-API"><a href="#开发REST-API" class="headerlink" title="开发REST API"></a>开发REST API</h2><p>使用REST虽然非常简单，但是，设计一套合理的REST框架却需要仔细考虑很多问题。    </p>
<h3 id="问题一：如何组织URL"><a href="#问题一：如何组织URL" class="headerlink" title="问题一：如何组织URL"></a>问题一：如何组织URL</h3><p>在实际工程中，一个Web应用既有REST，还有MVC，可能还需要集成其他第三方系统。如何组织URL？<br>一个简单的方法是通过固定的前缀区分。例如，<code>/static/</code>开头的URL是静态资源文件，类似的，<code>/api/</code>开头的URL就是REST API，其他URL是普通的MVC请求。<br>使用不同的子域名也可以区分，但对于中小项目来说配置麻烦。随着项目的扩大，将来仍然可以把单域名拆成多域名。    </p>
<h3 id="问题二：如何统一输出REST"><a href="#问题二：如何统一输出REST" class="headerlink" title="问题二：如何统一输出REST"></a>问题二：如何统一输出REST</h3><p>如果每个异步函数都编写下面这样的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置Content-Type:</span></span><br><span class="line">ctx.response.type = <span class="string">'application/json'</span>;</span><br><span class="line"><span class="comment">// 设置Response Body:</span></span><br><span class="line">ctx.response.body = &#123;</span><br><span class="line">    products: products</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>很显然，这样的重复代码很容易导致错误，例如，写错了字符串<code>&#39;application/json&#39;</code>，或者漏写了<code>ctx.response.type = &#39;application/json&#39;</code>，都会导致浏览器得不到JSON数据。    </p>
<h3 id="问题三：如何处理错误"><a href="#问题三：如何处理错误" class="headerlink" title="问题三：如何处理错误"></a>问题三：如何处理错误</h3><p>这个问题实际上有两部分。<br>第一，当REST API请求出错时，我们如何返回错误信息？<br>第二，当客户端收到REST响应后，如何判断是成功还是错误？<br>这两部分还必须统一考虑。<br>REST架构本身对错误处理并没有统一的规定。实际应用时，各种各样的错误处理机制都有。有的设计得比较合理，有的设计得不合理，导致客户端尤其是手机客户端处理API简直就是噩梦。<br>在涉及到REST API的错误时，我们必须先意识到，客户端会遇到两种类型的REST API错误。<br>一类是类似403，404，500等错误，这些错误实际上是HTTP请求可能发生的错误。REST请求只是一种请求类型和响应类型均为JSON的HTTP请求，因此，这些错误在REST请求中也会发生。<br>针对这种类型的错误，客户端除了提示用户“出现了网络错误，稍后重试”以外，并无法获得具体的错误信息。<br>另一类错误是业务逻辑的错误，例如，输入了不合法的Email地址，试图删除一个不存在的Product，等等。这种类型的错误完全可以通过JSON返回给客户端，这样，客户端可以根据错误信息提示用户“Email不合法”等，以便用户修复后重新请求API。<br>问题的关键在于客户端必须能区分出这两种类型的错误。<br>第一类的错误实际上客户端可以识别，并且我们也无法操控HTTP服务器的错误码。<br>第二类的错误信息是一个JSON字符串，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"code"</span>: <span class="string">"10000"</span>,</span><br><span class="line">    <span class="string">"message"</span>: <span class="string">"Bad email address"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是HTTP的返回码应该用啥？<br>有的Web应用使用<code>200</code>，这样客户端在识别出第一类错误后，如果遇到<code>200</code>响应，则根据响应的JSON判断是否有错误。这种方式对于动态语言（例如，JavaScript，Python等）非常容易：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="built_in">JSON</span>.parse(response.data);</span><br><span class="line"><span class="keyword">if</span> (result.code) &#123;</span><br><span class="line">    <span class="comment">// 有错误:</span></span><br><span class="line">    alert(result.message);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，对于静态语言（例如，Java）就比较麻烦，很多时候，不得不做两次序列化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">APIError err = objectMapper.readValue(jsonString, APIError<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (err.code == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有错误，还需要重新转换:</span></span><br><span class="line">    User user = objectMapper.readValue(jsonString, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 有错误:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有的Web应用对正确的REST响应使用<code>200</code>，对错误的REST响应使用<code>400</code>，这样，客户端即是静态语言，也可以根据HTTP响应码判断是否出错，出错时直接把结果反序列化为APIError对象。<br>两种方式各有优劣。我们选择第二种，<code>200</code>表示成功响应，<code>400</code>表示失败响应。    </p>
<p>但是，要注意，<em>绝不能</em>混合其他HTTP错误码。例如，使用401响应“登录失败”，使用403响应“权限不够”。这会使客户端无法有效识别HTTP错误码和业务错误，其原因在于HTTP协议定义的错误码十分偏向底层，而REST API属于“高层”协议，不应该复用底层的错误码。    </p>
<h3 id="如何定义错误码"><a href="#如何定义错误码" class="headerlink" title="如何定义错误码"></a>如何定义错误码</h3><p>REST架构本身同样没有标准的错误码定义一说，因此，有的Web应用使用数字<code>1000、1001……</code>作为错误码，例如Twitter和新浪微博，有的Web应用使用字符串作为错误码，例如YouTube。到底哪一种比较好呢？    </p>
<p>我们强烈建议使用字符串作为错误码。原因在于，使用数字作为错误码时，API提供者需要维护一份错误码代码说明表，并且，该文档必须时刻与API发布同步，否则，客户端开发者遇到一个文档上没有写明的错误码，就完全不知道发生了什么错误。    </p>
<p>使用字符串作为错误码，最大的好处在于不用查表，根据字面意思也能猜个八九不离十。例如，YouTube API如果返回一个错误<code>authError</code>，基本上能猜到是因为认证失败。    </p>
<p>我们定义的REST API错误格式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"code"</span>: <span class="string">"错误代码"</span>,</span><br><span class="line">    <span class="string">"message"</span>: <span class="string">"错误描述信息"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，错误代码命名规范为<em>大类:子类</em>，例如，口令不匹配的登录错误代码为<code>auth:bad_password</code>，用户名不存在的登录错误代码为<code>auth:user_not_found</code>。这样，客户端既可以简单匹配某个类别的错误，也可以精确匹配某个特定的错误。    </p>
<h3 id="问题五：如何返回错误"><a href="#问题五：如何返回错误" class="headerlink" title="问题五：如何返回错误"></a>问题五：如何返回错误</h3><p>如果一个REST异步函数想要返回错误，一个直观的想法是调用<code>ctx.rest()</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">user = processLogin(username, password);</span><br><span class="line"><span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">    ctx.rest(user);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.response.status = <span class="number">400</span>;</span><br><span class="line">    ctx.rest(&#123;</span><br><span class="line">        code: <span class="string">'auth:user_not_found'</span>,</span><br><span class="line">        message: <span class="string">'user not found'</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式不好，因为控制流程会混乱，而且，错误只能在Controller函数中输出。<br>更好的方式是异步函数直接用throw语句抛出错误，让middleware去处理错误：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user = processLogin(username, password);</span><br><span class="line"><span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">    ctx.rest(user);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> APIError(<span class="string">'auth:user_not_found'</span>, <span class="string">'user not found'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式可以在异步函数的任何地方抛出错误，包括调用的子函数内部。<br>我们只需要稍稍改写一个middleware就可以处理错误：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    APIError: <span class="function"><span class="keyword">function</span> (<span class="params">code, message</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code || <span class="string">'internal:unknown_error'</span>;</span><br><span class="line">        <span class="keyword">this</span>.message = message || <span class="string">''</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    restify: <span class="function">(<span class="params">pathPrefix</span>) =&gt;</span> &#123;</span><br><span class="line">        pathPrefix = pathPrefix || <span class="string">'/api/'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctx.request.path.startsWith(pathPrefix)) &#123;</span><br><span class="line">                <span class="comment">// 绑定rest()方法:</span></span><br><span class="line">                ctx.rest = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">                    ctx.response.type = <span class="string">'application/json'</span>;</span><br><span class="line">                    ctx.response.body = data;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">await</span> next();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="comment">// 返回错误:</span></span><br><span class="line">                    ctx.response.status = <span class="number">400</span>;</span><br><span class="line">                    ctx.response.type = <span class="string">'application/json'</span>;</span><br><span class="line">                    ctx.response.body = &#123;</span><br><span class="line">                        code: e.code || <span class="string">'internal:unknown_error'</span>,</span><br><span class="line">                        message: e.message || <span class="string">''</span></span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">await</span> next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个错误处理的好处在于，不但简化了Controller的错误处理（只需要throw，其他不管），并且，在遇到非APIError的错误时，自动转换错误码为<code>internal:unknown_error</code>。<br>受益于async/await语法，我们在middleware中可以直接用try…catch捕获异常。如果是callback模式，就无法用try…catch捕获，代码结构将混乱得多。<br>最后，顺便把APIError这个对象export出去。    </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/OpenSSL%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/27/OpenSSL%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">OpenSSL使用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-27 12:35:29" itemprop="dateCreated datePublished" datetime="2019-07-27T12:35:29+08:00">2019-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-10 00:48:31" itemprop="dateModified" datetime="2019-11-10T00:48:31+08:00">2019-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">技术笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。<br>在OpenSSL被曝出现严重安全漏洞后，发现多数通过SSL协议加密的网站使用名为OpenSSL的开源软件包。由于这是互联网应用最广泛的安全传输方法，被网银、在线支付、电商网站、门户网站、电子邮件等重要网站广泛使用，所以该漏洞影响范围广大。    </p>
<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>OpenSSL一共提供了8种对称加密算法，其中7种是分组加密算法，仅有的一种流加密算法是RC4。这7种分组加密算法分别是AES、DES、Blowfish、CAST、IDEA、RC2、RC5，都支持电子密码本模式（ECB）、加密分组链接模式（CBC）、加密反馈模式（CFB）和输出反馈模式（OFB）四种常用的分组密码加密模式。其中，AES使用的加密反馈模式（CFB）和输出反馈模式（OFB）分组长度是128位，其它算法使用的则是64位。事实上，DES算法里面不仅仅是常用的DES算法，还支持三个密钥和两个密钥3DES算法。        </p>
<h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><p>OpenSSL一共实现了4种非对称加密算法，包括DH算法、RSA算法、DSA算法和椭圆曲线算法（EC）。DH算法一般用户密钥交换。RSA算法既可以用于密钥交换，也可以用于数字签名，当然，如果你能够忍受其缓慢的速度，那么也可以用于数据加密。DSA算法则一般只用于数字签名。        </p>
<h2 id="信息摘要算法"><a href="#信息摘要算法" class="headerlink" title="信息摘要算法"></a>信息摘要算法</h2><p>OpenSSL实现了5种信息摘要算法，分别是MD2、MD5、MDC2、SHA（SHA1）和RIPEMD。SHA算法事实上包括了SHA和SHA1两种信息摘要算法，此外，OpenSSL还实现了DSS标准中规定的两种信息摘要算法DSS和DSS1。        </p>
<h2 id="密钥和证书管理"><a href="#密钥和证书管理" class="headerlink" title="密钥和证书管理"></a>密钥和证书管理</h2><p>密钥和证书管理是PKI的一个重要组成部分，OpenSSL为之提供了丰富的功能，支持多种标准。     </p>
<p>首先，OpenSSL实现了ASN.1的证书和密钥相关标准，提供了对证书、公钥、私钥、证书请求以及CRL等数据对象的DER、PEM和BASE64的编解码功能。OpenSSL提供了产生各种公开密钥对和对称密钥的方法、函数和应用程序，同时提供了对公钥和私钥的DER编解码功能。并实现了私钥的PKCS#12和PKCS#8的编解码功能。OpenSSL在标准中提供了对私钥的加密保护功能，使得密钥可以安全地进行存储和分发。     </p>
<p>在此基础上，OpenSSL实现了对证书的X.509标准编解码、PKCS#12格式的编解码以及PKCS#7的编解码功能。并提供了一种文本数据库，支持证书的管理功能，包括证书密钥产生、请求产生、证书签发、吊销和验证等功能。     </p>
<p>事实上，OpenSSL提供的CA应用程序就是一个小型的证书管理中心（CA），实现了证书签发的整个流程和证书管理的大部分机制。        </p>
<h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><ol>
<li>消息摘要算法应用例子        </li>
</ol>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 用SHA1算法计算文件file.txt的哈西值，输出到stdout</span><br><span class="line"># openssl dgst -sha1 file.txt</span><br><span class="line"></span><br><span class="line">#用SHA1算法计算文件file.txt的哈西值,输出到文件digest.txt</span><br><span class="line"># openssl sha1 -out digest.txt file.txt	</span><br><span class="line"></span><br><span class="line"># 用DSS1(SHA1)算法为文件file.txt签名,输出到文件dsasign.bin</span><br><span class="line"># 签名的private key必须为DSA算法产生的，保存在文件dsakey.pem中</span><br><span class="line"># openssl dgst -dss1 -sign dsakey.pem -out dsasign.bin file.txt</span><br><span class="line"></span><br><span class="line"># 用dss1算法验证file.txt的数字签名dsasign.bin，</span><br><span class="line"># 验证的private key为DSA算法产生的文件dsakey.pem</span><br><span class="line"># openssl dgst -dss1 -prverify dsakey.pem -signature dsasign.bin file.txt</span><br><span class="line"></span><br><span class="line"># 用sha1算法为文件file.txt签名,输出到文件rsasign.bin</span><br><span class="line"># 签名的private key为RSA算法产生的文件rsaprivate.pem</span><br><span class="line"># openssl sha1 -sign rsaprivate.pem -out rsasign.bin file.txt</span><br><span class="line"></span><br><span class="line"># 用sha1算法验证file.txt的数字签名rsasign.bin，</span><br><span class="line"># 验证的public key为RSA算法生成的rsapublic.pem</span><br><span class="line"># openssl sha1 -<span class="built_in">verify</span> rsapublic.pem -signature rsasign.bin file.txt</span><br></pre></td></tr></table></figure>
<ol>
<li>对称加密应用例子        </li>
</ol>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 对称加密应用例子</span><br><span class="line"># 用DES3算法的CBC模式加密文件plaintext.doc，</span><br><span class="line"># 加密结果输出到文件ciphertext.bin</span><br><span class="line"># openssl enc -des3 -salt -<span class="keyword">in</span> plaintext.doc -out ciphertext.bin</span><br><span class="line"></span><br><span class="line"># 用DES3算法的OFB模式解密文件ciphertext.bin，</span><br><span class="line"># 提供的口令为trousers，输出到文件plaintext.doc</span><br><span class="line"># 注意：因为模式不同，该命令不能对以上的文件进行解密</span><br><span class="line"># openssl enc -des-ede3-ofb -d -<span class="keyword">in</span> ciphertext.bin -out plaintext.doc -pass pass:trousers</span><br><span class="line"></span><br><span class="line"># 用Blowfish的CFB模式加密plaintext.doc，口令从环境变量PASSWORD中取</span><br><span class="line"># 输出到文件ciphertext.bin</span><br><span class="line"># openssl bf-cfb -salt -<span class="keyword">in</span> plaintext.doc -out ciphertext.bin -pass env:PASSWORD</span><br><span class="line"></span><br><span class="line"># 给文件ciphertext.bin用base64编码，输出到文件base64.txt</span><br><span class="line"># openssl base64 -<span class="keyword">in</span> ciphertext.bin -out base64.txt</span><br><span class="line"></span><br><span class="line"># 用RC5算法的CBC模式加密文件plaintext.doc</span><br><span class="line"># 输出到文件ciphertext.bin，</span><br><span class="line"># salt、key和初始化向量(iv)在命令行指定</span><br><span class="line"># openssl rc5 -<span class="keyword">in</span> plaintext.doc -out ciphertext.bin -S C62CB1D49F158ADC -iv E9EDACA1BD7090C6 -K <span class="number">89</span>D4B1678D604FAA3DBFFD030A314B29</span><br></pre></td></tr></table></figure>
<ol>
<li>Diffie-Hellman应用例子        </li>
</ol>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 使用生成因子<span class="number">2</span>和随机的<span class="number">1024</span>-bit的素数产生D0ffie-Hellman参数</span><br><span class="line"># 输出保存到文件dhparam.pem</span><br><span class="line"># openssl dhparam -out dhparam.pem -<span class="number">2</span> <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"># 从dhparam.pem中读取Diffie-Hell参数，以C代码的形式</span><br><span class="line"># 输出到stdout</span><br><span class="line"># openssl dhparam -<span class="keyword">in</span> dhparam.pem -noout -C</span><br></pre></td></tr></table></figure>
<ol>
<li>DSA应用例子应用例子        </li>
</ol>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 生成<span class="number">1024</span>位DSA参数集，并输出到文件dsaparam.pem</span><br><span class="line"># openssl dsaparam -out dsaparam.pem <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"># 使用参数文件dsaparam.pem生成DSA私钥匙，</span><br><span class="line"># 采用<span class="number">3</span>DES加密后输出到文件dsaprivatekey.pem</span><br><span class="line"># openssl gendsa -out dsaprivatekey.pem -des3 dsaparam.pem</span><br><span class="line"></span><br><span class="line"># 使用私钥匙dsaprivatekey.pem生成公钥匙，</span><br><span class="line"># 输出到dsapublickey.pem</span><br><span class="line"># openssl dsa -<span class="keyword">in</span> dsaprivatekey.pem -pubout -out dsapublickey.pem</span><br><span class="line"></span><br><span class="line"># 从dsaprivatekey.pem中读取私钥匙，解密并输入新口令进行加密，</span><br><span class="line"># 然后写回文件dsaprivatekey.pem</span><br><span class="line"># openssl dsa -<span class="keyword">in</span> dsaprivatekey.pem -out dsaprivatekey.pem -des3 -passin</span><br></pre></td></tr></table></figure>
<ol>
<li>RSA应用例子        </li>
</ol>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># 产生<span class="number">1024</span>位RSA私匙，用<span class="number">3</span>DES加密它，口令为trousers，</span><br><span class="line"># 输出到文件rsaprivatekey.pem</span><br><span class="line"># openssl genrsa -out rsaprivatekey.pem -passout pass:trousers -des3 <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"># 从文件rsaprivatekey.pem读取私匙，用口令trousers解密，</span><br><span class="line"># 生成的公钥匙输出到文件rsapublickey.pem</span><br><span class="line"># openssl rsa -<span class="keyword">in</span> rsaprivatekey.pem -passin pass:trousers -pubout -out rsapubckey.pem</span><br><span class="line"></span><br><span class="line"># 用公钥匙rsapublickey.pem加密文件plain.txt，</span><br><span class="line"># 输出到文件cipher.txt</span><br><span class="line"># openssl rsautl -encrypt -pubin -inkey rsapublickey.pem -<span class="keyword">in</span> plain.txt -out cipher.txt</span><br><span class="line"></span><br><span class="line"># 使用私钥匙rsaprivatekey.pem解密密文cipher.txt，</span><br><span class="line"># 输出到文件plain.txt</span><br><span class="line"># openssl rsautl -decrypt -inkey rsaprivatekey.pem -<span class="keyword">in</span> cipher.txt -out plain.txt</span><br><span class="line"></span><br><span class="line"># 用私钥匙rsaprivatekey.pem给文件plain.txt签名，</span><br><span class="line"># 输出到文件signature.bin</span><br><span class="line"># openssl rsautl -sign -inkey rsaprivatekey.pem -<span class="keyword">in</span> plain.txt -out signature.bin</span><br><span class="line"></span><br><span class="line"># 用公钥匙rsapublickey.pem验证签名signature.bin，</span><br><span class="line"># 输出到文件plain.txt</span><br><span class="line"># openssl rsautl -<span class="built_in">verify</span> -pubin -inkey rsapublickey.pem -<span class="keyword">in</span> signature.bin -out plain</span><br><span class="line"></span><br><span class="line"># 从X.<span class="number">509</span>证书文件cert.pem中获取公钥匙，</span><br><span class="line"># 用<span class="number">3</span>DES加密mail.txt</span><br><span class="line"># 输出到文件mail.enc</span><br><span class="line"># openssl smime -encrypt -<span class="keyword">in</span> mail.txt -des3 -out mail.enc cert.pem</span><br><span class="line"></span><br><span class="line"># 从X.<span class="number">509</span>证书文件cert.pem中获取接收人的公钥匙，</span><br><span class="line"># 用私钥匙key.pem解密S/MIME消息mail.enc，</span><br><span class="line"># 结果输出到文件mail.txt</span><br><span class="line"># openssl smime -decrypt -<span class="keyword">in</span> mail.enc -recip cert.pem -inkey key.pem -out mail.txt</span><br><span class="line"></span><br><span class="line"># cert.pem为X.<span class="number">509</span>证书文件，用私匙key,pem为mail.txt签名，</span><br><span class="line"># 证书被包含在S/MIME消息中，输出到文件mail.sgn</span><br><span class="line"># openssl smime -sign -<span class="keyword">in</span> mail.txt -signer cert.pem -inkey key.pem -out mail.sgn</span><br><span class="line"></span><br><span class="line"># 验证S/MIME消息mail.sgn，输出到文件mail.txt</span><br><span class="line"># 签名者的证书应该作为S/MIME消息的一部分包含在mail.sgn中</span><br><span class="line"># openssl smime -<span class="built_in">verify</span> -<span class="keyword">in</span> mail.sgn -out mail.txt</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/spring-%E6%BA%90%E7%A0%81%E5%86%8D%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/27/spring-%E6%BA%90%E7%A0%81%E5%86%8D%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">spring 源码再分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-07-27 12:32:26 / 修改时间：12:34:12" itemprop="dateCreated datePublished" datetime="2019-07-27T12:32:26+08:00">2019-07-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <img src="/2019/07/27/spring-%E6%BA%90%E7%A0%81%E5%86%8D%E5%88%86%E6%9E%90/spring%E5%88%9D%E5%A7%8B%E5%8C%96-%E5%8D%95%E4%BE%8B%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B.svg" class="" title="This is an example image">
<p>ConfigurationClassPostProcessor        BeanDefinitionRegistryPostProcessor<br>AutowiredAnnotationBeanPostProcessor            InstantiationAwareBeanPostProcessorAdapter<br>CommonAnnotationBeanPostProcessor             InstantiationAwareBeanPostProcessor</p>
<p>EventListenerMethodProcessor        SmartInitializingSingleton<br>DefaultEventListenerFactory                EventListenerFactory<br>ApplicationContextAwareProcessor        BeanPostProcessor</p>
<p>ApplicationListenerDetector        BeanPostProcessor</p>
<p>BeanPostProcessorChecker</p>
<ol>
<li>prepareRefresh<br> 记录启动时间</li>
<li>prepareBeanFactory<br> 忽略和设置框架依赖注入</li>
<li>postProcessBeanFactory<br> 扩展方法，</li>
<li><p>invokeBeanFactoryPostProcessors<br> 调用 BeanFactoryPostProcessor  BeanDefinitionRegistryPostProcessor 扩展</p>
<ol>
<li>直接挂在 context 上的 BeanDefinitionRegistryPostProcessor   -&gt; postProcessBeanDefinitionRegistry</li>
<li>beanFactory 里面的  BeanDefinitionRegistryPostProcessor ,PriorityOrdered -&gt;  postProcessBeanDefinitionRegistry</li>
<li>beanFactory 里面的  BeanDefinitionRegistryPostProcessor ,Ordered -&gt;  postProcessBeanDefinitionRegistry</li>
<li>beanFactory 里面的  BeanDefinitionRegistryPostProcessor -&gt;  postProcessBeanDefinitionRegistry</li>
<li>上面执行过的 继续执行 BeanFactoryPostProcessor —&gt; postProcessBeanFactory</li>
<li>直接挂在 context 上的 BeanFactoryPostProcessor —&gt; postProcessBeanFactory</li>
<li>beanFactory 里面的 BeanFactoryPostProcessor , PriorityOrdered  -&gt;  postProcessBeanFactory</li>
<li>beanFactory 里面的 BeanFactoryPostProcessor , Ordered -&gt;  postProcessBeanFactory</li>
<li>beanFactory 里面的 BeanFactoryPostProcessor  -&gt;  postProcessBeanFactory<br>这里核心的是 ConfigurationClassPostProcessor</li>
</ol>
</li>
<li><p>registerBeanPostProcessors<br> 添加 BeanPostProcessor<br> beanFactory 自身带的<br> 添加 BeanPostProcessorChecker<br> 容器里面的<br> BeanPostProcessor - PriorityOrdered<br> BeanPostProcessor - Ordered<br> BeanPostProcessor -<br> 上面三个，按照顺序添加到自身带的后面<br> BeanPostProcessor - MergedBeanDefinitionPostProcessor - PriorityOrdered<br> BeanPostProcessor - MergedBeanDefinitionPostProcessor - Ordered<br> BeanPostProcessor - MergedBeanDefinitionPostProcessor<br> 再添加一次 MergedBeanDefinitionPostProcessor 类型的，按照上面的顺序<br> 最后添加 ApplicationListenerDetector</p>
</li>
<li>initMessageSource<br> 这个是国际化的地方<br> DelegatingMessageSource</li>
<li>initApplicationEventMulticaster<br> 事件<br> SimpleApplicationEventMulticaster</li>
<li>onRefresh<br>空的，扩展接口</li>
<li>registerListeners<br>添加 ApplicationListener<br>先 beanFactory 上挂的，然后 beanFactory 里面的<br>然后将这之前的事件发布了</li>
<li>finishBeanFactoryInitialization<br>特殊处理 LoadTimeWeaverAware 先进行初始化 （getBean）<br>冻结 beanDefinition ,不再改变<br>实例化非延时加载的单例</li>
<li>finishRefresh<br>结束</li>
</ol>
<p>实例化非延时加载的单例</p>
<p>spring 实例化 bean 其实就是调用 getBean<br>内部实现是 doGetBean<br>先看 普通的 bean  后面再看 factoryBean</p>
<ol>
<li>就是去手动注册的 bean 里面检查是否存在，如果存在，直接返回了  一般只有部分 spring 内部的 bean 是手动注册的</li>
<li>在创建 bean 之前，用 InstantiationAwareBeanPostProcessor -&gt; postProcessBeforeInstantiation 处理<br> 这里参数是 class 和 beanName ，如果返回非 null ，那么就使用这里返回的 bean 然后<pre><code> BeanPostProcessor -&gt; postProcessAfterInitialization 处理生成的 bean
</code></pre></li>
<li>如果没被上面的扩展接口处理，那么进入标准的创建流程</li>
<li>如果提供了 bean 的工厂类，那么使用工厂类创建 （可以是 Supplier 或者 factoryMethod）</li>
<li>核心创建方法两个 autowireConstructor （有构造依赖的构建） 和 instantiateBean （标准创建）</li>
<li>创建完成后 调用扩展 MergedBeanDefinitionPostProcessor -&gt; postProcessMergedBeanDefinition  这里是修改 BeanDefinetion 的地方</li>
<li>populateBean  处理扩展接口 InstantiationAwareBeanPostProcessor -&gt; postProcessAfterInstantiation   返回值决定是否继续处理 propertyValue<br> 后面继续处理扩展接口  InstantiationAwareBeanPostProcessor -&gt; postProcessProperties  postProcessPropertyValues</li>
</ol>
<p>BeanPostProcessor -&gt; postProcessBeforeInitialization  </p>
<p>afterPropertiesSet  initMethod<br>BeanPostProcessor -&gt; postProcessAfterInitialization<br>注册 destoryMethod</p>
<p>几个核心的 BeanPostProcessor<br>ApplicationContextAwareProcessor<br>ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor<br>PostProcessorRegistrationDelegate$BeanPostProcessorChecker<br>CommonAnnotationBeanPostProcessor<br>AutowiredAnnotationBeanPostProcessor<br>ApplicationListenerDetector</p>
<ol>
<li>ApplicationContextAwareProcessor  实现  BeanPostProcessor<br>作用：<br>在 init 方法之前，调用 bean 的 Aware 接口<br>EnvironmentAware<br>EmbeddedValueResolverAware<br>ResourceLoaderAware<br>ApplicationEventPublisherAware<br>MessageSourceAware<br>ApplicationContextAware</li>
<li>ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor 实现 InstantiationAwareBeanPostProcessor<br>作用:<br>在依赖注入前，设置 BeanFactory 接口  EnhancedConfiguration<br>在 init 方法前 调用<br>ImportAware</li>
<li>PostProcessorRegistrationDelegate$BeanPostProcessorChecker<br>这个扩展是用来检测 bean 是否经过了所有 BeanPostProcess 的处理 ，如果没有，会有 info 日志<br>因为在实例化 bean 之前，首先处理的是 BeanPostProcessor 实例，按照顺序，是内建 -&gt; PriorityOrdered -&gt; Ordered -&gt; 非排序的<br>如果直接存在依赖注入的问题，那么，会有一个问题，在 BeanPostProcessor 里面依赖了其他普通的 bean，那么会先触发普通 bean 的实例化，但是没法享受 BeanPostProcessor 的处理了<br>要知道 无论是 ioc 还是 aop 都是使用 BeanPostProcessor 扩展的</li>
<li>CommonAnnotationBeanPostProcessor 实现 InstantiationAwareBeanPostProcessor MergedBeanDefinitionPostProcessor DestructionAwareBeanPostProcessor<br>这里处理的是 init 和 destroy 和 JSR-250 注解依赖注入的地方<br>这里的注解属于标准注解 javax.annotation.PostConstruct javax.annotation.PreDestroy  javax.annotation.Resource 等</li>
<li>AutowiredAnnotationBeanPostProcessor 实现 InstantiationAwareBeanPostProcessor  MergedBeanDefinitionPostProcessor<br>这里是处理内置注解 @Autowired   @Value  javax.inject.Inject  的注入</li>
<li>ApplicationListenerDetector<br>这里是处理 ApplicationListener 的地方，单例的 ApplicationListener 实例注册，非单例，打印警告信息</li>
</ol>
<p>ConfigurationClassPostProcessor 这个是核心类，还要仔细看看</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/spring-boot-%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/27/spring-boot-%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">spring-boot 分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-07-27 12:26:44 / 修改时间：12:33:22" itemprop="dateCreated datePublished" datetime="2019-07-27T12:26:44+08:00">2019-07-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <img src="/2019/07/27/spring-boot-%E5%88%86%E6%9E%90/springboot.svg" class="" title="This is an example image">
<h2 id="org-springframework-context-ApplicationContextInitializer"><a href="#org-springframework-context-ApplicationContextInitializer" class="headerlink" title="org.springframework.context.ApplicationContextInitializer"></a><code>org.springframework.context.ApplicationContextInitializer</code></h2><ol>
<li><code>org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer</code><br> 这里面添加了一个 <code>BeanFactoryPostProcessor</code> 实现类 <code>ConfigurationWarningsPostProcessor</code><br> 主要是打印启动过程中的警告信息的</li>
<li><code>org.springframework.boot.context.ContextIdApplicationContextInitializer</code><br> 这里处理 <code>ContextId</code>    </li>
<li><code>org.springframework.boot.context.config.DelegatingApplicationContextInitializer</code><br> 这里处理 <code>ApplicationContextInitializer</code> 的实现类<br> 这个接口就是一个 <code>initialize</code> 方法，参数是 <code>ConfigurableApplicationContext</code> 的子类<br> 当然，不是所有的 <code>ApplicationContextInitializer</code> 都会被调用，可以通过参数 <code>context.initializer.classes</code> 指定要调用的实现类，多个用逗号分隔</li>
<li><code>org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer</code><br> 这个类也实现了 <code>ApplicationListener</code> 接口，用来监听 <code>WebServerInitializedEvent</code> 时间<br> 作用是处理设置 <code>server.port</code></li>
</ol>
<h2 id="org-springframework-context-ApplicationListener"><a href="#org-springframework-context-ApplicationListener" class="headerlink" title="org.springframework.context.ApplicationListener"></a><code>org.springframework.context.ApplicationListener</code></h2><ol>
<li><code>org.springframework.boot.ClearCachesApplicationListener</code><br> 监听的事件是 <code>ContextRefreshedEvent</code> ，也就是 <code>refersh</code> 方法完成后<br> 清理反射使用的缓存</li>
<li><code>org.springframework.boot.builder.ParentContextCloserApplicationListener</code><br>监听的事件是 <code>ParentContextAvailableEvent</code><br>这个是在 <code>ParentContextApplicationContextInitializer</code> 里面触发的，<code>ApplicationContextInitializer</code> 上面说过了<br>这里处理的是有 parent 的情况，使用 <code>SpringApplicationBuilder</code> 的时候，可以指定 parent    </li>
<li><code>org.springframework.boot.context.FileEncodingApplicationListener</code><br>监听的事件是 <code>ApplicationEnvironmentPreparedEvent</code><br>就是实例化 <code>ConfigurableEnvironment</code> 后<br>作用是，检查 <code>spring.mandatory-file-encoding</code> 参数强制指定的字符集与 <code>file.encoding</code> 系统参数的字符集是否一样，如果不愿意，就异常</li>
<li><code>org.springframework.boot.context.config.AnsiOutputApplicationListener</code><br> 监听的事件是 <code>ApplicationEnvironmentPreparedEvent</code><br> 就是实例化 <code>ConfigurableEnvironment</code> 后<br> 处理参数 <code>spring.output.ansi.enabled</code> 和 <code>spring.output.ansi.console-available</code> 就是控制彩色输出</li>
<li><code>org.springframework.boot.context.config.ConfigFileApplicationListener</code><br> 监听的事件是 <code>ApplicationEnvironmentPreparedEvent</code> 和 <code>ApplicationPreparedEvent</code><br> 就是实例化 <code>ConfigurableEnvironment</code> 后和注册完主类为 BeanDefinition 后<br> 处理事件 <code>ApplicationEnvironmentPreparedEvent</code><pre><code> 加载 `EnvironmentPostProcessor` 的实现类
 默认配置有
 `org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor`
 `org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor`
 `org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor`
 在加上自身，调用 `postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application)` 方法
 这里 *关键* ，后面再细看
</code></pre> 处理事件 <code>ApplicationPreparedEvent</code><pre><code> 这里添加了一个 `BeanFactoryPostProcessor` 的实例 `PropertySourceOrderingPostProcessor`
 作用是将 `defaultProperties` 的 `PropertySource` 添加到最后
</code></pre></li>
<li><code>org.springframework.boot.context.config.DelegatingApplicationListener</code><br> 监听的事件是 <code>ApplicationEnvironmentPreparedEvent</code><br> 在 <code>ApplicationEnvironmentPreparedEvent</code> 事件的时候，获取配置 <code>context.listener.classes</code> 指定的 <code>ApplicationListener</code> 类，如果有的话，就转发其他所有事件</li>
<li><code>org.springframework.boot.context.logging.ClasspathLoggingApplicationListener</code><br> 监听的事件是 <code>ApplicationEnvironmentPreparedEvent</code> 或者 <code>ApplicationFailedEvent</code><br> 就是打印一个 <code>classpath</code> 日志</li>
<li><code>org.springframework.boot.context.logging.LoggingApplicationListener</code><br> 监听的事件 <code>ApplicationStartingEvent.class, ApplicationEnvironmentPreparedEvent.class, ApplicationPreparedEvent.class, ContextClosedEvent.class, ApplicationFailedEvent.class</code><br> 处理日志配置和等级的</li>
<li><code>org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener</code><br><code>Liquibase</code> 是数据库版本控制，具体里面做啥，没看。</li>
</ol>
<h2 id="org-springframework-boot-env-EnvironmentPostProcessor"><a href="#org-springframework-boot-env-EnvironmentPostProcessor" class="headerlink" title="org.springframework.boot.env.EnvironmentPostProcessor"></a><code>org.springframework.boot.env.EnvironmentPostProcessor</code></h2><p>上面第 5 条会触发这里，继续看    </p>
<ol>
<li><code>org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor</code><br>云原生相关的，后面看 <code>spring-cloud</code> 的时候再细看</li>
<li><code>org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor</code><br>作用就是找参数 <code>spring.application.json</code> 或者 <code>SPRING_APPLICATION_JSON</code> 指定的 <code>json</code> 文件，加载配置，优先级高于系统参数</li>
<li><code>org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor</code><br>处理 <code>systemEnvironment</code></li>
<li><p><code>org.springframework.boot.context.config.ConfigFileApplicationListener</code><br> 这里就是加载 <code>application.properties</code> 的地方<br> 如果直接指定了 <code>spring.config.location</code> 那么只去加载这里<br> 如果指定了 <code>spring.config.additional-location</code> 额外加载的文件，先加载这里<br> 加上默认的 <code>classpath:/,classpath:/config/,file:./,file:./config/</code></p>
<p> 一般上面指定的是目录，然后在目录下，找文件名，默认是 <code>application</code> , 可以通过 <code>spring.config.name</code> 参数来修改文件名<br> 剩下的就是加载过程了<br> 加载过程中，先加载 <code>spring.factory</code> 的 <code>org.springframework.boot.env.PropertySourceLoader</code> , 默认有两个实现类<br> <code>org.springframework.boot.env.PropertiesPropertySourceLoader</code>   <code>properties</code> 和 <code>xml</code><br> <code>org.springframework.boot.env.YamlPropertySourceLoader</code>      <code>yml</code> 和 <code>yaml</code><br> 好吧，看名字就知道分别处理 <code>properteis</code> 和 <code>yaml</code> 文件了</p>
</li>
</ol>
<p>以上就是 <code>spring-boot</code> 的核心配置<br>我们主要知道了，<code>spring-boot</code> 的启动过程，以及通过哪些扩展接口进行增强<br>接下来看看 <code>spring-boot-autoconfigure</code></p>
<h2 id="org-springframework-context-ApplicationContextInitializer-1"><a href="#org-springframework-context-ApplicationContextInitializer-1" class="headerlink" title="org.springframework.context.ApplicationContextInitializer"></a><code>org.springframework.context.ApplicationContextInitializer</code></h2><ol>
<li><code>org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer</code><br> 注册了一个 <code>BeanFactoryPostProcessor</code> 实现类 <code>CachingMetadataReaderFactoryPostProcessor</code><br> 作用，注册了一个 <code>SharedMetadataReaderFactoryBean</code> 的 <code>BeanDefinition</code></li>
<li><code>org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</code><br> 作用就是打印一些自动注册的日志</li>
</ol>
<h2 id="org-springframework-context-ApplicationListener-1"><a href="#org-springframework-context-ApplicationListener-1" class="headerlink" title="org.springframework.context.ApplicationListener"></a><code>org.springframework.context.ApplicationListener</code></h2><ol>
<li><code>org.springframework.boot.autoconfigure.BackgroundPreinitializer</code><br> 监听的事件是 <code>SpringApplicationEvent</code> 这是一个抽象类 ，上面说的 <code>spring-boot</code> 相关的事件类，大部分都是这个类的子类<br> 作用就是启动一个线程去做一些初始化，类相关的</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/artha-%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/27/artha-%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">artha 学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-27 00:57:02" itemprop="dateCreated datePublished" datetime="2019-07-27T00:57:02+08:00">2019-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-10 00:48:29" itemprop="dateModified" datetime="2019-11-10T00:48:29+08:00">2019-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">技术笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="artha-文档地址"><a href="#artha-文档地址" class="headerlink" title="artha 文档地址"></a><a href="https://alibaba.github.io/arthas/index.html" target="_blank" rel="noopener">artha 文档地址</a></h2><h2 id="artha-能做什么"><a href="#artha-能做什么" class="headerlink" title="artha 能做什么"></a>artha 能做什么</h2><p>官网摘抄：</p>
<blockquote>
<p>Arthas 是Alibaba开源的Java诊断工具<br>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p>
<ol>
<li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li>
<li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li>
<li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li>
<li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li>
<li>是否有一个全局视角来查看系统的运行状况？</li>
<li>有什么办法可以监控到JVM的实时运行状态？<br>说简单点，就是针对正在运行的 <code>jvm</code> 进程,当无法使用日志分析出问题，本地没法或者很难重现的情况下，观察正在运行的 <code>jvm</code> 内部信息，包括整体情况，方法执行，变量信息等</li>
</ol>
<hr>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>基于 <code>JDK6</code> 开始的 <code>Instrumentation</code> 功能<br>关于 <code>Instrumentation</code> 的介绍可以看 <a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html" target="_blank" rel="noopener">Instrumentation 新功能</a><br>摘抄:<br>总的来说，基于 <code>Instrumentation</code> 功能，开发者可以构建一个独立于应用程序的代理程序（Agent），用来监测和协助运行在 JVM 上的程序，甚至能够替换和修改某些类的定义。<br>有了这样的功能，开发者就可以实现更为灵活的运行时虚拟机监控和 Java 类操作了，这样的特性实际上提供了一种虚拟机级别支持的 AOP 实现方式，使得开发者无需对 JDK 做任何升级和改动，就可以实现某些 AOP 的功能了。<br>独立开发的代理程序，可以通过应用启动的时候指定，或者对运行中的 <code>JVM</code> 进行 <code>attach</code>。<br>基于 <code>artha</code> 大部分时候都是动态载入的，允许远程载入（没做测试）<br>其实，简单点说，就是在应用程序运行中的时候，加载代理（<code>artha</code>），然后 <code>artha</code> 启动 <code>tcp</code> 监听,接受各种命令，根据命令对相应的类做修改（本质就是 <code>aop</code> ）。</p>
<h2 id="至于有什么功能，就看代理的实现了，Instrumentation-的-api-完全可以做到修改线程代码逻辑，运行时的数据。不过大部分这类代理通常只做局部修改查询，不修改数据，防止对线上应用造成严重影响。"><a href="#至于有什么功能，就看代理的实现了，Instrumentation-的-api-完全可以做到修改线程代码逻辑，运行时的数据。不过大部分这类代理通常只做局部修改查询，不修改数据，防止对线上应用造成严重影响。" class="headerlink" title="至于有什么功能，就看代理的实现了，Instrumentation 的 api 完全可以做到修改线程代码逻辑，运行时的数据。不过大部分这类代理通常只做局部修改查询，不修改数据，防止对线上应用造成严重影响。"></a>至于有什么功能，就看代理的实现了，<code>Instrumentation</code> 的 <code>api</code> 完全可以做到修改线程代码逻辑，运行时的数据。不过大部分这类代理通常只做局部修改查询，不修改数据，防止对线上应用造成严重影响。</h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>参见官方文档<br>不过文档推荐是访问各类镜像网站，下载，针对不能访问这些网站的时候，直接全量下载就可以了<br><a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&amp;g=com.taobao.arthas&amp;a=arthas-packaging&amp;e=zip&amp;c=bin&amp;v=LATEST" target="_blank" rel="noopener">下载地址</a><br>解压到应用服务器上面，<code>as.sh</code> 设置可执行权限</p>
<h2 id="执行-as-sh-选择-jvm-进程，就可以了。"><a href="#执行-as-sh-选择-jvm-进程，就可以了。" class="headerlink" title="执行 ./as.sh ,选择 jvm 进程，就可以了。"></a>执行 <code>./as.sh</code> ,选择 <code>jvm</code> 进程，就可以了。</h2><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h2 id="artha-功能和命令挺多的，但是常用的就是几个，这里简单介绍一下，如果需要用其他命令，可以去看官方文档"><a href="#artha-功能和命令挺多的，但是常用的就是几个，这里简单介绍一下，如果需要用其他命令，可以去看官方文档" class="headerlink" title="artha 功能和命令挺多的，但是常用的就是几个，这里简单介绍一下，如果需要用其他命令，可以去看官方文档"></a><code>artha</code> 功能和命令挺多的，但是常用的就是几个，这里简单介绍一下，如果需要用其他命令，可以去看官方文档</h2><h3 id="ognl"><a href="#ognl" class="headerlink" title="ognl"></a>ognl</h3><p>执行 <code>ognl</code> 表达式<br>格式为 <code>ognl &#39;表达式&#39; 对象展开层次</code><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用静态函数：</span></span><br><span class="line">$ ognl <span class="string">'@java.lang.System@out.println("hello")'</span></span><br><span class="line">null</span><br><span class="line"><span class="comment"># 获取静态类的静态字段：</span></span><br><span class="line">$ ognl <span class="string">'@demo.MathGame@random'</span></span><br><span class="line">@Random[</span><br><span class="line">  serialVersionUID=@Long[3905348978240129619],</span><br><span class="line">  seed=@AtomicLong[125451474443703],</span><br><span class="line">  multiplier=@Long[25214903917],</span><br><span class="line">  addend=@Long[11],</span><br><span class="line">  mask=@Long[281474976710655],</span><br><span class="line">  DOUBLE_UNIT=@Double[1.1102230246251565E-16],</span><br><span class="line">  BadBound=@String[bound must be positive],</span><br><span class="line">  BadRange=@String[bound must be greater than origin],</span><br><span class="line">  BadSize=@String[size must be non-negative],</span><br><span class="line">  seedUniquifier=@AtomicLong[-3282039941672302964],</span><br><span class="line">  nextNextGaussian=@Double[0.0],</span><br><span class="line">  haveNextNextGaussian=@Boolean[<span class="literal">false</span>],</span><br><span class="line">  serialPersistentFields=@ObjectStreamField[][isEmpty=<span class="literal">false</span>;size=3],</span><br><span class="line">  unsafe=@Unsafe[sun.misc.Unsafe@28ea5898],</span><br><span class="line">  seedOffset=@Long[24],</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 执行多行表达式，赋值给临时变量，返回一个List：</span></span><br><span class="line">$ ognl <span class="string">'#value1=@System@getProperty("java.home"), #value2=@System@getProperty("java.runtime.name"), &#123;#value1, #value2&#125;'</span></span><br><span class="line">@ArrayList[</span><br><span class="line">  @String[/opt/java/8.0.181-zulu/jre],</span><br><span class="line">  @String[OpenJDK Runtime Environment],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<ul>
<li><a href="https://github.com/alibaba/arthas/issues/71" target="_blank" rel="noopener">OGNL特殊用法请参考</a></li>
<li><a href="https://commons.apache.org/proper/commons-ognl/language-guide.html" target="_blank" rel="noopener">OGNL表达式官方指南</a></li>
</ul>
<hr>
<h3 id="getstatic"><a href="#getstatic" class="headerlink" title="getstatic"></a>getstatic</h3><p>下面的内容都是官方文档里面的。<br>通过 <code>getstatic</code> 命令可以方便的查看类的静态属性。使用方法为 <code>getstatic class_name field_name</code><br>简单用法<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ getstatic demo.MathGame random</span><br><span class="line">field: random</span><br><span class="line">@Random[</span><br><span class="line">  serialVersionUID=@Long[3905348978240129619],</span><br><span class="line">  seed=@AtomicLong[120955813885284],</span><br><span class="line">  multiplier=@Long[25214903917],</span><br><span class="line">  addend=@Long[11],</span><br><span class="line">  mask=@Long[281474976710655],</span><br><span class="line">  DOUBLE_UNIT=@Double[1.1102230246251565E-16],</span><br><span class="line">  BadBound=@String[bound must be positive],</span><br><span class="line">  BadRange=@String[bound must be greater than origin],</span><br><span class="line">  BadSize=@String[size must be non-negative],</span><br><span class="line">  seedUniquifier=@AtomicLong[-3282039941672302964],</span><br><span class="line">  nextNextGaussian=@Double[0.0],</span><br><span class="line">  haveNextNextGaussian=@Boolean[<span class="literal">false</span>],</span><br><span class="line">  serialPersistentFields=@ObjectStreamField[][isEmpty=<span class="literal">false</span>;size=3],</span><br><span class="line">  unsafe=@Unsafe[sun.misc.Unsafe@2eaa1027],</span><br><span class="line">  seedOffset=@Long[24],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br>如果是复杂对象，可以使用 <code>ognl</code> 语法<br>例如，假设n是一个Map，Map的Key是一个Enum，我们想过滤出Map中Key为某个Enum的值，可以写如下命令</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ getstatic com.alibaba.arthas.Test n <span class="string">'entrySet().iterator.&#123;? #this.key.name()=="STOP"&#125;'</span></span><br><span class="line">field: n</span><br><span class="line">@ArrayList[</span><br><span class="line">  @Node[STOP=bbb],</span><br><span class="line">]</span><br><span class="line">Affect(row-cnt:1) cost <span class="keyword">in</span> 68 ms.</span><br><span class="line">$ getstatic com.alibaba.arthas.Test m <span class="string">'entrySet().iterator.&#123;? #this.key=="a"&#125;'</span></span><br><span class="line">field: m</span><br><span class="line">@ArrayList[</span><br><span class="line">  @Node[a=aaa],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></h2><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>方法执行数据观测<br>让你能方便的观察到指定方法的调用情况。能观察到的范围为：返回值、抛出异常、入参，通过编写 <code>OGNL</code> 表达式进行对应变量的查看。<br>格式为 <code>watch class-pattern method-pattern express condition-express [-x] x -[b|e|s|f|E] [-n] n</code></p>
<ul>
<li>-x x 代表输出结果的遍历深度，默认是1，就是说如果返回对象层次很深，大部分时候是展示 <code>hashcode</code> ,设置了 这个参数，就可以展示内部信息了</li>
<li>-b 在方法调用之前观察，这个就不会有异常和返回值了</li>
<li>-e 在方法异常之后观察</li>
<li>-s 在方法返回之后观察</li>
<li>-f 在方法结束之后(正常返回和异常返回)观察,这个是默认的，不到任何观察点，那就是这个了</li>
<li>-E 开启正则表达式匹配，默认为通配符匹配</li>
<li>-n n 代表输出次数，默认是一直输出，如果观察的对象调用过于频繁，会刷屏，控制输出次数<br>其中 <code>express</code> 和 <code>condition-express</code> 可以使用 <code>ognl</code> 表达式<br>通常匹配尽量少的类和方法，减少命令影响的类的数量，最好直接定位<br>官方示例：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 观察方法出参和返回值</span></span><br><span class="line">$ watch demo.MathGame primeFactors <span class="string">"&#123;params,returnObj&#125;"</span> -x 2</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 44 ms.</span><br><span class="line">ts=2018-12-03 19:16:51; [cost=1.280502ms] result=@ArrayList[</span><br><span class="line">@Object[][</span><br><span class="line">  @Integer[535629513],</span><br><span class="line">],</span><br><span class="line">@ArrayList[</span><br><span class="line">  @Integer[3],</span><br><span class="line">  @Integer[19],</span><br><span class="line">  @Integer[191],</span><br><span class="line">  @Integer[49199],</span><br><span class="line">],</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 观察方法入参</span></span><br><span class="line">$ watch demo.MathGame primeFactors <span class="string">"&#123;params,returnObj&#125;"</span> -x 2 -b</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 50 ms.</span><br><span class="line">ts=2018-12-03 19:23:23; [cost=0.0353ms] result=@ArrayList[</span><br><span class="line">@Object[][</span><br><span class="line">  @Integer[-1077465243],</span><br><span class="line">],</span><br><span class="line">null,</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 对比前一个例子，返回值为空（事件点为方法执行前，因此获取不到返回值）</span></span><br><span class="line"><span class="comment"># 同时观察方法调用前和方法返回后</span></span><br><span class="line">$ watch demo.MathGame primeFactors <span class="string">"&#123;params,target,returnObj&#125;"</span> -x 2 -b -s -n 2</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 46 ms.</span><br><span class="line">ts=2018-12-03 19:29:54; [cost=0.01696ms] result=@ArrayList[</span><br><span class="line">@Object[][</span><br><span class="line">  @Integer[1544665400],</span><br><span class="line">],</span><br><span class="line">@MathGame[</span><br><span class="line">  random=@Random[java.util.Random@522b408a],</span><br><span class="line">  illegalArgumentCount=@Integer[13038],</span><br><span class="line">],</span><br><span class="line">null,</span><br><span class="line">]</span><br><span class="line">ts=2018-12-03 19:29:54; [cost=4.277392ms] result=@ArrayList[</span><br><span class="line">@Object[][</span><br><span class="line">  @Integer[1544665400],</span><br><span class="line">],</span><br><span class="line">@MathGame[</span><br><span class="line">random=@Random[java.util.Random@522b408a],</span><br><span class="line">illegalArgumentCount=@Integer[13038],</span><br><span class="line">],</span><br><span class="line">@ArrayList[</span><br><span class="line">  @Integer[2],</span><br><span class="line">  @Integer[2],</span><br><span class="line">  @Integer[2],</span><br><span class="line">  @Integer[5],</span><br><span class="line">  @Integer[5],</span><br><span class="line">  @Integer[73],</span><br><span class="line">  @Integer[241],</span><br><span class="line">  @Integer[439],</span><br><span class="line">],</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 参数里-n 2，表示只执行两次</span></span><br><span class="line"><span class="comment"># 这里输出结果中，第一次输出的是方法调用前的观察表达式的结果，第二次输出的是方法返回后的表达式的结果</span></span><br><span class="line"><span class="comment"># 结果的顺序和命令中 -s -b 的顺序没有关系，只与事件本身的先后顺序有关</span></span><br><span class="line"><span class="comment"># 调整-x的值，观察具体的方法参数值</span></span><br><span class="line">$ watch demo.MathGame primeFactors <span class="string">"&#123;params,target&#125;"</span> -x 3</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 58 ms.</span><br><span class="line">ts=2018-12-03 19:34:19; [cost=0.587833ms] result=@ArrayList[</span><br><span class="line">@Object[][</span><br><span class="line">  @Integer[47816758],</span><br><span class="line">],</span><br><span class="line">@MathGame[</span><br><span class="line">  random=@Random[</span><br><span class="line">  serialVersionUID=@Long[3905348978240129619],</span><br><span class="line">  seed=@AtomicLong[3133719055989],</span><br><span class="line">  multiplier=@Long[25214903917],</span><br><span class="line">  addend=@Long[11],</span><br><span class="line">  mask=@Long[281474976710655],</span><br><span class="line">  DOUBLE_UNIT=@Double[1.1102230246251565E-16],</span><br><span class="line">  BadBound=@String[bound must be positive],</span><br><span class="line">  BadRange=@String[bound must be greater than origin],</span><br><span class="line">  BadSize=@String[size must be non-negative],</span><br><span class="line">  seedUniquifier=@AtomicLong[-3282039941672302964],</span><br><span class="line">  nextNextGaussian=@Double[0.0],</span><br><span class="line">  haveNextNextGaussian=@Boolean[<span class="literal">false</span>],</span><br><span class="line">  serialPersistentFields=@ObjectStreamField[][isEmpty=<span class="literal">false</span>;size=3],</span><br><span class="line">  unsafe=@Unsafe[sun.misc.Unsafe@2eaa1027],</span><br><span class="line">  seedOffset=@Long[24],</span><br><span class="line">],</span><br><span class="line">illegalArgumentCount=@Integer[13159],</span><br><span class="line">],</span><br><span class="line">]</span><br><span class="line"><span class="comment"># -x表示遍历深度，可以调整来打印具体的参数和结果内容，默认值是1</span></span><br><span class="line"><span class="comment"># 条件表达式的例子</span></span><br><span class="line">$ watch demo.MathGame primeFactors <span class="string">"&#123;params[0],target&#125;"</span> <span class="string">"params[0]&lt;0"</span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 68 ms.</span><br><span class="line">ts=2018-12-03 19:36:04; [cost=0.530255ms] result=@ArrayList[</span><br><span class="line">  @Integer[-18178089],</span><br><span class="line">  @MathGame[demo.MathGame@41cf53f9],</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 只有满足条件的调用，才会有响应。</span></span><br><span class="line"><span class="comment"># 观察异常信息的例子</span></span><br><span class="line">$ watch demo.MathGame primeFactors <span class="string">"&#123;params[0],throwExp&#125;"</span> -e -x 2</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 62 ms.</span><br><span class="line">ts=2018-12-03 19:38:00; [cost=1.414993ms] result=@ArrayList[</span><br><span class="line">@Integer[-1120397038],</span><br><span class="line">java.lang.IllegalArgumentException: number is: -1120397038, need &gt;= 2</span><br><span class="line">at demo.MathGame.primeFactors(MathGame.java:46)</span><br><span class="line">at demo.MathGame.run(MathGame.java:24)</span><br><span class="line">at demo.MathGame.main(MathGame.java:16)</span><br><span class="line">,</span><br><span class="line">]</span><br><span class="line"><span class="comment"># -e表示抛出异常时才触发</span></span><br><span class="line"><span class="comment"># express中，表示异常信息的变量是throwExp</span></span><br><span class="line"><span class="comment"># 按照耗时进行过滤</span></span><br><span class="line">$ watch demo.MathGame primeFactors <span class="string">'&#123;params, returnObj&#125;'</span> <span class="string">'#cost&gt;200'</span> -x 2</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 66 ms.</span><br><span class="line">ts=2018-12-03 19:40:28; [cost=2112.168897ms] result=@ArrayList[</span><br><span class="line">@Object[][</span><br><span class="line">  @Integer[2141897465],</span><br><span class="line">],</span><br><span class="line">@ArrayList[</span><br><span class="line">  @Integer[5],</span><br><span class="line">  @Integer[428379493],</span><br><span class="line">],</span><br><span class="line">]</span><br><span class="line"><span class="comment">#cost&gt;200(单位是ms)表示只有当耗时大于200ms时才会输出，过滤掉执行时间小于200ms的调用</span></span><br><span class="line"><span class="comment"># 观察当前对象中的属性</span></span><br><span class="line">$ watch demo.MathGame primeFactors <span class="string">'target'</span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 52 ms.</span><br><span class="line">ts=2018-12-03 19:41:52; [cost=0.477882ms] result=@MathGame[</span><br><span class="line">  random=@Random[java.util.Random@522b408a],</span><br><span class="line">  illegalArgumentCount=@Integer[13355],</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 然后使用 `target.field_name` 访问当前对象的某个属性</span></span><br><span class="line">$ watch demo.MathGame primeFactors <span class="string">'target.illegalArgumentCount'</span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 67 ms.</span><br><span class="line">ts=2018-12-03 20:04:34; [cost=131.303498ms] result=@Integer[8]</span><br><span class="line">ts=2018-12-03 20:04:35; [cost=0.961441ms] result=@Integer[8]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><p>方法执行监控<br>用来统计一段时间内方法的调用情况(耗时，是否成功)<br>格式为 <code>monitor class-pattern method-pattern [-E] [-c] c</code></p>
<ul>
<li>-E 开启正则表达式匹配，默认为通配符匹配</li>
<li>-c c 统计周期，默认值为120秒,就是多长时间统计输出一次<br>统计表格的内容有：<br>| 监控项 | 说明 |<br>| —- | —— |<br>| timestamp | 时间戳 |<br>| class | Java类 |<br>| method | 方法（构造方法、普通方法） |<br>| total | 调用次数 |<br>| success | 成功次数 |<br>| fail | 失败次数 |<br>| rt | 平均RT |<br>| fail-rate | 失败率 |<br>示例:<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ monitor -c 5 demo.MathGame primeFactors</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 94 ms.</span><br><span class="line">timestamp class method total success fail avg-rt(ms) fail-rate</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line">2018-12-03 19:06:38 demo.MathGame primeFactors 5 1 4 1.15 80.00%</span><br><span class="line">timestamp class method total success fail avg-rt(ms) fail-rate</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line">2018-12-03 19:06:43 demo.MathGame primeFactors 5 3 2 42.29 40.00%</span><br><span class="line">timestamp class method total success fail avg-rt(ms) fail-rate</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line">2018-12-03 19:06:48 demo.MathGame primeFactors 5 3 2 67.92 40.00%</span><br><span class="line">timestamp class method total success fail avg-rt(ms) fail-rate</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line">2018-12-03 19:06:53 demo.MathGame primeFactors 5 2 3 0.25 60.00%</span><br><span class="line">timestamp class method total success fail avg-rt(ms) fail-rate</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line">2018-12-03 19:06:58 demo.MathGame primeFactors 1 1 0 0.45 0.00%</span><br><span class="line">timestamp class method total success fail avg-rt(ms) fail-rate</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line">2018-12-03 19:07:03 demo.MathGame primeFactors 2 2 0 3182.72 0.00%</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><p>方法内部调用路径，并输出方法路径上的每个节点上耗时<br><code>trace</code> 能方便的帮助你定位和发现因 RT 高而导致的性能问题缺陷，但其每次只能跟踪一级方法的调用链路。<br>场景就是当一个方法很耗时的时候，通过 <code>trace</code> 命令，查看这个方法内部其他方法调用的耗时，看到底是哪个方法耗时严重<br>格式为 <code>trace class-pattern method-pattern condition-express [-E] [-n] n [-j]</code></p>
<ul>
<li>-E 开启正则表达式匹配，默认为通配符匹配</li>
<li>-n n 命令执行次数,也就是输出次数</li>
<li>-j 过滤掉 <code>jdk</code> 的方法<br>如果内部方法有多次调用，会一起统计<br>统计的时候没有减去自身的开销，统计结果不太精确<br>示例:<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># trace函数</span></span><br><span class="line">$ trace demo.MathGame run</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 42 ms.</span><br><span class="line">`---ts=2018-12-04 00:44:17;thread_name=main;id=1;is_daemon=<span class="literal">false</span>;priority=5;TCCL=sun.misc.Launcher<span class="variable">$AppClassLoader</span>@3d4eac69</span><br><span class="line">`---[10.611029ms] demo.MathGame:run()</span><br><span class="line">+---[0.05638ms] java.util.Random:nextInt()</span><br><span class="line">+---[10.036885ms] demo.MathGame:primeFactors()</span><br><span class="line">`---[0.170316ms] demo.MathGame:<span class="built_in">print</span>()</span><br><span class="line"><span class="comment"># 过滤掉jdk的函数</span></span><br><span class="line">$ trace -j demo.MathGame run</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 31 ms.</span><br><span class="line">`---ts=2018-12-04 01:09:14;thread_name=main;id=1;is_daemon=<span class="literal">false</span>;priority=5;TCCL=sun.misc.Launcher<span class="variable">$AppClassLoader</span>@3d4eac69</span><br><span class="line">`---[5.190646ms] demo.MathGame:run()</span><br><span class="line">+---[4.465779ms] demo.MathGame:primeFactors()</span><br><span class="line">`---[0.375324ms] demo.MathGame:<span class="built_in">print</span>()</span><br><span class="line"><span class="comment"># 据调用耗时过滤</span></span><br><span class="line">$ trace demo.MathGame run <span class="string">'#cost &gt; 10'</span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 41 ms.</span><br><span class="line">`---ts=2018-12-04 01:12:02;thread_name=main;id=1;is_daemon=<span class="literal">false</span>;priority=5;TCCL=sun.misc.Launcher<span class="variable">$AppClassLoader</span>@3d4eac69</span><br><span class="line">`---[12.033735ms] demo.MathGame:run()</span><br><span class="line">+---[0.006783ms] java.util.Random:nextInt()</span><br><span class="line">+---[11.852594ms] demo.MathGame:primeFactors()</span><br><span class="line">`---[0.05447ms] demo.MathGame:<span class="built_in">print</span>()</span><br><span class="line"><span class="comment"># 只会展示耗时大于 10ms 的调用路径，有助于在排查问题的时候，只关注异常情况</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="tt"><a href="#tt" class="headerlink" title="tt"></a>tt</h3><p>方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测<br>举个例子，有一个 <code>hello(String name)</code> 方法，很多人都需要调用，但是每个人的参数都不一样，我只关心我自己的调用<br>虽然 <code>watch</code> 命令可以看到参数，但是需要提前想好过滤条件，也没法重试<br><code>tt</code> 的作用就是记录指定次数的方法调用，记录下来，后面可以查看这些记录，重试调用等<br><strong>记录调用</strong><br>格式 <code>tt -t class-pattern method-pattern [-n] n</code></p>
<ul>
<li>-n n 记录命令执行次数<br>展示:<br>| 表格字段 | 字段解释 |<br>| —- | —— |<br>| INDEX | 时间片段记录编号，每一个编号代表着一次调用，后续tt还有很多命令都是基于此编号指定记录操作，非常重要。 |<br>| TIMESTAMP | 方法执行的本机时间，记录了这个时间片段所发生的本机时间 |<br>| COST(ms) | 方法执行的耗时 |<br>| IS-RET | 方法是否以正常返回的形式结束 |<br>| IS-EXP | 方法是否以抛异常的形式结束 |<br>| OBJECT | 执行对象的hashCode()，注意，曾经有人误认为是对象在JVM中的内存地址，但很遗憾他不是。但他能帮助你简单的标记当前执行方法的类实体 |<br>| CLASS | 执行的类名 |<br>| METHOD | 执行的方法名 |<br>示例：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ tt -t demo.MathGame primeFactors</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 66 ms.</span><br><span class="line">INDEX TIMESTAMP COST(ms) IS-RET IS-EXP OBJECT CLASS METHOD</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">1000 2018-12-04 11:15:38 1.096236 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1001 2018-12-04 11:15:39 0.191848 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1002 2018-12-04 11:15:40 0.069523 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1003 2018-12-04 11:15:41 0.186073 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1004 2018-12-04 11:15:42 17.76437 <span class="literal">true</span> <span class="literal">false</span> 0x4b67cf4d MathGame primeFactors</span><br></pre></td></tr></table></figure>
<strong>检索调用记录</strong><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有记录</span></span><br><span class="line">$ tt -l</span><br><span class="line">INDEX TIMESTAMP COST(ms) IS-RET IS-EXP OBJECT CLASS METHOD</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">1000 2018-12-04 11:15:38 1.096236 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1001 2018-12-04 11:15:39 0.191848 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1002 2018-12-04 11:15:40 0.069523 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1003 2018-12-04 11:15:41 0.186073 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1004 2018-12-04 11:15:42 17.76437 <span class="literal">true</span> <span class="literal">false</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">9</span><br><span class="line">1005 2018-12-04 11:15:43 0.4776 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">Affect(row-cnt:6) cost <span class="keyword">in</span> 4 ms.</span><br><span class="line"><span class="comment"># 筛选</span></span><br><span class="line">$ tt -s <span class="string">'method.name=="primeFactors"'</span></span><br><span class="line">INDEX TIMESTAMP COST(ms) IS-RET IS-EXP OBJECT CLASS METHOD</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">1000 2018-12-04 11:15:38 1.096236 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1001 2018-12-04 11:15:39 0.191848 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1002 2018-12-04 11:15:40 0.069523 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1003 2018-12-04 11:15:41 0.186073 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1004 2018-12-04 11:15:42 17.76437 <span class="literal">true</span> <span class="literal">false</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">9</span><br><span class="line">1005 2018-12-04 11:15:43 0.4776 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">Affect(row-cnt:6) cost <span class="keyword">in</span> 607 ms.</span><br></pre></td></tr></table></figure>
<strong>查看调用信息</strong><br><code>-i</code> 指定 <code>INDEX</code><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ tt -i 1003</span><br><span class="line">INDEX 1003</span><br><span class="line">GMT-CREATE 2018-12-04 11:15:41</span><br><span class="line">COST(ms) 0.186073</span><br><span class="line">OBJECT 0x4b67cf4d</span><br><span class="line">CLASS demo.MathGame</span><br><span class="line">METHOD primeFactors</span><br><span class="line">IS-RETURN <span class="literal">false</span></span><br><span class="line">IS-EXCEPTION <span class="literal">true</span></span><br><span class="line">PARAMETERS[0] @Integer[-564322413]</span><br><span class="line">THROW-EXCEPTION java.lang.IllegalArgumentException: number is: -564322413, need &gt;= 2</span><br><span class="line">at demo.MathGame.primeFactors(MathGame.java:46)</span><br><span class="line">at demo.MathGame.run(MathGame.java:24)</span><br><span class="line">at demo.MathGame.main(MathGame.java:16)</span><br><span class="line">Affect(row-cnt:1) cost <span class="keyword">in</span> 11 ms.</span><br></pre></td></tr></table></figure>
<strong>重做一次调用</strong><br>当你稍稍做了一些调整之后，你可能需要前端系统重新触发一次你的调用，此时得求爷爷告奶奶的需要前端配合联调的同学再次发起一次调用。而有些场景下，这个调用不是这么好触发的。<br>tt 命令由于保存了当时调用的所有现场信息，所以我们可以自己主动对一个 INDEX 编号的时间片自主发起一次调用，从而解放你的沟通成本。此时你需要 -p 参数。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ tt -i 1004 -p</span><br><span class="line">RE-INDEX 1004</span><br><span class="line">GMT-REPLAY 2018-12-04 11:26:00</span><br><span class="line">OBJECT 0x4b67cf4d</span><br><span class="line">CLASS demo.MathGame</span><br><span class="line">METHOD primeFactors</span><br><span class="line">PARAMETERS[0] @Integer[946738738]</span><br><span class="line">IS-RETURN <span class="literal">true</span></span><br><span class="line">IS-EXCEPTION <span class="literal">false</span></span><br><span class="line">RETURN-OBJ @ArrayList[</span><br><span class="line">@Integer[2],</span><br><span class="line">@Integer[11],</span><br><span class="line">@Integer[17],</span><br><span class="line">@Integer[2531387],</span><br><span class="line">]</span><br><span class="line">Time fragment[1004] successfully replayed.</span><br><span class="line">Affect(row-cnt:1) cost <span class="keyword">in</span> 14 ms.</span><br></pre></td></tr></table></figure>
重做一次调用需要注意的地方：</li>
</ul>
<ol>
<li><code>ThreadLocal</code> 信息丢失<br>很多框架偷偷的将一些环境变量信息塞到了发起调用线程的 <code>ThreadLocal</code> 中，由于调用线程发生了变化，这些 <code>ThreadLocal</code> 线程信息无法通过 <code>Arthas</code> 保存，所以这些信息将会丢失。<br>一些常见的例子 比如：鹰眼的 <code>TraceId</code> 等。</li>
<li>引用的对象<br>需要强调的是，<code>tt</code> 命令是将当前环境的对象引用保存起来，但仅仅也只能保存一个引用而已。如果方法内部对入参进行了变更，或者返回的对象经过了后续的处理，那么在 <code>tt</code> 查看的时候将无法看到当时最准确的值。这也是为什么 <code>watch</code> 命令存在的意义。</li>
</ol>
<hr>
<h2 id="其他可能用到的功能"><a href="#其他可能用到的功能" class="headerlink" title="其他可能用到的功能"></a>其他可能用到的功能</h2><p>详细的可以看官方文档</p>
<h3 id="后台任务"><a href="#后台任务" class="headerlink" title="后台任务"></a>后台任务</h3><ol>
<li>使用&amp;在后台执行任务<br>比如希望执行后台执行trace命令，那么调用下面命令<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace Test t &amp;</span><br></pre></td></tr></table></figure>
这时命令在后台执行，可以在console中继续执行其他命令。</li>
<li>通过 <code>jobs</code> 查看任务<br>如果希望查看当前有哪些 <code>arthas</code> 任务在执行，可以执行 <code>jobs</code> 命令，执行结果如下<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">[10]*</span><br><span class="line">Stopped watch com.taobao.container.Test <span class="built_in">test</span> <span class="string">"params[0].&#123;? #this.name == null &#125;"</span> -x 2</span><br><span class="line">execution count : 19</span><br><span class="line">start time : Fri Sep 22 09:59:55 CST 2017</span><br><span class="line">timeout date : Sat Sep 23 09:59:55 CST 2017</span><br><span class="line">session : 3648e874-5e69-473f-9eed-7f89660b079b (current)</span><br></pre></td></tr></table></figure>
可以看到目前有一个后台任务在执行。</li>
</ol>
<ul>
<li>job id是10, <code>*</code> 表示此job是当前session创建</li>
<li>状态是Stopped</li>
<li>execution count是执行次数，从启动开始已经执行了19次</li>
<li>timeout date是超时的时间，到这个时间，任务将会自动超时退出</li>
</ul>
<ol>
<li>任务暂停和取消<br>当任务正在前台执行，比如直接调用命令<code>trace Test t</code>或者调用后台执行命令<code>trace Test t &amp;</code>后又通过<code>fg</code>命令将任务转到前台。这时<code>console</code>中无法继续执行命令，但是可以接收并处理以下事件：</li>
</ol>
<ul>
<li><code>‘ctrl + z’</code>：将任务暂停。通过<code>jbos</code>查看任务状态将会变为Stopped，通过<code>bg</code> 或者<code>fg</code> 可让任务重新开始执行</li>
<li><code>‘ctrl + c’</code>：停止任务</li>
<li><code>‘ctrl + d’</code>：按照<code>linux</code>语义应当是退出终端，目前<code>arthas</code>中是空实现，不处理</li>
</ul>
<ol>
<li>fg、bg命令，将命令转到前台、后台继续执行</li>
</ol>
<ul>
<li>任务在后台执行或者暂停状态（<code>ctrl + z</code>暂停任务）时，执行<code>fg</code> 将可以把对应的任务转到前台继续执行。在前台执行时，无法在console中执行其他命令</li>
<li>当任务处于暂停状态时（<code>ctrl + z</code>暂停任务），执行<code>bg</code> 将可以把对应的任务在后台继续执行</li>
<li>非当前session创建的job，只能由当前session <code>fg</code>到前台执行</li>
</ul>
<ol>
<li>任务输出重定向<br>可通过<code>&gt;</code>或者<code>&gt;&gt;</code>将任务输出结果输出到指定的文件中，可以和&amp;一起使用，实现<code>arthas</code>命令的异步调用。比如：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ trace Test t &gt;&gt; test.out &amp;</span><br></pre></td></tr></table></figure>
这时<code>trace</code>命令会在后台执行，并且把结果输出到<code>~/logs/arthas-cache/test.out</code>。可继续执行其他命令。并可查看文件中的命令执行结果。<br>当连接到远程的<code>arthas server</code>时，可能无法查看远程机器的文件，<code>arthas</code>同时支持了自动重定向到本地缓存路径。使用方法如下：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ trace Test t &gt;&gt; &amp;</span><br><span class="line">job id : 2</span><br><span class="line">cache location : /Users/gehui/logs/arthas-cache/28198/2</span><br></pre></td></tr></table></figure>
可以看到并没有指定重定向文件位置，<code>arthas</code>自动重定向到缓存中了，执行命令后会输出job id和cache location。cache location就是重定向文件的路径，在系统logs目录下，路径包括pid和job id，避免和其他任务冲突。命令输出结果到<code>/Users/gehui/logs/arthas-cache/28198/2</code>中，job id为2。</li>
<li>停止命令<br>异步执行的命令，如果希望停止，可执行kill <job-id></li>
<li>其他<br>最多同时支持8个命令使用重定向将结果写日志<br>请勿同时开启过多的后台异步命令，以免对目标JVM性能造成影响</li>
</ol>
<hr>
<h3 id="结果存日志"><a href="#结果存日志" class="headerlink" title="结果存日志"></a>结果存日志</h3><p>将命令的结果完整保存在日志文件中，便于后续进行分析<br>默认情况下，该功能是关闭的，如果需要开启，请执行以下命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ options save-result <span class="literal">true</span></span><br><span class="line">NAME BEFORE-VALUE AFTER-VALUE</span><br><span class="line">----------------------------------------</span><br><span class="line">save-result <span class="literal">false</span> <span class="literal">true</span></span><br><span class="line">Affect(row-cnt:1) cost <span class="keyword">in</span> 3 ms.</span><br></pre></td></tr></table></figure><br>看到上面的输出，即表示成功开启该功能；<br>结果会异步保存在：<code>{user.home}/logs/arthas-cache/result.log</code>，请定期进行清理，以免占据磁盘空间<br><strong>使用新版本Arthas的异步后台任务将结果存日志文件</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ trace Test t &gt;&gt; &amp;</span><br><span class="line">job id : 2</span><br><span class="line">cache location : /Users/admin/logs/arthas-cache/28198/2</span><br></pre></td></tr></table></figure><br>此时命令会在后台异步执行，并将结果异步保存在文件（<code>~/logs/arthas-cache/${PID}/${JobId}</code>）中；</p>
<ul>
<li>此时任务的执行不受session断开的影响；任务默认超时时间是1天，可以通过全局 <code>options</code> 命令修改默认超时时间；</li>
<li>此命令的结果将异步输出到文件中；此时不管 <code>save-result 是否为true，都不会再往</code>~/logs/arthas-cache/result.log` 中异步写结果</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/java-%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luo lei">
      <meta itemprop="description" content="主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Askluolei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/27/java-%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">java 泛型</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-27 00:51:45" itemprop="dateCreated datePublished" datetime="2019-07-27T00:51:45+08:00">2019-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-10 00:47:40" itemprop="dateModified" datetime="2019-11-10T00:47:40+08:00">2019-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">技术笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>用了这么久的 <code>spirng</code> ,以为对 <code>ioc</code> 的原理和实现机制已经非常了解了<br>但是，突然想到泛型的依赖注入是怎么实现的，这就很纠结了，因为普通的依赖注入，自己想一下，实现起来简单，但是涉及到泛型，实现就比较复杂了，需要对 <code>jdk</code> 的 <code>Type</code> 有了解<br>这里举几个例子，看看泛型依赖注入的效果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ID <span class="title">save</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        System.out.println(t.getClass().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDao</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">Book</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">User</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BaseEnhanceDao&lt;Book&gt; bookBaseDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BaseEnhanceDao&lt;User&gt; userBaseDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bookBaseDao.save(<span class="keyword">new</span> Book());</span><br><span class="line">        System.out.println(<span class="string">"-=-=-= 我是分割线 -=-=-="</span>);</span><br><span class="line">        userBaseDao.save(<span class="keyword">new</span> User());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个常用的，很简单的泛型注入，可以看到 <code>spring</code> 在 <code>MyService</code> 类的字段 <code>BaseEnhanceDao&lt;Book&gt;</code> 跟 <code>BookDao</code> 看做同一个类型，而跟 <code>UserDao</code> 不是同一个类型（如果是，依赖注入就会报错,多个满足条件的 <code>bean</code>,但是他们在原生类型上，是存在继承关系的）<br>如果要我们自己实现，如何判断这两个类型是同一个呢？<br>再扩展一点，上面的只是一个简单的继承体系，一个最终的实现类，他的泛型可能来自 <code>superClass</code> 或者 <code>interface</code> ，而且都可以向上延伸<br>举例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A1</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A2</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A3</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型顶层类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ab2</span>&lt;<span class="title">T</span>, <span class="title">F</span>, <span class="title">H</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AB3</span>&lt;<span class="title">T</span>, <span class="title">F</span>&gt; <span class="keyword">extends</span> <span class="title">Ab2</span>&lt;<span class="title">T</span>, <span class="title">F</span>, <span class="title">A1</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AB4</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AB3</span>&lt;<span class="title">T</span>, <span class="title">A2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AB5</span> <span class="keyword">extends</span> <span class="title">AB4</span>&lt;<span class="title">A3</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里例子，很明显的看到 <code>AB5</code> 有3个泛型类型都是通过继承来的, 如果 <code>AB5</code> 注册为 <code>bean</code>，他可以代表的类型是 <code>Ab2&lt;A3, A2, A1&gt;</code> , <code>AB3&lt;A3, A2&gt;</code> , <code>AB4&lt;A3&gt;</code> ,如果中间的泛型顺序不对，那么就不是同一个类型  </p>
<p>再来看个接口的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略 OBJ1,2,3,4</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">I1</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">I2</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">I1</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">OBJ4</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">I3</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">I2</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">OBJ3</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">I4</span>&lt;<span class="title">A</span>&gt; <span class="keyword">extends</span> <span class="title">I3</span>&lt;<span class="title">A</span>, <span class="title">OBJ2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">I5</span> <span class="keyword">extends</span> <span class="title">I4</span>&lt;<span class="title">OBJ1</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Impl1</span> <span class="keyword">implements</span> <span class="title">I5</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Impl2</span> <span class="keyword">extends</span> <span class="title">Impl1</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>无论是 <code>Impl1</code> 还是 <code>Impl2</code> 都应该是类型 <code>I1 I2 I3 I4 I5</code> 类型的（原生类型），如果考虑到泛型，那么泛型的具体类型，数量和顺序也是关键，可以自然的想到，当需要注入一个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> I1&lt;OBJ1, OBJ2, OBJ3, OBJ4&gt; i1;</span><br></pre></td></tr></table></figure></p>
<p>字段的时候， <code>Impl1</code> <code>Impl2</code> 都是满足条件的， <code>spring</code> 也能够处理<br>现在我们思考一下，如果要我们自己去实现这个功能，要怎么做呢？要同时满足接口和超类<br>测试的时候不需要考虑注入问题，只要能够判断 <code>Impl1</code> 是类型 <code>I1&lt;OBJ1, OBJ2, OBJ3, OBJ4&gt;</code>  而不是类型 <code>I1&lt;OBJ4, OBJ3, OBJ2, OBJ1&gt;</code> 就可以了  </p>
<p>所有，我们有这么一个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSameType</span><span class="params">(Type sourceType, Type toMatchedType)</span></span></span><br></pre></td></tr></table></figure></p>
<p>其中 <code>sourceType</code> 的具体例子就是 <code>I1&lt;OBJ1, OBJ2, OBJ3, OBJ4&gt;</code> , <code>toMatchedType</code> 的例子就是 <code>Impl1</code><br>返回是否为同一个类型<br>看到，参数给的是 <code>Type</code> 类型，而不是 <code>Class</code> 如果传原生的 <code>Class</code> 可能会丢到泛型信息，当通过 <code>field</code> 获取字段类型的时候，使用 <code>getGenericType()</code> 方法获取 <code>Type</code> 类型<br>为了实现这个功能，就需要对 <code>jdk</code> 的 <code>Type</code> 体系有点了解了，毕竟，我们通常使用的是 <code>Class</code> 而不是 <code>Type</code>， <code>getGenericType()</code> 返回的是什么呢？<br>JDK 里面的 Type 定义如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a string describing this type, including information</span></span><br><span class="line"><span class="comment">     * about any type parameters.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@implSpec</span> The default implementation calls &#123;<span class="doctag">@code</span> toString&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a string describing this type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getTypeName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以调用 <code>getTypeName()</code> 方法，来看里面包含什么泛型信息（这里只是调试看的）<br><code>Type</code> 跟 <code>Class</code> 是什么关系？继承关系，<code>Class</code> 也是一个 <code>Type</code><br><code>Type</code> 下面有几个比较重要的体系 <code>ParameterizedType</code>  <code>TypeVariable</code>  <code>Class</code>  这三个比较重要，另外还有 <code>GenericArrayType</code> 和 <code>WildcardType</code><br>其中 <code>GenericArrayType</code> 代表泛型数组，就是字段类型是 <code>T[] array</code> 这样的<br><code>WildcardType</code> 是通配符表达式 类似 <code>List&lt;? extends Number&gt; list</code> 这样的，可以看成是特殊的 TypeVariable<br>本次研究不看 <code>GenericArrayType</code> 和 <code>WildcardType</code>   </p>
<p>首先要明确的是，最终的实现类，一定要确认所有的泛型类型才能注册为 <code>bean</code>，所以，他的泛型信息肯定是在 <code>superClass</code> 或者 <code>interface(s)</code> 里面的<br>先说简单情况，只有继承关系，没有接口的干预<br>通常，我们获取父类调用 <code>Class</code> 的 <code>getSuperClass</code> 这个方法会丢掉泛型信息，我们需要换一个方法 <code>getGenericSuperclass</code> 这个方法返回一个 <code>Type</code><br>如果父类不是泛型类，没有泛型标签，那么返回的是 <code>Class</code> 类型（实际），否则返回的是 <code>ParameterizedType</code> 类型(实现类)<br>而 <code>ParameterizedType</code> 里面有几个重要方法 <code>getRawType</code> 返回原生类型，就跟 <code>getSuperClass</code> 返回一样, <code>getActualTypeArguments()</code> 返回泛型参数列表 <code>Type[]</code><br>这里的 <code>Type[]</code> 数组，里面具体是什么类型的呢？ 可能是 <code>Class</code> 可能是 <code>TypeVariable</code> 和 <code>WildcardType</code><br>如果是 <code>Class</code> 好说，就是这本层指定了具体的泛型类型，譬如 <code>public class AB4&lt;T&gt; extends AB3&lt;T, A2&gt;</code>  如果是 <code>AB4</code> 调用 <code>getActualTypeArguments</code> 那么泛型参数列表<br>就是 <code>&lt;T, A2, A1&gt;</code> 有3个泛型参数，其中后两个确定了，那么就是 <code>Class</code> 类型， <code>T</code> 代表没确定，就是 <code>TypeVariable</code> 暂时先不考虑限定符的问题，这里的 <code>T</code> 可能是子类指定的，所以很自然的想到 <code>Ab2&lt;A3, A2, A1&gt;</code> 跟 <code>AB5</code> 是不是同一个类型的时候，需要判断的是 <code>AB5</code> 原生类型是不是 <code>Ab2</code> 的子类，以及他们的泛型参数列表是不是相同的，其中 <code>Ab2</code> 的泛型参数列表好获取，重点在于 <code>AB5</code> 的，他的泛型参数是从不同的实现类指定了。   </p>
<p>如果实现了上面说的超类的，那么请再考虑一下 <code>interface</code> 的，想想也知道，更为复杂，因为接口允许多继承，各位可以自己想一想，不需要考虑限定符<br>下面给出参考实现(简单测试过没啥问题，不过不保证):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断两个类型是否为同一个类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceType 目标类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toMatchedType 待匹配类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSameType</span><span class="params">(Type sourceType, Type toMatchedType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为 null，就不是</span></span><br><span class="line">        <span class="keyword">if</span> (sourceType == <span class="keyword">null</span> || toMatchedType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; sourceClass = <span class="keyword">null</span>;</span><br><span class="line">        Class&lt;?&gt; toMatchedClass = <span class="keyword">null</span>;</span><br><span class="line">        ParameterizedType sourceParameterizedType = <span class="keyword">null</span>;</span><br><span class="line">        ParameterizedType toMatchedParameterizedType = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (Class<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">sourceType</span>)) </span>&#123;</span><br><span class="line">            sourceClass = (Class&lt;?&gt;) sourceType;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ParameterizedType<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">sourceType</span>))</span>&#123;</span><br><span class="line">            sourceParameterizedType = (ParameterizedType) sourceType;</span><br><span class="line">            sourceClass = (Class&lt;?&gt;) sourceParameterizedType.getRawType();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Class<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">toMatchedType</span>)) </span>&#123;</span><br><span class="line">            toMatchedClass = (Class&lt;?&gt;) toMatchedType;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ParameterizedType<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">toMatchedType</span>))</span>&#123;</span><br><span class="line">            toMatchedParameterizedType = (ParameterizedType) toMatchedType;</span><br><span class="line">            toMatchedClass = (Class&lt;?&gt;) toMatchedParameterizedType.getRawType();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sourceClass == <span class="keyword">null</span> | toMatchedClass == <span class="keyword">null</span> || !sourceClass.isAssignableFrom(toMatchedClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正常情况下，到这里，sourceType 应该就是泛型类型了，如果不是，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (sourceParameterizedType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里是待匹配的泛型类型</span></span><br><span class="line">        Type[] actualTypeArguments = sourceParameterizedType.getActualTypeArguments();</span><br><span class="line">        <span class="comment">// 现在的重点是拿 toMatched 的泛型类型，但是，这个类可能就是单纯的 class，他的泛型可能是从 superClass 和 interface 获取到的</span></span><br><span class="line">        <span class="comment">// 思路是，从 matchedType 向上（接口线，或者super线，或者 super + 接口线）到 sourceType 的 rawType 类型,并找到这条线上的泛型参数，对比 actualTypeArguments</span></span><br><span class="line"></span><br><span class="line">        List&lt;ParameterizedType&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Type parent = toMatchedClass;</span><br><span class="line">        Type result = searchVertical(sourceClass, parent, list);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            addResult(result, list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这样查询后，最顶层的类在前面</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (!list.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 第一个类或者接口就是 sourceClass</span></span><br><span class="line">            ParameterizedType parameterizedType = list.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 这里就待匹配的泛型了，但是里面可能是 T 这样的 TypeVariable ，具体的泛型在下面</span></span><br><span class="line">            Type[] matchedTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">            Type[] realMatched = <span class="keyword">new</span> Type[matchedTypeArguments.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matchedTypeArguments.length; i++) &#123;</span><br><span class="line">                Type type = matchedTypeArguments[i];</span><br><span class="line">                <span class="keyword">if</span> (TypeVariable<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">type</span>)) </span>&#123;</span><br><span class="line">                    TypeVariable&lt;?&gt; typeVariable = (TypeVariable&lt;?&gt;) type;</span><br><span class="line">                    <span class="comment">// 这里是泛型变量</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; list.size(); j++) &#123;</span><br><span class="line">                        ParameterizedType p2 = list.get(j);</span><br><span class="line">                        Class&lt;?&gt; rawType = (Class&lt;?&gt;) p2.getRawType();</span><br><span class="line">                        TypeVariable&lt;? extends Class&lt;?&gt;&gt;[] typeParameters = rawType.getTypeParameters();</span><br><span class="line">                        <span class="keyword">if</span> (typeParameters.length == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">boolean</span> find = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; typeParameters.length; k++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (typeParameters[k].getName().equals(typeVariable.getName())) &#123;</span><br><span class="line">                                Type t2 = p2.getActualTypeArguments()[k];</span><br><span class="line">                                <span class="keyword">if</span> (Class<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">t2</span>)) </span>&#123;</span><br><span class="line">                                    realMatched[i] = t2;</span><br><span class="line">                                    find = <span class="keyword">true</span>;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (find) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    realMatched[i] = type;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (actualTypeArguments.length != realMatched.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; actualTypeArguments.length; i++) &#123;</span><br><span class="line">                Class&lt;?&gt; actualType = (Class&lt;?&gt;) actualTypeArguments[i];</span><br><span class="line">                Class&lt;?&gt; toMatchType = (Class&lt;?&gt;) realMatched[i];</span><br><span class="line">                <span class="keyword">if</span> (!actualType.isAssignableFrom(toMatchType)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 垂直查询继承体系</span></span><br><span class="line"><span class="comment">     * 递归调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> current</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Type <span class="title">searchVertical</span><span class="params">(Class&lt;?&gt; sourceClass, Type current, List&lt;ParameterizedType&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Class<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">current</span>)) </span>&#123;</span><br><span class="line">            <span class="comment">// 如果是 class 代表没泛型</span></span><br><span class="line">            Class&lt;?&gt; currentClass = (Class&lt;?&gt;) current;</span><br><span class="line">            <span class="keyword">if</span> (currentClass == Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 代表搜寻到 Object 了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> searchClass(sourceClass, currentClass, current, list);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ParameterizedType<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">current</span>)) </span>&#123;</span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType) current;</span><br><span class="line">            Class&lt;?&gt; rawClass = (Class&lt;?&gt;) parameterizedType.getRawType();</span><br><span class="line">            <span class="keyword">if</span> (rawClass == sourceClass) &#123;</span><br><span class="line">                <span class="comment">// 代表搜寻完毕</span></span><br><span class="line">                <span class="keyword">return</span> parameterizedType;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> searchClass(sourceClass, rawClass, current, list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继续向上，搜索父类或者接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> searchClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> current</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Type <span class="title">searchClass</span><span class="params">(Class&lt;?&gt; sourceClass, Class&lt;?&gt; searchClass, Type current, List&lt;ParameterizedType&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Type type : searchClass.getGenericInterfaces()) &#123;</span><br><span class="line">            Type result = searchVertical(sourceClass, type, list);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                addResult(result, list);</span><br><span class="line">                <span class="keyword">return</span> type;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Type superclass = searchClass.getGenericSuperclass();</span><br><span class="line">        Type result = searchVertical(sourceClass, superclass, list);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            addResult(result, list);</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果是泛型，那么添加到列表里面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addResult</span><span class="params">(Type result, List&lt;ParameterizedType&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ParameterizedType<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">result</span>)) </span>&#123;</span><br><span class="line">            list.add((ParameterizedType) result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>给出测试代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 修改泛型列表的具体类型  </span></span><br><span class="line"><span class="keyword">private</span> Ab2&lt;A3, A2, A1&gt; ab;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Field field = getClass().getDeclaredField(<span class="string">"ab"</span>);</span><br><span class="line">    Type genericType = field.getGenericType();</span><br><span class="line"></span><br><span class="line">    AB5 ab5 = <span class="keyword">new</span> AB5();</span><br><span class="line">    System.out.println();</span><br><span class="line">    GenericTest test = <span class="keyword">new</span> GenericTest();</span><br><span class="line">    <span class="keyword">boolean</span> sameType = GenericUtil.isSameType(genericType, ab5.getClass());</span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">        System.out.println(<span class="string">"same type"</span>);</span><br><span class="line">        field.set(test, ab5);</span><br><span class="line">        System.out.println(<span class="string">"set field success"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"diff type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改泛型列表的具体类型  </span></span><br><span class="line"><span class="keyword">private</span> I1&lt;OBJ1, OBJ2, OBJ3, OBJ4&gt; i1;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Field field = getClass().getDeclaredField(<span class="string">"i1"</span>);</span><br><span class="line">    Type genericType = field.getGenericType();</span><br><span class="line"></span><br><span class="line">    Impl2 impl1 = <span class="keyword">new</span> Impl2();</span><br><span class="line"></span><br><span class="line">    GenericTest test = <span class="keyword">new</span> GenericTest();</span><br><span class="line">    <span class="keyword">boolean</span> sameType = GenericUtil.isSameType(genericType, impl1.getClass());</span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">        System.out.println(<span class="string">"same type"</span>);</span><br><span class="line">        field.set(test, impl1);</span><br><span class="line">        System.out.println(<span class="string">"set field success"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"diff type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Luo lei"
    src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Luo lei</p>
  <div class="site-description" itemprop="description">主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Luo lei</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  <script src="/js/local-search.js"></script>












    <div id="pjax">

  

  

  


    </div>
</body>
</html>
