<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>螺旋矩阵</title>
    <url>/2019/12/26/leetcode/54/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p>
<p>示例 1:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*输入:*</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line">输出: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><br><em>示例 2:</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1, 2, 3, 4],</span><br><span class="line">  [5, 6, 7, 8],</span><br><span class="line">  [9,10,11,12]</span><br><span class="line">]</span><br><span class="line">输出: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure></p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>由外到内，顺时针访问<br>尾递归，可以使用 for 循环代替</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spiralOrder</span><span class="params">(matrix [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 坑方法，递归调用</span></span><br><span class="line">	m := <span class="built_in">len</span>(matrix)</span><br><span class="line">	<span class="keyword">if</span> m == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	n := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">var</span> res []<span class="keyword">int</span></span><br><span class="line">	toR(matrix, &amp;res, <span class="number">0</span>, m, <span class="number">0</span>, n)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toR</span><span class="params">(matrix [][]<span class="keyword">int</span>, res *[]<span class="keyword">int</span>, xs, xe, ys, ye <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> xs &gt;= xe || ys &gt;= ye &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i:= ys;i&lt;ye;i++&#123;</span><br><span class="line">		*res=<span class="built_in">append</span>(*res, matrix[xs][i])</span><br><span class="line">	&#125;</span><br><span class="line">	xs++</span><br><span class="line">	toD(matrix, res, xs, xe, ys, ye)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toD</span><span class="params">(matrix [][]<span class="keyword">int</span>, res *[]<span class="keyword">int</span>, xs, xe, ys, ye <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> xs &gt;= xe || ys &gt;= ye &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i:=xs;i&lt;xe;i++&#123;</span><br><span class="line">		*res=<span class="built_in">append</span>(*res, matrix[i][ye<span class="number">-1</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	ye--</span><br><span class="line">	toL(matrix, res, xs, xe, ys, ye)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toL</span><span class="params">(matrix [][]<span class="keyword">int</span>, res *[]<span class="keyword">int</span>, xs, xe, ys, ye <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> xs &gt;= xe || ys &gt;= ye &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i:=ye<span class="number">-1</span>;i&gt;=ys;i-- &#123;</span><br><span class="line">		*res=<span class="built_in">append</span>(*res, matrix[xe<span class="number">-1</span>][i])</span><br><span class="line">	&#125;</span><br><span class="line">	xe--</span><br><span class="line">	toU(matrix, res, xs, xe, ys, ye)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toU</span><span class="params">(matrix [][]<span class="keyword">int</span>, res *[]<span class="keyword">int</span>, xs, xe, ys, ye <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> xs &gt;= xe || ys &gt;= ye &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i:=xe<span class="number">-1</span>;i&gt;=xs;i--&#123;</span><br><span class="line">		*res=<span class="built_in">append</span>(*res, matrix[i][ys])</span><br><span class="line">	&#125;</span><br><span class="line">	ys++</span><br><span class="line">	toR(matrix, res, xs, xe, ys, ye)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>最大子序和</title>
    <url>/2019/12/24/leetcode/53/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><em>示例:</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure></p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>贪心算法</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 贪心算法，每步都选最大值</span></span><br><span class="line">	length := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">if</span> length == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	res := nums[<span class="number">0</span>]</span><br><span class="line">	curMax := nums[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123;</span><br><span class="line">		curMax = max(nums[i], curMax + nums[i])</span><br><span class="line">		res = max(res, curMax)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>其实这两个思路都是一样的，<br>就计算当前位置的最大累加值  对比 历史最大累加值</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 动态规划</span></span><br><span class="line">	<span class="comment">// 利用 f(n) =  1:  nums[n]  条件 f(n-1)&lt;=0  2: f(n-1) + nums[n] </span></span><br><span class="line">	length := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">if</span> length == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	res := nums[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i<span class="number">-1</span>] &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 将累加值存储在原数组</span></span><br><span class="line">			nums[i] = nums[i<span class="number">-1</span>] + nums[i]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 计算最大值</span></span><br><span class="line">		res = max(res, nums[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转图像</title>
    <url>/2019/12/18/leetcode/48/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个 <code>n × n</code> 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p>说明：</p>
<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要<em>使用</em>另一个矩阵来旋转图像。</p>
<p><strong>示例 1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 matrix = </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br><strong>示例 2:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 matrix =</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>先矩阵转置，然后每行翻转。<br>时间复杂度 O（n*n）<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(matrix [][]<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(matrix)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先矩阵转置，就是沿着对角线互换</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j:=i; j&lt;n;j++ &#123;</span><br><span class="line">			tmp := matrix[i][j]</span><br><span class="line">			matrix[i][j] = matrix[j][i]</span><br><span class="line">			matrix[j][i] = tmp</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 然后每行翻转</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;n/<span class="number">2</span>;j++ &#123;</span><br><span class="line">			tmp := matrix[i][j]</span><br><span class="line">			matrix[i][j] = matrix[i][n-j<span class="number">-1</span>]</span><br><span class="line">			matrix[i][n-j<span class="number">-1</span>] = tmp</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>就是将每4个对应的元素顺时针旋转一下<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(matrix [][]<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(matrix)</span><br><span class="line">	<span class="comment">// 很自然的想法，就是对应位置的 4个元素顺时针转了一圈。</span></span><br><span class="line">	<span class="comment">// 可以以 n-4 的矩阵画一下，以 i=0,j=1 这个元素，来尝试一下下标变化</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;(n+<span class="number">1</span>)/<span class="number">2</span>;i++&#123;</span><br><span class="line">		<span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;n/<span class="number">2</span>;j++&#123;</span><br><span class="line">			tmp := matrix[i][j]</span><br><span class="line">			matrix[i][j] = matrix[n<span class="number">-1</span>-j][i]</span><br><span class="line">			matrix[n<span class="number">-1</span>-j][i]=matrix[n<span class="number">-1</span>-i][n<span class="number">-1</span>-j]</span><br><span class="line">			matrix[n<span class="number">-1</span>-i][n<span class="number">-1</span>-j]=matrix[j][n<span class="number">-1</span>-i]</span><br><span class="line">			matrix[j][n<span class="number">-1</span>-i]=tmp</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>跳跃游戏 II</title>
    <url>/2019/12/11/leetcode/45/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p><em>示例:</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure><br><em>说明:</em></p>
<p>假设你总是可以到达数组的最后一个位置。</p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>思路就是 当前坐标，一步最大跨越到 end。<br>然后在 遍历 end 计算下一个最大跨步是多少。依次往后</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	length := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">if</span> length &lt;=<span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	end := nums[<span class="number">0</span>];</span><br><span class="line">	maxPosition := end;</span><br><span class="line">	steps := <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 简单点说 坐标 end 代表这步要跨越到哪里，直到遍历到 end，一直更新 maxPosition，</span></span><br><span class="line">	<span class="comment">// 当达到 end 的时候，当前 maxPosition 就是下次跨越到的地方了，同样的逻辑，在本次步长内，继续寻找下次达到的地方</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length- <span class="number">1</span>; i++&#123;</span><br><span class="line">		<span class="comment">//找能跳的最远的</span></span><br><span class="line">		maxPosition = max(maxPosition, nums[i] + i);</span><br><span class="line">		<span class="keyword">if</span> i == end &#123; <span class="comment">//遇到边界，就更新边界，并且步数加一</span></span><br><span class="line">			end = maxPosition;</span><br><span class="line">			steps++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	steps++</span><br><span class="line">	<span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a&gt;b&#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>从后往前推</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	position := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">	steps := <span class="number">0</span></span><br><span class="line">	<span class="comment">// 思路是 倒着来，寻找能够到达目的点 position 的最左坐标，然后 position 定位刚刚寻找的点，继续寻找，直到0</span></span><br><span class="line">	<span class="keyword">for</span> ;position!=<span class="number">0</span>; &#123;</span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;position;i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[i] &gt;= position - i &#123;</span><br><span class="line">				position = i</span><br><span class="line">				steps++</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> steps</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>接雨水</title>
    <url>/2019/12/08/leetcode/42/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br><img src="/2019/12/08/leetcode/42/42.png" class="" title="This is an example image"><br>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p>
<p><em>示例</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure></p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>思路是依次判断 每个坐标 i 上，能装多少水<br>判断的思路是  计算 坐标 i 左右两边的最大值 maxLeft maxRight ，根据破桶原理，选择其中较小的 min，<br>如果 min &gt; height[i] 那么 min - height[i] 就是该坐标能够装的水</p>
<p>时间复杂度为 O(n*n)</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	length := <span class="built_in">len</span>(height)</span><br><span class="line">	<span class="keyword">if</span> length &lt;= <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 思路是依次判断 每个坐标 i 上，能装多少水</span></span><br><span class="line">	<span class="comment">// 判断的思路是  计算 坐标 i 左右两边的最大值 maxLeft maxRight ，根据破桶原理，选择其中较小的 min，</span></span><br><span class="line">	<span class="comment">// 如果 min &gt; height[i] 那么 min - height[i] 就是该坐标能够装的水</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;length<span class="number">-1</span>;i++ &#123;</span><br><span class="line">		maxLeft := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> j:=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--&#123;</span><br><span class="line">			<span class="keyword">if</span> height[j] &gt; maxLeft &#123;</span><br><span class="line">				maxLeft = height[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		maxRight := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> j:=i+<span class="number">1</span>;j&lt;length;j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> height[j] &gt; maxRight &#123;</span><br><span class="line">				maxRight = height[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		min := min(maxLeft, maxRight)</span><br><span class="line">		<span class="keyword">if</span> min &gt; height[i] &#123;</span><br><span class="line">			res = res + (min - height[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>动态规划<br>还是上面的思路，只不过不需要每次都重新计算 <code>maxLeft</code> <code>maxRight</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maxLeft[i] = max(maxLeft[i-1], height[i-1])</span><br><span class="line">maxRight[i] = max(maxRight[i+1], height[i+1])</span><br></pre></td></tr></table></figure><br>我们可以先计算出来 maxLeftArr maxRightArr</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	length := <span class="built_in">len</span>(height)</span><br><span class="line">	<span class="keyword">if</span> length &lt;= <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">	maxLeftArr := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line">	maxRightArr := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;length<span class="number">-1</span>;i++&#123;</span><br><span class="line">		maxLeftArr[i] = max(maxLeftArr[i<span class="number">-1</span>], height[i<span class="number">-1</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i:= length<span class="number">-2</span>; i&gt;<span class="number">0</span>;i-- &#123;</span><br><span class="line">		maxRightArr[i] = max(maxRightArr[i+<span class="number">1</span>], height[i+<span class="number">1</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;length<span class="number">-1</span>;i++ &#123;</span><br><span class="line">		min := min(maxLeftArr[i], maxRightArr[i])</span><br><span class="line">		<span class="keyword">if</span> min &gt; height[i] &#123;</span><br><span class="line">			res = res + (min - height[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h3><p>双指针，从左右两边，找最高都<br>height[left-1], height[right+1]<br>哪边更高，就计算旁边坐标的灌水<br><code>if height[left-1] &lt; height[right+1]</code><br>就计算 <code>height[left]</code> 的，否则计算 <code>height[right]</code> 的</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	length := <span class="built_in">len</span>(height)</span><br><span class="line">	<span class="keyword">if</span> length &lt;= <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> maxLeft, maxRight <span class="keyword">int</span></span><br><span class="line">	left := <span class="number">1</span></span><br><span class="line">	right := length<span class="number">-2</span></span><br><span class="line">	<span class="keyword">for</span> ;left &lt;= right; &#123;</span><br><span class="line">		<span class="keyword">if</span> height[left<span class="number">-1</span>] &lt; height[right+<span class="number">1</span>] &#123;</span><br><span class="line">			maxLeft = max(height[left<span class="number">-1</span>], maxLeft)</span><br><span class="line">			<span class="keyword">if</span> maxLeft &gt; height[left] &#123;</span><br><span class="line">				res = res + (maxLeft - height[left])</span><br><span class="line">			&#125;</span><br><span class="line">			left++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			maxRight = max(maxRight, height[right+<span class="number">1</span>])</span><br><span class="line">			<span class="keyword">if</span> maxRight &gt; height[right] &#123;</span><br><span class="line">				res = res + (maxRight - height[right])</span><br><span class="line">			&#125;</span><br><span class="line">			right--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>缺失的第一个正数</title>
    <url>/2019/12/04/leetcode/41/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p>
<p><em>示例 1:</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,0]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><br><em>示例 2:</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,4,-1,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><br><em>示例 3:</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,8,9,11,12]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><br><em>说明:</em><br>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。</p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>不考虑空间限制，使用 <code>map</code> 记录出现的数字<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstMissingPositive</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 空间换时间，暴力解法</span></span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		m[num] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	n := <span class="built_in">len</span>(nums) + <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;n;i++ &#123;</span><br><span class="line">		_, ok := m[i]</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>还是上面的思路，不过，依据结果肯定在 <code>(0,n]</code> 之间,因此可以使用一个数组来记录<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstMissingPositive</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用数组 结果只可能是 (0, len+1] 中间，因此，构建一个数组，坐标元素相同</span></span><br><span class="line">	length := <span class="built_in">len</span>(nums)</span><br><span class="line">	m := <span class="built_in">make</span>([]<span class="keyword">int</span>, length + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="keyword">if</span> num&gt;<span class="number">0</span> &amp;&amp; num &lt;= length &#123;</span><br><span class="line">			m[num] = num</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 不相同的，代表不存在，直接取结果了</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=length;i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> m[i] != i &#123;</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> length + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h3><p>上面两个解法空间都不满足要求，题目要求常量级别空间，基本就断定，只能在原数组都基础上修改来。还是利用结果在 <code>(0,n]</code>, 剔除掉不在范围内都。都使用 <code>1</code> 来填充,上面思路2，我们使用 <code>a[i] = i + 1</code> 来表示出现来数字 <code>i</code>,现在，使用取负数，来表示出现过 <code>i</code>.<br>为啥取负数，因为，当我们有 <code>a = nums[i]</code> 在范围 <code>(0,n]</code> ， 我们需要记录 <code>nums[a]</code> .如何记录，上面思路2，是等于 i + 1.但是，这样就修改来原有都数字来，我们需要保留这个数字，因此取负数</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstMissingPositive</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	length := <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">	has1 := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;length;i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i]==<span class="number">1</span> &#123;</span><br><span class="line">			has1++</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> has1 == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> length == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; length;i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] &lt;= <span class="number">0</span> || nums[i] &gt; length &#123;</span><br><span class="line">			nums[i]=<span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;length;i++&#123;</span><br><span class="line">		a := abs(nums[i])</span><br><span class="line">		<span class="keyword">if</span> a == length &#123;</span><br><span class="line">			nums[<span class="number">0</span>] = - abs(nums[<span class="number">0</span>])</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			nums[a] = - abs(nums[a])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;length;i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> nums[<span class="number">0</span>] &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> length</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> length + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> -a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>组合总和II</title>
    <url>/2019/12/02/leetcode/40/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个数组  <code>candidates</code>  和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p>
<p>说明：</p>
<p>所有数字（包括目标数）都是正整数。<br>解集不能包含重复的组合。<br><em>示例 1:</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br><em>示例 2:</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>和之前的不同前提<br>1。 数组可能有重复数字<br>2。 不能重复使用数组里面的数字</p>
<p>还是之前的思路。之前的解法<br>不同点在于，每次都是从 i+1 开始</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum2</span><span class="params">(candidates []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 和之前的不同前提</span></span><br><span class="line">	<span class="comment">// 1。 数组可能有重复数字</span></span><br><span class="line">	<span class="comment">// 2。 不能重复使用数组里面的数字</span></span><br><span class="line">	<span class="keyword">var</span> res [][]<span class="keyword">int</span></span><br><span class="line">	n := <span class="built_in">len</span>(candidates)</span><br><span class="line">	<span class="keyword">if</span> n != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// n*logn</span></span><br><span class="line">		sort.Ints(candidates)</span><br><span class="line">		findByCanditates2(<span class="number">0</span>, target, candidates, []<span class="keyword">int</span>&#123;&#125;, &amp;res)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findByCanditates2</span><span class="params">(i, target <span class="keyword">int</span>, nums []<span class="keyword">int</span>, candidates []<span class="keyword">int</span>, res *[][]<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">if</span> target == <span class="number">0</span> &#123;</span><br><span class="line">		*res = <span class="built_in">append</span>(*res, candidates)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(nums) || target &lt; nums[i] &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 问题在这里，如果直接对 candidates 进行修改，这里是 go 这里是引用传参，会导致其他地方都会有问题</span></span><br><span class="line">	<span class="comment">// 因此，新建一个 slice 然后 copy，但是，copy 对时候，注意 newCandidate 对初始长度与 candidates 一样，否则多出来对会为0，如果少了，它也不自动扩容</span></span><br><span class="line">	<span class="comment">// 因此这里使用 make 创建，而不是初始定义，初始定义为 nil，copy 没作用</span></span><br><span class="line">	<span class="keyword">var</span> newCandidate = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(candidates))</span><br><span class="line">	<span class="built_in">copy</span>(newCandidate, candidates)</span><br><span class="line">  newCandidate = <span class="built_in">append</span>(newCandidate, nums[i])</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 不同点1:  i+1 开始</span></span><br><span class="line">	findByCanditates2(i+<span class="number">1</span>, target - nums[i], nums, newCandidate, res)</span><br><span class="line"></span><br><span class="line">	length := <span class="built_in">len</span>(nums)</span><br><span class="line">  <span class="keyword">var</span> j = i + <span class="number">1</span></span><br><span class="line">  <span class="comment">// 不同点2: 跳过同样的数字</span></span><br><span class="line">	<span class="keyword">for</span> ;j &lt; length &amp;&amp; nums[j] == nums[j<span class="number">-1</span>]; j++ &#123;&#125;</span><br><span class="line">	findByCanditates2(j, target, nums, candidates, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>组合总和</title>
    <url>/2019/12/01/leetcode/39/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<p>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。<br><em>示例 1:</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2,3,6,7], target = 7,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br><em>示例 2:</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>先排序，用来剔除重复的结果<br>譬如 <code>candidates = [2, 3, 7], target = 18</code><br>思路就是从 <code>18 - 2</code> <code>18 - 3</code> <code>18 - 7</code> ，然后递归调用。  </p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 可以重复使用列表里面的数</span></span><br><span class="line">	<span class="comment">// 结果不能重复</span></span><br><span class="line">	<span class="keyword">var</span> res [][]<span class="keyword">int</span></span><br><span class="line">	n := <span class="built_in">len</span>(candidates)</span><br><span class="line">	<span class="keyword">if</span> n != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// n*logn</span></span><br><span class="line">		sort.Ints(candidates)</span><br><span class="line">		findByCanditates(<span class="number">0</span>, target, candidates, []<span class="keyword">int</span>&#123;&#125;, &amp;res)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findByCanditates</span><span class="params">(i, target <span class="keyword">int</span>, nums []<span class="keyword">int</span>, candidates []<span class="keyword">int</span>, res *[][]<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">  <span class="comment">// 结果在这里</span></span><br><span class="line">	<span class="keyword">if</span> target == <span class="number">0</span> &#123;</span><br><span class="line">		*res = <span class="built_in">append</span>(*res, candidates)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 截止情况</span></span><br><span class="line">	<span class="keyword">if</span> i == <span class="built_in">len</span>(nums) || target &lt; nums[i] &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 问题在这里，如果直接对 candidates 进行修改，这里是 go 这里是引用传参，会导致其他地方都会有问题</span></span><br><span class="line">	<span class="comment">// 因此，新建一个 slice 然后 copy，但是，copy 对时候，注意 newCandidate 对初始长度与 candidates 一样，否则多出来对会为0，如果少了，它也不自动扩容</span></span><br><span class="line">	<span class="comment">// 因此这里使用 make 创建，而不是初始定义，初始定义为 nil，copy 没作用</span></span><br><span class="line">	<span class="keyword">var</span> newCandidate = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(candidates))</span><br><span class="line">	<span class="built_in">copy</span>(newCandidate, candidates)</span><br><span class="line">  newCandidate = <span class="built_in">append</span>(newCandidate, nums[i])</span><br><span class="line">  <span class="comment">// 使用递归调用，来构建树，这里代表深度，尝试先用小的数累加，然后看看有没有结果</span></span><br><span class="line">  findByCanditates(i, target - nums[i], nums, newCandidate, res)</span><br><span class="line">  <span class="comment">// 这里是广度，target 没变化，i + 1，代表，尝试往后面看，有没有用最少的数量组成结果</span></span><br><span class="line">	findByCanditates(i+<span class="number">1</span>, target, nums, candidates, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索插入位置</title>
    <url>/2019/11/30/leetcode/35/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p><em>示例 1:</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><br><em>示例 2:</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><br><em>示例 3:</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><br><em>示例 4:</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure></p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>爆破了，就是找第一个 <code>&gt; target</code> 的位置 </p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 暴力</span></span><br><span class="line">	l := <span class="built_in">len</span>(nums)</span><br><span class="line">	res := l</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; l; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] &gt;= target &#123;</span><br><span class="line">			res = i</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>二分，<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 二分</span></span><br><span class="line">	l := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="comment">//res := l</span></span><br><span class="line">	left := <span class="number">0</span></span><br><span class="line">	right := l - <span class="number">1</span></span><br><span class="line">	<span class="comment">// 问题在于，还需要找到插入的位置，target 也可能在数组中不存在</span></span><br><span class="line">	<span class="keyword">for</span> ; left &lt;= right; &#123;</span><br><span class="line">		mid := left + (right - left) / <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">			right = mid - <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			left = mid + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> right + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2019/11/28/leetcode/34/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 <code>O(log n)</code> 级别。</p>
<p>如果数组中不存在目标值，返回 <code>[-1, -1]</code>。</p>
<p><em>示例 1:</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: [3,4]</span><br></pre></td></tr></table></figure><br><em>示例 2:</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出: [-1,-1]</span><br></pre></td></tr></table></figure></p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>log 级别，需要使用二分法</p>
<p>自己的思路是，先二分找到 target，然后从该 index，左右扩展，寻找边界坐标<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> res []<span class="keyword">int</span></span><br><span class="line">	res = <span class="built_in">append</span>(res, <span class="number">-1</span>, <span class="number">-1</span>)</span><br><span class="line">	<span class="built_in">len</span> := <span class="built_in">len</span>(nums)</span><br><span class="line">	left := <span class="number">0</span>;</span><br><span class="line">	right := <span class="built_in">len</span> - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> ; left &lt;= right; &#123;</span><br><span class="line">		mid := left + (right - left) / <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">			left = mid + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">			right = mid - <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> left = mid; left &gt;= <span class="number">1</span> &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]; left--&#123;&#125;</span><br><span class="line">			<span class="keyword">for</span> right = mid; right &lt;= <span class="built_in">len</span> - <span class="number">2</span> &amp;&amp; nums[right] == nums[right+<span class="number">1</span>]; right++&#123;&#125;</span><br><span class="line">			res[<span class="number">0</span>] = left</span><br><span class="line">			res[<span class="number">1</span>] = right</span><br><span class="line">			<span class="keyword">return</span> res</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索旋转排序数组</title>
    <url>/2019/11/26/leetcode/33/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p><em>示例1</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><br><em>示例2</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure></p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>O(log n) 肯定是需要二分法的,思路直接看注释了</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// logn 肯定是需要二分法了</span></span><br><span class="line">	result := <span class="number">-1</span></span><br><span class="line">	start := <span class="number">0</span></span><br><span class="line">	end := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">	<span class="comment">// 头尾指针</span></span><br><span class="line">	<span class="keyword">for</span> ; start &lt;= end; &#123;</span><br><span class="line">		<span class="comment">// 取中间的数</span></span><br><span class="line">		mid := start + (end - start) / <span class="number">2</span></span><br><span class="line">		<span class="comment">// 刚好等于，那就返回结果</span></span><br><span class="line">		<span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">			<span class="keyword">return</span> mid</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 开始 比 mid 小， start - mid 是一个升序</span></span><br><span class="line">		<span class="keyword">if</span> nums[start] &lt;= nums[mid] &#123;</span><br><span class="line">			<span class="comment">// 如果 target 在 start 和 mid 中间，那么就在 start，mid-1 里面找</span></span><br><span class="line">			<span class="keyword">if</span> target &gt;= nums[start] &amp;&amp; target &lt; nums[mid] &#123;</span><br><span class="line">				end = mid - <span class="number">1</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 否则 就是在 mid + 1， end</span></span><br><span class="line">				start = mid + <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 那么  mid - end 是升序，类似的处理</span></span><br><span class="line">			<span class="keyword">if</span> target &gt; nums[mid] &amp;&amp; target &lt;= nums[end] &#123;</span><br><span class="line">				start = mid + <span class="number">1</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				end = mid - <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm-垃圾搜集器</title>
    <url>/2019/11/26/jvm-%E5%9E%83%E5%9C%BE%E6%90%9C%E9%9B%86%E5%99%A8/</url>
    <content><![CDATA[<p>垃圾回收需要考虑三件事  </p>
<ol>
<li>哪些内存需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ol>
<h2 id="对象是否已死"><a href="#对象是否已死" class="headerlink" title="对象是否已死"></a>对象是否已死</h2><ol>
<li>引用计数</li>
<li>可达性分析</li>
</ol>
<p>引用类型  </p>
<ul>
<li>强引用  常用的，new </li>
<li>软引用  将要发生内存溢出，会回收软引用</li>
<li>弱引用  下一次 gc 到来的时候回收</li>
<li>虚引用  不知道啥时候回收，只是为了获取通知</li>
</ul>
<p>类卸载条件</p>
<ul>
<li>类的所有实例已被回收</li>
<li>加载该类的 ClassLoader 已经被回收</li>
<li>类的 Class 对象没有被其他地方引用</li>
</ul>
<h2 id="垃圾搜集算法"><a href="#垃圾搜集算法" class="headerlink" title="垃圾搜集算法"></a>垃圾搜集算法</h2><ol>
<li>标记清除 Mark-Sweep</li>
<li>复制算法</li>
<li>标记整理 Mark-Compact</li>
<li><p>分代收集算法 </p>
</li>
<li><p>枚举根节点<br>从 GCRoot 找引用链，不在链路上的就是垃圾了</p>
</li>
<li>安全点<br>SafePoint，在特定的位置，记录引用，就是安全点</li>
<li>安全区域<br>线程没在执行的情况，不会引起引用发生变化的区域，是安全区域</li>
</ol>
<h2 id="垃圾搜集器"><a href="#垃圾搜集器" class="headerlink" title="垃圾搜集器"></a>垃圾搜集器</h2><ul>
<li>Young: Serial，ParNew，Parallel Scavenge，   G1</li>
<li>Old: CMS, Serial Old, Parallel Old     G1</li>
</ul>
<ol>
<li>Serial<br>最基本的垃圾搜集器，是单线程的搜集器，在垃圾搜集的时候，需要停止其他工作线程</li>
<li>ParNew<br>是 Serial 的多线程版本</li>
<li>Parallel Scavenge<br>关注点在达到可控制的吞吐量。<br>上面三个都是复制算法</li>
<li>Seril Old<br>1 的老年代版本</li>
<li>Parallel Old<br>Parallel Scavenge 的老年代版本，多线程和标记整理算法</li>
<li>CMS<br>多线程+标记清除，工作分为 4 步<ol>
<li>初始标记   stop the world   速度很快</li>
<li>并发标记</li>
<li>重新标记   stop the world</li>
<li>并发清除<br>缺点：</li>
<li>会占用用户线程 CPU 资源</li>
<li>无法清除浮动垃圾 并发清理阶段产生的垃圾</li>
<li>会有空间碎片，如果过多，可能导致 Full GC</li>
</ol>
</li>
<li>G1<br>并发，分代搜集，空间整合，可预测的停顿<br>基本和上面的不一样了，将真个内存区域划分为 Region ，Region 可以用来作为新生代，老年代，不需要空间连续<br>步骤<ol>
<li>初始标记  stop the world  时间很短</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ol>
</li>
</ol>
<h2 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h2><ol>
<li>优先在 Eden 分配</li>
<li>当 Eden 没有足够的空间进行分配，将发起一次 Minor GC</li>
<li>大对象直接进老年代，长字符串，数组</li>
<li>长期存活多对象进老年代，对象在 Eden 出生经过一次 Minor GC，进入 Survivor 区，年龄为1，没熬过一次 Minor GC 年龄 + 1，到 15（默认），进老年代，例外：如果相同年龄占 survivor 一半以上，年龄大于等于这个年龄的，直接进老年代</li>
</ol>
<p><em>空间分配担保</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在发生 Minor GC 之前，检测</span><br><span class="line">if 老年代 最大连续可用空间 &gt; 新生代所有对象空间</span><br><span class="line">  Minor GC</span><br><span class="line">else if 允许担保是吧 &amp;&amp; 老年代 最大连续可用空间 &gt; 历次晋升到老年代的空间</span><br><span class="line">  Minor GC</span><br><span class="line">else </span><br><span class="line">  Full GC</span><br></pre></td></tr></table></figure><br>空间分配担保，主要是为了减少 <code>Full GC</code></p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>下一个排列</title>
    <url>/2019/11/24/leetcode/31/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须<em>原地</em>修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,2,3 → 1,3,2</span><br><span class="line">3,2,1 → 1,2,3</span><br><span class="line">1,1,5 → 1,5,1</span><br></pre></td></tr></table></figure>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>首先要理解题目意思，什么是下一个序列，最小序列，最大序列<br><code>1,2,3</code>  可以看做数字 <code>123</code> 那么使用 <code>1,2,3</code> 数字组合的下一个序列是 <code>1,3,2</code> 其实就是 <code>1,2,3</code> 三个数字排列组合后，当前排列的更大的一个排列。   什么时候最小呢？升序的时候，就是 <code>123</code> 什么时候最大呢 ？ 降序的时候 <code>321</code> 。<br>来一个更普通的例子 <code>1,5,8,4,7,5,3,1</code> ,它的下一个序列是什么呢？ <code>1,5,8,5,1,3,4,7</code><br>我们直接看换的思路是什么？首先降序排列是最大的，同样适用于局部，这里的分界是 <code>4,7</code>,我们只要将 <code>4</code> 替换为 <code>5</code>(刚好比 <code>4</code> 大的) 后面的变成升序（最小）就行了。<br>具体到思路  </p>
<ol>
<li>找到 <code>a[i] &lt;= a[i + 1]</code></li>
<li>在 <code>i</code> 的右侧，找到刚好大于 <code>a[i]</code> 的数 <code>a[j]</code></li>
<li>交互 <code>a[i], a[j]</code></li>
<li>从 <code>i + 1</code> 开始，后面的数变成降序</li>
</ol>
<p>大体思路就是上面的，当然，基于这个思路还可以有一些细节优化</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextPermutation</span><span class="params">(nums []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	i := <span class="built_in">len</span>(nums) - <span class="number">2</span></span><br><span class="line">	<span class="keyword">for</span> ; i &gt;= <span class="number">0</span> &amp;&amp; nums[i + <span class="number">1</span>] &lt;= nums[i]; i--&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">		j := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> ; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &lt;= nums[i]; j--&#123;&#125;</span><br><span class="line">		swap(nums, i, j)</span><br><span class="line">	&#125;</span><br><span class="line">	reverse(nums, i + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(nums []<span class="keyword">int</span>, start <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	i := start</span><br><span class="line">	j := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> ; i &lt; j ; &#123;</span><br><span class="line">		swap(nums, i, j)</span><br><span class="line">		i++</span><br><span class="line">		j--</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(nums []<span class="keyword">int</span>, i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	temp := nums[i]</span><br><span class="line">	nums[i] = nums[j]</span><br><span class="line">	nums[j] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm-自动内存管理</title>
    <url>/2019/11/23/jvm-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p><code>深入理解 Java 虚拟机</code> 读书笔记 </p>
<h2 id="运行时数据区域划分"><a href="#运行时数据区域划分" class="headerlink" title="运行时数据区域划分"></a>运行时数据区域划分</h2><ol>
<li>方法区（元空间）<br>线程共享区域，主要存储已被虚拟机加载的类信息，常量，静态变量，即时编译后的产物，也叫非堆（Non Heap）<br>运行时常量池。</li>
<li>虚拟机栈<br>线程私有的，生命周期和线程相同，每个方法执行的同时都会创建一个栈帧（Stack Frame），用来存局部变量表，操作数栈，动态链接，方法出口等信息，<br>局部变量表存放编译期可知的各种基本数据类型，每个局部变量空间（slot）为 32 位，64 为长度的类型占用两个 slot</li>
<li>本地方法栈<br>为 native 方法服务的</li>
<li>堆<br>最大的一块内存区域，也是线程共享的内存区域，几乎所有的对象都在这里分配内存。<br>这里也是垃圾回收的主要区域，因为分代搜集算法，所以堆还可细分为 新生代 和 老年代，新生代再细致一点有 eden，from survivor， to survivor，</li>
<li>程序计数器<br>可以看作是当前线程所执行的字节码行号指示器，线程私有的</li>
<li>直接内存<br>DirectByteBuffer 引用一块堆外内存</li>
</ol>
<h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>普通对象创建（不包含数组，<code>Class</code> 对象）  </p>
<ol>
<li>类加载过程<br>在常量池中是否定位一个类的符号引用<br>类是否已被加载，解析，初始化</li>
<li>新生对象分配内存<br>对象所需的内存大小在类加载完成后就已经确定？<br>分配内存的方式<ul>
<li>指针碰撞： 假设内存规整，由于对象所需内存大小已知，只需要记录边界指针，移动响应的大小就行类</li>
<li>空闲列表： 内存不规整，那么就需要记录哪些空间是可用的，需要维护一个列表<br>内存是否规整由采用的垃圾回收器决定。 Serial ， ParNew 等垃圾搜集完毕，会整理内存，因此是 指针碰撞<br>CMS 基于标记-清除，没有内存整理，因此是空闲列表<br>创建对象是非常频繁的操作，直接指针修改位置，是非线程安全的，有两种解决方式<ul>
<li>CAS 失败重试，并发常用的模式</li>
<li>TLAB 本地线程分配缓冲，每个线程先预分配一小块内存，用完了，才需要同步锁定<br>内存分配完毕后，会初始化零值，应该可以理解为所有位全部置 0</li>
</ul>
</li>
</ul>
</li>
<li>对象设置<br>例如，这个对象是哪个类的实例。如何找到类的元数据，对象哈希码，对象的 GC 分代年龄。这些信息放对象头中</li>
<li>init 方法<br>从虚拟机角度，上面3个步骤后，对象就已经创建完了，但是还没执行 init 方法，也就是构造方法，当然，字段的初值也是在 init 方法里面执行</li>
</ol>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>可以分为 3 个区域：对象头，实例数据，对齐填充 </p>
<p><em>对象头</em><br>包含两部分数据</p>
<ol>
<li>对象自身运行时数据：哈希码，GC 分代年龄，锁状态标志，线程持有的锁，偏向线程id，偏向时间戳等，在 64 为虚拟机中占 64 位，也就是常说的 Mark Word</li>
<li>类型指针：指向类的元数据指针，并不是所有虚拟机实现都必须在对象上保留类型指针</li>
<li>如果是数组，那么还有数组长度</li>
</ol>
<p>32位 对象头内存布局<br><img src="/2019/11/23/jvm-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/JVM32-obj-header.png" class="" title="JVM 32位对象头内存布局"></p>
<p>64位 对象头内存布局<br><img src="/2019/11/23/jvm-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/JVM64-obj-header.png" class="" title="JVM 64位对象头内存布局"></p>
<p><em>实例数据</em><br>各种类型的字段内容，包括父类继承的和自己的</p>
<p><em>填充*</em><br>对象内存起始地址必须是 8 字节的整数倍，如果没对齐，就有对齐填充了</p>
<h2 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h2><p>Java 程序需要使用栈上的 reference 数据来操作具体的堆上的具体对象。<br>reference 指向一个的对象的引用，有两种访问方式</p>
<ol>
<li>句柄：堆中单独划分一块内存，用来存句柄池，reference 指向句柄地址，句柄包含对象实例数据，类型数据的具体地址</li>
<li>直接指针: reference 直接指向对象地址</li>
</ol>
<p>句柄的好处是 referenc 存储稳定，对象移动（GC 影响）只修改 句柄到对象的指向。<br>直接指针的好处就是速度快。<br><code>Hotspot</code> 采用的是 直接指针</p>
<h2 id="内存溢出问题-OutOfMemoryError"><a href="#内存溢出问题-OutOfMemoryError" class="headerlink" title="内存溢出问题 OutOfMemoryError"></a>内存溢出问题 OutOfMemoryError</h2><p><em>堆内存溢出</em><br>堆内存大小设置以及内存溢出时候 dump，这几个 JVM 参数是常用的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置最小堆内存</span><br><span class="line">-Xms20m</span><br><span class="line">设置最大堆内存</span><br><span class="line">-Xmx20m</span><br><span class="line">发生内存溢出的时候 dump，通常 JVM 用 -XX:+/- 来代表 true/false</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure></p>
<p>有来 dump 文件，可以使用 MAT 进行分析。查看哪个对象占用空间大，也可以查看泄露对象到 GC root 的引用链，分析为什么没有释放内存  </p>
<p><em>虚拟机栈和本地方法栈</em><br>栈空间大小设置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xss</span><br><span class="line">-Xsx</span><br></pre></td></tr></table></figure></p>
<p>栈空间，如果请求深度过大，会是 <code>StackOverflowError</code> , 也是栈溢出，通常在递归调用的时候容易出现<br>当虚拟机在扩展栈空间的时候，无法申请到足够的内存空间，则抛出 <code>OutOfMemoryError</code> </p>
<p><em>方法区/元空间</em><br>这里导致溢出，通常是动态代理，或者字节码技术生成 class 过多导致的</p>
<p><em>本机直接内存溢出*</em><br>由于 nio 可以申请使用堆外内存。<br>堆外内存限制可以使用参 <code>-XX: MaxDirectMemorySize</code> 指定<br>由直接内存导致的内存溢出，一个明显的特征是 Heap Dump 文件中看不到明显的异常，Dump 文件也很小</p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>移除元素</title>
    <url>/2019/11/23/leetcode/27/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要原地移除所有数值等于 <code>val</code> 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 <code>O(1)</code> 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><em>示例1</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums = [3,2,2,3], val = 3,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p>
<p><em>示例2</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums = [0,1,2,2,3,0,4,2], val = 2,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p>
<p>首先，理解一下题目，最后想要的结果，是数组中 <code>!= val</code> 的数量，并且，这些数需要被挪到数组前面，不管顺序<br>过程条件,额外空间为 <code>O(1)</code>,那就是不能使用额外数组空间了 </p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>快慢指针，慢指针用来记录最后结果存储的下标，快指针遍历原数组<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="keyword">int</span>, val <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 快慢双指针，i 为填充数组的坐标，j 遍历原数组</span></span><br><span class="line">	<span class="comment">// 当不等于 val 当时候，保留， == val 当时候 j++ 了后面保留在 i 的位置</span></span><br><span class="line">	<span class="comment">// 这里问题在于，如果 nums 全不同，实际上，会有很多无效的赋值操作</span></span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="built_in">len</span> := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">for</span> j:=<span class="number">0</span>; j &lt; <span class="built_in">len</span>; j++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[j] != val &#123;</span><br><span class="line">			nums[i] = nums[j]</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>将 <code>== val</code> 的数丢到数组后面就行了<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="keyword">int</span>, val <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 理解题目，其实就是将 != val 的数挪到前面去，那我们把 == val 的丢到数组最后就行了</span></span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">for</span> ; i &lt; n; &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] == val &#123;</span><br><span class="line">			nums[i] = nums[n - <span class="number">1</span>]</span><br><span class="line">			n--</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池常见问题记录</title>
    <url>/2019/11/22/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>记录一些常见的关于线程池的问题，参考其他看过的资料，总结为自己的答案</p>
<h2 id="为什么不推荐使用-Executors-创建线程池"><a href="#为什么不推荐使用-Executors-创建线程池" class="headerlink" title="为什么不推荐使用 Executors 创建线程池"></a>为什么不推荐使用 Executors 创建线程池</h2><p><code>Executors</code> 内部使用的是 <code>ThreadPoolExecutor</code>，如果转为直接使用 <code>ThreadPoolExecutor</code>, 那么需要使用者了解内部的原理，至少知道几个参数是干嘛的。如果使用 <code>Executors</code> 创建，可能不太清楚内部的规则，而导致资源耗尽的异常。</p>
<h2 id="线程池的参数有哪些"><a href="#线程池的参数有哪些" class="headerlink" title="线程池的参数有哪些"></a>线程池的参数有哪些</h2><p>这里，其实就是问的 <code>ThreadPoolExecutor</code> 构造需要哪些参数，当然，<code>ThreadPoolExecutor</code> 内部也有几个非构造传入的参数，其中重点参数有</p>
<ol>
<li>corePoolSize 核心线程数</li>
<li>maximumPoolSize 最大线程数</li>
<li>keepAliveTime 超过核心线程数，最大空闲存活时间</li>
<li>unit 上面的单位</li>
<li>workQueue 工作队列</li>
<li>threadFactory 线程工程，这里注意修改线程名和是否后台线程</li>
<li>handler  拒绝策略 <code>RejectedExecutionHandler</code> 接口的实现</li>
</ol>
<p>除了上面的构造参数，还有一个 <code>allowCoreThreadTimeOut</code> 是否允许释放核心线程，正常情况下，线程池会维持至少 core 个核心线程，如果配置了这个参数，那么核心线程也会使用 <code>keepAliveTime</code> 的配置来释放自己</p>
<h2 id="线程池的任务提交流程"><a href="#线程池的任务提交流程" class="headerlink" title="线程池的任务提交流程"></a>线程池的任务提交流程</h2><ol>
<li>如果线程池中线程的数量 小于 core ，那么创建新的任务线程</li>
<li>如果已经到达了 core 线程，那么丢任务队列 workQueue</li>
<li>如果队列满了，继续新建线程数量 小于 maximumPoolSize （对单个任务来说，只是建一个线程，当然，也可能建不了，因为 core == maximumPoolSize）</li>
<li>如果线程数量达到 maximumPoolSize ，那么使用拒绝策略 <code>RejectedExecutionHandler</code></li>
</ol>
<h2 id="线程池的关闭方法是上面，对正在运行的线程有怎样的影响"><a href="#线程池的关闭方法是上面，对正在运行的线程有怎样的影响" class="headerlink" title="线程池的关闭方法是上面，对正在运行的线程有怎样的影响"></a>线程池的关闭方法是上面，对正在运行的线程有怎样的影响</h2><p>关闭方法有两个</p>
<ol>
<li>shutdown<br>设置为 <code>SHUTDOWN</code> 状态，不再接受新的任务，已有的任务继续执行</li>
<li>shutdownNow<br>设置为 <code>STOP</code> 状态，不再接受新的任务，尝试停止所有正在执行的任务（设置中断），返回还未执行的任务队列</li>
</ol>
<h2 id="线程池有哪些拒绝策略"><a href="#线程池有哪些拒绝策略" class="headerlink" title="线程池有哪些拒绝策略"></a>线程池有哪些拒绝策略</h2><p>拒绝策略是实现 <code>RejectedExecutionHandler</code> 接口。内部有以下几种实现  </p>
<ol>
<li>AbortPolicy 抛 <code>RejectedExecutionException</code> 异常， 这个是默认的</li>
<li>DiscardPolicy  啥事也不做，默默的丢到任务</li>
<li>DiscardOldestPolicy  丢到队列头部的任务，也就是最老（早）的任务</li>
<li>CallerRunsPolicy 直接在调用线程执行任务</li>
</ol>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>线程池</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>centos 安装 ES</title>
    <url>/2019/11/22/centos-%E5%AE%89%E8%A3%85-ES/</url>
    <content><![CDATA[<p>记录一下 <code>centos7</code> 下的 <code>ES</code> 安装<br>首先需要安装 <code>jdk</code><br><code>centos7</code> 里面默认安装了 <code>openjdk</code> 替换为 <code>hotspot</code> 的 <code>jdk</code><br>首先卸载<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo rpm --nodeps $(rpm -qa | grep java)</span><br><span class="line">sudo rpm --nodeps $(rpm -qa | grep jdk)</span><br></pre></td></tr></table></figure></p>
<p>然后使用一下命令，没有 <code>java</code> 信息，就说明卸载干净了<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rpm -qa|grep java</span><br><span class="line">rpm -qa|grep jdk</span><br></pre></td></tr></table></figure></p>
<p>下载 <code>rpm</code> 的 <code>jdk</code> 包，可以去华为的镜像站去下载<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://repo.huaweicloud.com/java/jdk/8u202-b08/jdk-8u202-linux-x64.rpm</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">然后安装  </span><br><span class="line">```sh</span><br><span class="line">sudo rpm -ivh jdk-8u202-linux-x64.rpm</span><br></pre></td></tr></table></figure></p>
<p>验证是否安装成功<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure></p>
<p>现在，需要下载 <code>ES</code> 了<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.huaweicloud.com/elasticsearch/6.8.5/elasticsearch-6.8.5.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>解压<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar zxvf elasticsearch-6.8.5.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>到 bin 目录启动<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> elasticsearch-6.8.5/bin</span><br><span class="line">./elasticsearch</span><br></pre></td></tr></table></figure></p>
<p>可以看到启动日志，当然，也可能启动失败，<code>ES</code> 不能用 <code>root</code> 用户启动，因此，需要添加一个普通用户<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">groupadd elsearch</span><br><span class="line">useradd elsearch -g elsearch -p elasticsearch</span><br></pre></td></tr></table></figure></p>
<p>然后需要修改 <code>elasticsearch</code> 文件夹的所属用户,注意执行命令的目录，在解压的 <code>elasticsearch-6.8.5</code> 父目录<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo chown -R elsearch:elsearch elasticsearch</span><br></pre></td></tr></table></figure></p>
<p>然后切换到 <code>elsearch</code> 用户再启动<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">su elsearch</span><br><span class="line">./elasticsearch</span><br></pre></td></tr></table></figure></p>
<p>想后台启动，使用<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./elasticsearch -d</span><br></pre></td></tr></table></figure></p>
<p>验证 <code>ES</code> 启动是否成功，访问<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl <span class="string">'http://localhost:9200?pretty'</span></span><br></pre></td></tr></table></figure></p>
<p>看到返回结果，就是启动成功了  </p>
<p>目前 <code>ES</code> 只能本机访问，如果需要外网访问，需要修改配置  <code>config/elasticsearch.yml</code><br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><br>或者使用指定的 <code>ip</code></p>
<p>然后启动。<br>可能会报错，因为 ES 这时候开启了启动检测。一些系统参数可能需要修改<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo sysctl -w vm.max_map_count=262144</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>安装</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>删除排序数组中的重复项</title>
    <url>/2019/11/21/leetcode/26/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 <code>O(1)</code> 额外空间的条件下完成。</p>
<p><em>示例1</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p>
<p><em>示例2</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>简单问题，就是相同的元素往前堆叠就可以了<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	index := <span class="number">0</span></span><br><span class="line">	<span class="built_in">len</span> := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span> &lt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i - <span class="number">1</span>] &lt; nums[i] &#123;</span><br><span class="line">			nums[index] = nums[i - <span class="number">1</span>]</span><br><span class="line">			index++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	nums[index] = nums[<span class="built_in">len</span> - <span class="number">1</span>]</span><br><span class="line">	index++</span><br><span class="line">	nums = nums[:index]</span><br><span class="line">	<span class="keyword">return</span> index</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>四数之和</title>
    <url>/2019/11/20/leetcode/18/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个包含 <code>n</code> 个整数的数组 <code>nums</code> 和一个目标值 <code>target</code>，判断 nums 中是否存在四个元素 <code>a，b，c</code> 和 <code>d</code> ，使得 <code>a + b + c + d</code> 的值与 <code>target</code> 相等？找出所有满足条件且不重复的四元组。<br><em>注意：</em><br>答案中不可以包含重复的四元组。</p>
<p>示例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</span><br><span class="line"></span><br><span class="line">满足要求的四元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>暴力解法<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fourSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> result [][]<span class="keyword">int</span></span><br><span class="line">	<span class="built_in">len</span> := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span> &lt; <span class="number">4</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 先排序</span></span><br><span class="line">	sort.Ints(nums);</span><br><span class="line">	<span class="comment">// 暴力解法</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span><span class="number">-3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> ;i!=<span class="number">0</span> &amp;&amp; i &lt; <span class="built_in">len</span> - <span class="number">3</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>];i++&#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span><span class="number">-2</span>;j++ &#123;</span><br><span class="line">			<span class="keyword">for</span> ;j!=i+<span class="number">1</span> &amp;&amp; j &lt; <span class="built_in">len</span><span class="number">-2</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>];j++&#123;&#125;</span><br><span class="line">			<span class="keyword">for</span> k := j+<span class="number">1</span>; k &lt; <span class="built_in">len</span> <span class="number">-1</span>;k++ &#123;</span><br><span class="line">				<span class="keyword">for</span> ; k != j+<span class="number">1</span> &amp;&amp; k &lt; <span class="built_in">len</span> - <span class="number">1</span>&amp;&amp; nums[k]==nums[k<span class="number">-1</span>];k++&#123;&#125;</span><br><span class="line">				<span class="keyword">for</span> l := k+<span class="number">1</span>; l &lt; <span class="built_in">len</span>; l++ &#123;</span><br><span class="line">					sum := nums[i] + nums[j] + nums[k] + nums[l]</span><br><span class="line">					<span class="keyword">if</span> sum == target &#123;</span><br><span class="line">						result = <span class="built_in">append</span>(result, []<span class="keyword">int</span>&#123;nums[i], nums[j], nums[k], nums[l]&#125;)</span><br><span class="line">						<span class="keyword">break</span></span><br><span class="line">					&#125; <span class="keyword">else</span> <span class="keyword">if</span> sum &gt; target&#123;</span><br><span class="line">						<span class="keyword">break</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>基于上面的，结合 <code>a + b = target</code> 的双指针思路<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fourSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> result [][]<span class="keyword">int</span></span><br><span class="line">	<span class="built_in">len</span> := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span> &lt; <span class="number">4</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Ints(nums)</span><br><span class="line">	<span class="comment">// 暴力解法扩展,内部使用 a + b = target 的双向指针解法</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span><span class="number">-3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> ; i != <span class="number">0</span> &amp;&amp; i &lt; <span class="built_in">len</span><span class="number">-3</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]; i++ &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span><span class="number">-2</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">for</span> ; j != i+<span class="number">1</span> &amp;&amp; j &lt; <span class="built_in">len</span><span class="number">-2</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>]; j++ &#123;</span><br><span class="line">			&#125;</span><br><span class="line">			firstIndex := j + <span class="number">1</span></span><br><span class="line">			lastIndex := <span class="built_in">len</span> - <span class="number">1</span></span><br><span class="line">			expect := target - nums[i] - nums[j]</span><br><span class="line">			<span class="keyword">for</span> firstIndex &lt; lastIndex &#123;</span><br><span class="line">				first := nums[firstIndex]</span><br><span class="line">				last := nums[lastIndex]</span><br><span class="line">				sum := first + last</span><br><span class="line">				<span class="keyword">if</span> sum &gt; expect &#123;</span><br><span class="line">					lastIndex--</span><br><span class="line">					<span class="keyword">for</span> ; firstIndex &lt; lastIndex &amp;&amp; nums[lastIndex] == nums[lastIndex+<span class="number">1</span>]; lastIndex-- &#123;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> sum &lt; expect &#123;</span><br><span class="line">					firstIndex++</span><br><span class="line">					<span class="keyword">for</span> ; firstIndex &lt; lastIndex &amp;&amp; nums[firstIndex] == nums[firstIndex<span class="number">-1</span>]; firstIndex++ &#123;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					result = <span class="built_in">append</span>(result, []<span class="keyword">int</span>&#123;nums[i], nums[j], first, last&#125;)</span><br><span class="line">					lastIndex--</span><br><span class="line">					<span class="keyword">for</span> ; firstIndex &lt; lastIndex &amp;&amp; nums[lastIndex] == nums[lastIndex+<span class="number">1</span>]; lastIndex-- &#123;</span><br><span class="line">					&#125;</span><br><span class="line">					firstIndex++</span><br><span class="line">					<span class="keyword">for</span> ; firstIndex &lt; lastIndex &amp;&amp; nums[firstIndex] == nums[firstIndex<span class="number">-1</span>]; firstIndex++ &#123;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>最接近的三数之和</title>
    <url>/2019/11/19/leetcode/16/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个包括 <code>n</code> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</span><br><span class="line"></span><br><span class="line">与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure></p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>最简单的肯定还是暴力解法，时间复杂度是 O(n <em> n </em> n)<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSumClosest</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	minLen := math.MaxInt64</span><br><span class="line">	result := <span class="number">0</span></span><br><span class="line">	<span class="built_in">len</span> := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="comment">// 暴力解法</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span> - <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span> - <span class="number">1</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">for</span> k := j + <span class="number">1</span>; k &lt; <span class="built_in">len</span>; k++ &#123;</span><br><span class="line">				sum := nums[i] + nums[j] + nums[k]</span><br><span class="line">				abs := abs(sum, target)</span><br><span class="line">				<span class="keyword">if</span> abs == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> sum</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> abs &lt; minLen &#123;</span><br><span class="line">					minLen = abs</span><br><span class="line">          result = sum</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a - b</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> b - a</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>还是像之前的题目，一样，先排序 O(n<em>logn) ，然后固定前面一位，然后前后指针寻找 O(n </em> n) ,总共 O(n * n),当然，里面还有一些细节可以优化。<br>譬如说，类似二分之类的，目前还是一位一位寻找的<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSumClosest</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	result := <span class="number">0</span></span><br><span class="line">	<span class="comment">// 先排序</span></span><br><span class="line">	sort.Ints(nums)</span><br><span class="line"></span><br><span class="line">	minLen := math.MaxInt64</span><br><span class="line">	<span class="built_in">len</span> := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span> - <span class="number">2</span>; i++ &#123;</span><br><span class="line">		first := i + <span class="number">1</span></span><br><span class="line">		last := <span class="built_in">len</span> - <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> ; first &lt; last; &#123;</span><br><span class="line">			sum := nums[i] + nums[first] + nums[last]</span><br><span class="line">			<span class="keyword">if</span> sum &lt; target &#123;</span><br><span class="line">				abs := target - sum</span><br><span class="line">				<span class="keyword">if</span> abs &lt; minLen &#123;</span><br><span class="line">					minLen = abs</span><br><span class="line">					result = sum</span><br><span class="line">				&#125;</span><br><span class="line">				first++</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> sum &gt; target &#123;</span><br><span class="line">				abs := sum - target</span><br><span class="line">				<span class="keyword">if</span> abs &lt; minLen &#123;</span><br><span class="line">					minLen = abs</span><br><span class="line">					result = sum</span><br><span class="line">				&#125;</span><br><span class="line">				last--</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> sum</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和</title>
    <url>/2019/11/18/leetcode/15/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <code>a，b，c</code> ，使得 <code>a + b + c = 0</code> ？找出所有满足条件且不重复的三元组。<br><em>注意：</em>答案中不可以包含重复的三元组。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>暴力解法，3遍 for 循环，但是，不能包含重复的三元组这个条件不好满足<br>继续想，之前又 a + b = target ，那么，我们固定，其实，这里也是满足的 a + b = -c 的模式<br>重复问题，只能用 hash 解决了，但是，我们可以通过先排序，然后去掉同样的元素就可以了，排序的时间复杂度为 O(nlogn) ,是可以接受的。 </p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> result [][]<span class="keyword">int</span></span><br><span class="line">	<span class="built_in">len</span> := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span> &lt; <span class="number">3</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 先排序</span></span><br><span class="line">	sort.Ints(nums)</span><br><span class="line">	<span class="comment">// 全部大于0 或者小于0，就没有结果</span></span><br><span class="line">	<span class="keyword">if</span> nums[<span class="number">0</span>] &gt; <span class="number">0</span> || nums[<span class="built_in">len</span> - <span class="number">1</span>] &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span> - <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 第一个数  &gt; 0 那就没有了</span></span><br><span class="line">		<span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 同样的数，不需要重复找</span></span><br><span class="line">		<span class="keyword">if</span> i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 固定第一位数，然后前后分别找，类似 寻找数组里面 a + b = target 一样</span></span><br><span class="line">		first := i + <span class="number">1</span></span><br><span class="line">		last := <span class="built_in">len</span> - <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> ;first &lt; last &amp;&amp; nums[last] &gt;= <span class="number">0</span>; &#123;</span><br><span class="line">			exp := nums[first] + nums[last] + nums[i]</span><br><span class="line">			<span class="keyword">if</span> exp &lt; <span class="number">0</span> &#123;</span><br><span class="line">				first++</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> exp &gt; <span class="number">0</span>&#123;</span><br><span class="line">				last--</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				line := []<span class="keyword">int</span>&#123;nums[i], nums[first], nums[last]&#125;</span><br><span class="line">				result = <span class="built_in">append</span>(result, line)</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 这里剔除重复的</span></span><br><span class="line">				<span class="keyword">for</span> first++ ; first &lt; last &amp;&amp; nums[first - <span class="number">1</span>] == nums[first]; first++&#123;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span> last-- ; first &lt; last &amp;&amp; nums[last + <span class="number">1</span>] == nums[last]; last--&#123;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>盛最多水的容器</title>
    <url>/2019/11/17/leetcode/11/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>说明： 你不能倾斜容器，且 n 的值至少为 2。</p>
<p>示例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出: 49</span><br></pre></td></tr></table></figure></p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>暴力解法<br>没啥思路可言，直接穷举了</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="built_in">len</span> := <span class="built_in">len</span>(height)</span><br><span class="line">	result := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++ &#123;</span><br><span class="line">		first := height[i]</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>; j++ &#123;</span><br><span class="line">			second := height[j]</span><br><span class="line">			h := min(first, second)</span><br><span class="line">			w := j - i</span><br><span class="line">			m := h * w</span><br><span class="line">			<span class="keyword">if</span> m &gt; result &#123;</span><br><span class="line">				result = m</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>从两侧开始，这样 width 最大，选择一个 height 最大的就行了。然后依次遍历，谁小，就从哪边开始减小下标</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 从两侧开始，这样 width 最大，选择一个 height 最大的就行了。然后依次遍历，谁小，就从哪边开始减小下标</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	result := <span class="number">0</span></span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	j := <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> ;i &lt; j; &#123;</span><br><span class="line">		left := height[i]</span><br><span class="line">		right := height[j]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> left &lt;= right &#123;</span><br><span class="line">			m = left * (j - i)</span><br><span class="line">			i++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			m = right * (j - i)</span><br><span class="line">			j--</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> m &gt; result &#123;</span><br><span class="line">			result = m</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找两个有序数组的中位数</title>
    <url>/2019/11/16/leetcode/4/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定两个大小为 m 和 n 的 <em>有序</em> 数组 <code>nums1</code> 和 <code>nums2</code>。<br>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 <code>O(log(m + n))</code>。  </p>
<p><em>示例1</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure></p>
<p><em>示例2</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure></p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>先不管时间复杂度，先求出结果，最简单的就是先排好序，然后取中间值，由于是两个有序数组，排序只需要 <code>O(m + n)</code> </p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">  <span class="comment">// 简单的方法，合并两个有序数组，取中位数，不过不满足题目要求，时间复杂度 O（m + n）</span></span><br><span class="line">	mergeArr := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> i, j <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> ;i &lt; <span class="built_in">len</span>(nums1) &amp;&amp; j &lt; <span class="built_in">len</span>(nums2); &#123;</span><br><span class="line">		first := nums1[i]</span><br><span class="line">		second := nums2[j]</span><br><span class="line">		<span class="keyword">if</span> first &lt; second &#123;</span><br><span class="line">			mergeArr = <span class="built_in">append</span>(mergeArr, first)</span><br><span class="line">			i++</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> first &gt; second &#123;</span><br><span class="line">			mergeArr = <span class="built_in">append</span>(mergeArr, second)</span><br><span class="line">			j++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			mergeArr = <span class="built_in">append</span>(mergeArr, first)</span><br><span class="line">			mergeArr = <span class="built_in">append</span>(mergeArr, second)</span><br><span class="line">			i++</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(nums1); i++ &#123;</span><br><span class="line">		mergeArr = <span class="built_in">append</span>(mergeArr, nums1[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> ; j &lt; <span class="built_in">len</span>(nums2); j++ &#123;</span><br><span class="line">		mergeArr = <span class="built_in">append</span>(mergeArr, nums2[j])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">len</span> := <span class="built_in">len</span>(mergeArr)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span> % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">		mid := mergeArr[<span class="built_in">len</span>/<span class="number">2</span> - <span class="number">1</span>] + mergeArr[<span class="built_in">len</span>/<span class="number">2</span>]</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">float64</span>(mid) / <span class="number">2</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">float64</span>(mergeArr[<span class="built_in">len</span> / <span class="number">2</span>])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>是基于思路1的扩展，我们的目的是找到中位数，也就是第 k 位，不需要排序<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">  <span class="comment">// 基于上面都方法，我们不需要合并，只是找出中位数就可以了，时间复杂度 O（m + n）</span></span><br><span class="line">	aLen := <span class="built_in">len</span>(nums1)</span><br><span class="line">	bLen := <span class="built_in">len</span>(nums2)</span><br><span class="line">	<span class="built_in">len</span> := aLen + bLen</span><br><span class="line">	<span class="keyword">var</span> i, j, left, right <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> index := <span class="number">0</span>; index &lt;= <span class="built_in">len</span> / <span class="number">2</span>; index++ &#123;</span><br><span class="line">		left = right</span><br><span class="line">		<span class="keyword">if</span> i &lt; aLen &amp;&amp; (j &gt;= bLen || nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">			right = nums1[i]</span><br><span class="line">			i++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			right = nums2[j]</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span> &amp; <span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">float64</span>(left) + <span class="keyword">float64</span>(right)) / <span class="number">2</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">float64</span>(right)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面两个看的题解。。</p>
<h3 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h3><p>上面两个的数据复杂度都不满足题目要求。<br>看到 <code>log</code> 都时间复杂度，应该就要想到 <code>二分法</code>,还是上面都思路，思路2，是一位一位排除的。<br>如果我们取第 K 位，那么，我们可以在两个数组里面各自取 k/2位，比较大小后，就可以直接排除掉 k/2了<br>当然，里面有特例情况，k/2 长度超过了数组 len，那么就取最后一位就行了<br>如果其中一个数组空了，那么也好处理,直接取剩余数组的中位数就行了<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="comment">// 上面两个解法都不满足题目要求，log（m + n） 基本确定需要二分法</span></span><br><span class="line">	<span class="comment">// 根据上一个思路，我们是要在排序好第数组里面，找到第 k 个数，如果是一个数组，那么好说，直接二分查找</span></span><br><span class="line">	<span class="comment">// 但是上面是两个数组，我们也可以借鉴一些思路</span></span><br><span class="line">	<span class="comment">// 譬如，我们要找第 k 个数，那么，同时在两个数组找 k/2 ，如果这个长度大于数组长度，取最后一个</span></span><br><span class="line">	<span class="comment">// 比较两个数组里面找的值，谁小，就相当于把 前面的都剔除掉了</span></span><br><span class="line"></span><br><span class="line">	n := <span class="built_in">len</span>(nums1)</span><br><span class="line">	m := <span class="built_in">len</span>(nums2)</span><br><span class="line">	left := (n + m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	right := (n + m + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。</span></span><br><span class="line">	v1 := findMid(&amp;nums1, <span class="number">0</span>, n - <span class="number">1</span>, &amp;nums2, <span class="number">0</span>, m - <span class="number">1</span>, left)</span><br><span class="line">	v2 := findMid(&amp;nums1, <span class="number">0</span>, n - <span class="number">1</span>, &amp;nums2, <span class="number">0</span>, m - <span class="number">1</span>, right)</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">float64</span>(v1) + <span class="keyword">float64</span>(v2)) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMid</span><span class="params">(nums1 *[]<span class="keyword">int</span>, start1, end1 <span class="keyword">int</span>, nums2 *[]<span class="keyword">int</span>, start2, end2 <span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	len1 := end1 - start1 + <span class="number">1</span>;</span><br><span class="line">	len2 := end2 - start2 + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 	确保 nums 先遍历完</span></span><br><span class="line">	<span class="keyword">if</span> len1 &gt; len2 &#123;</span><br><span class="line">		<span class="keyword">return</span> findMid(nums2, start2, end2, nums1, start1, end1, k)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 当 num1 遍历完，其实就是在 nums2 里面找 第 k 个数</span></span><br><span class="line">	<span class="keyword">if</span> len1 == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (*nums2)[start2 + k - <span class="number">1</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找 第 1 个</span></span><br><span class="line">	<span class="keyword">if</span> k == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> min((*nums1)[start1], (*nums2)[start2])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 取每个数组第 k/2 位数，如果 len 小于 k/2 那就是最后一个数</span></span><br><span class="line">	i := start1 + min(len1, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">	j := start2 + min(len2, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 排除掉小的</span></span><br><span class="line">	<span class="keyword">if</span> (*nums1)[i] &gt; (*nums2)[j] &#123;</span><br><span class="line">		<span class="keyword">return</span> findMid(nums1, start1, end1, nums2, j + <span class="number">1</span>, end2, k - (j - start2 + <span class="number">1</span>));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> findMid(nums1, i + <span class="number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="思路4"><a href="#思路4" class="headerlink" title="思路4"></a>思路4</h3><p>什么是中位数，就是一个集合里面，比它小的数量和比它大的数量相同。<br>其实刚看到这题，最想当然的想法就是，取两个数组的中位数，然后平均。。。<br>这想法当然是有问题的，但是思路是木有问题的。首先，满足两边的数量相同，但是没满足大小的比较<br>用图形化的想法，我们将两个数组各自劈成两半，左边是一组，右边是一组，始终保证这个条件下，想办法满足大小条件。<br>怎么满足呢？假设 数组1 的分割位是 i ，数组2 的分割位是 j，只要 i+1 ，j-1 ，这样就可以满足数量不变，去尝试满足大小条件<br>反过来 i-1， j+1 。那么怎么去满足大小关系？左边的最大值 <code>&lt;=</code> 右边的最小值就行了<br>假设数组1 为 A ，数组2 为 B ，那么，只涉及到4位数的比较 <code>A[i - 1], A[i], B[j - 1], B[j]</code><br>又因为 A，B 是有序的，我们只需要比较 <code>A[i-1] &lt;= B[j]  B[j-1] &lt;= A[i]</code> 就行了.<br>然后就是边界条件，具体的可以去看题解<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">len</span>(nums1)</span><br><span class="line">	n := <span class="built_in">len</span>(nums2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保证 m &lt;= n</span></span><br><span class="line">	<span class="keyword">if</span> m &gt; n &#123;</span><br><span class="line">		<span class="keyword">return</span> findMedianSortedArrays(nums2, nums1)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	iMin := <span class="number">0</span></span><br><span class="line">	iMax := m</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ;iMin &lt;= iMax; &#123;</span><br><span class="line">		i := (iMin + iMax) / <span class="number">2</span></span><br><span class="line">		j := (m + n + <span class="number">1</span>)/ <span class="number">2</span> - i</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> j != <span class="number">0</span> &amp;&amp; i != m &amp;&amp; nums2[j<span class="number">-1</span>] &gt; nums1[i] &#123; <span class="comment">// i 需要增大</span></span><br><span class="line">			iMin = i + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> i != <span class="number">0</span> &amp;&amp; j != n &amp;&amp; nums1[i<span class="number">-1</span>] &gt; nums2[j] &#123; <span class="comment">// i 需要减小</span></span><br><span class="line">			iMax = i - <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 达到要求，并且将边界条件列出来单独考虑</span></span><br><span class="line">			maxLeft := <span class="number">0</span></span><br><span class="line">			<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">				maxLeft = nums2[j<span class="number">-1</span>]</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> j == <span class="number">0</span> &#123;</span><br><span class="line">				maxLeft = nums1[i<span class="number">-1</span>]</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				maxLeft = max(nums1[i<span class="number">-1</span>], nums2[j<span class="number">-1</span>])</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 奇数的话，就不需要考虑右半部分了</span></span><br><span class="line">			<span class="keyword">if</span> (m + n) % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">float64</span>(maxLeft)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			minRight := <span class="number">0</span></span><br><span class="line">			<span class="keyword">if</span> i == m &#123;</span><br><span class="line">				minRight = nums2[j]</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> j == n &#123;</span><br><span class="line">				minRight = nums1[i]</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				minRight = min(nums1[i], nums2[j])</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> (<span class="keyword">float64</span>(maxLeft) + <span class="keyword">float64</span>(minRight)) / <span class="number">2</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>sentinel 学习-下</title>
    <url>/2019/11/14/sentinel-%E5%AD%A6%E4%B9%A0-%E4%B8%8B/</url>
    <content><![CDATA[<p>上篇主要学习了怎么用 <code>sentinel</code><br>这篇主要简单的进入源码瞅瞅 <code>sentinel</code> 的结构  </p>
<p>上篇中，可以看到，限流操作的基本代码结构为<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Entry entry = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ContextUtil.enter(target, origin);</span><br><span class="line">  entry = SphU.entry(resourceName);</span><br><span class="line">&#125; <span class="keyword">catch</span> (BlockException e) &#123;</span><br><span class="line">   <span class="comment">// 限流处理</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">      entry.exit();</span><br><span class="line">  &#125;</span><br><span class="line">  ContextUtil.exit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只不过，在使用的时候，基于 <code>aop</code> 获取拦截器，屏蔽掉类似这样的模板代码<br>那么，这段代码里面到底发生了什么呢？  </p>
<p>先看整个调用图  </p>
<img src="/2019/11/14/sentinel-%E5%AD%A6%E4%B9%A0-%E4%B8%8B/sentinel.svg" class="" title="This is an example image">
<h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><p>这里面需要关注的几个类或接口</p>
<ol>
<li>Context</li>
<li>Node</li>
<li>Entry</li>
<li>ProcessorSlotChain</li>
<li>ProcessorSlot</li>
</ol>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>每次调用 <code>entry</code> 获取资源<br>首先获取 <code>Context</code>，这是一个 <code>ThreadLocal</code> 变量，线程绑定变量</p>
<p>包含以下信息</p>
<ol>
<li>上下文名称 <code>name</code></li>
<li>当前调用树的入口节点  <code>entranceNode</code></li>
<li>当前处理的 <code>Entry</code></li>
<li>来源信息 <code>origin</code> 通常跨越系统调用才有</li>
<li>异步表示 <code>async</code> </li>
</ol>
<p>一般，可以通过 <code>ContextUtil</code> 来设置 <code>contextName</code> 和 <code>origin</code><br>如果没，则使用默认的上下文  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Context context = ContextUtil.getContext();</span><br><span class="line"><span class="keyword">if</span> (context <span class="keyword">instanceof</span> NullContext) &#123;</span><br><span class="line">    <span class="comment">// The &#123;@link NullContext&#125; indicates that the amount of context has exceeded the threshold,</span></span><br><span class="line">    <span class="comment">// so here init the entry only. No rule checking will be done.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CtEntry(resourceWrapper, <span class="keyword">null</span>, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Using default context.</span></span><br><span class="line">    context = InternalContextUtil.internalEnter(Constants.CONTEXT_DEFAULT_NAME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同一个资源可以对应不同的上下文，以此来区分不同的场景，这样，不同场景的调用可以独立统计<br>每个 <code>contextName</code> 会生成一个 <code>EntranceNode</code> 挂在 <code>Constants.ROOT.addChild(node);</code> 子节点</p>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>节点，是内部的统计单元，根据在内部的作用，有 <code>ClusterNode</code> <code>EntranceNode</code> <code>DefaultNode</code>     </p>
<ol>
<li><code>EntranceNode</code>  是入口节点，通常是外部入口，譬如上面的，每个 contextName 对应的就是入口节点</li>
<li><code>ClusterNode</code>  集群节点，其实算资源的汇总统计节点，上面说个，每个资源，根据 contextName 会独立统计，就是对应下面的 <code>DefaultNode</code>,每个资源的汇总统计，就是这个节点</li>
<li><code>DefaultNode</code> 默认节点，上面说了</li>
</ol>
<p>节点的统计信息将会用于后面的限流规则<br>里面的统计是基于滑动窗口的，实现类为 <code>LeapArray</code><br>这是一个抽象的实现，实现滑动窗口<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeapArray</span><span class="params">(<span class="keyword">int</span> sampleCount, <span class="keyword">int</span> intervalInMs)</span> </span>&#123;</span><br><span class="line">    AssertUtil.isTrue(sampleCount &gt; <span class="number">0</span>, <span class="string">"bucket count is invalid: "</span> + sampleCount);</span><br><span class="line">    AssertUtil.isTrue(intervalInMs &gt; <span class="number">0</span>, <span class="string">"total time interval of the sliding window should be positive"</span>);</span><br><span class="line">    AssertUtil.isTrue(intervalInMs % sampleCount == <span class="number">0</span>, <span class="string">"time span needs to be evenly divided"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.windowLengthInMs = intervalInMs / sampleCount;</span><br><span class="line">    <span class="keyword">this</span>.intervalInMs = intervalInMs;</span><br><span class="line">    <span class="keyword">this</span>.sampleCount = sampleCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.array = <span class="keyword">new</span> AtomicReferenceArray&lt;&gt;(sampleCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>intervalInMs 代表每个窗口时间<br>sampleCount  代表将窗口时间划分为多少分，越多越平滑，性能也越差</p>
<p><code>sentinel</code> 内部，秒级窗口,默认是 2 1000<br>也就是内部将1s 划分为 2 个  500 ms  统计    </p>
<p>具体实现有 <code>BucketLeapArray</code> <code>OccupiableBucketLeapArray</code>    </p>
<p><code>BucketLeapArray</code>  为普通实现,不支持预占资源<br><code>OccupiableBucketLeapArray</code>  这个在内部维护一个 <code>FutureBucketLeapArray</code> 用来记录未来资源使用情况，来允许预占资源</p>
<h2 id="ProcessorSlotChain-ProcessorSlot"><a href="#ProcessorSlotChain-ProcessorSlot" class="headerlink" title="ProcessorSlotChain ProcessorSlot"></a>ProcessorSlotChain ProcessorSlot</h2><p>处理链 和 处理插槽可以一起看，所有规则都是对应处理插槽处理的。使用 <code>SPI</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SlotChainBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Build the processor slot chain.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a processor slot that chain some slots together</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ProcessorSlotChain <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过实现上面的接口，来构建处理链<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSlotChainBuilder</span> <span class="keyword">implements</span> <span class="title">SlotChainBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProcessorSlotChain <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProcessorSlotChain chain = <span class="keyword">new</span> DefaultProcessorSlotChain();</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> NodeSelectorSlot());</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> ClusterBuilderSlot());</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> LogSlot());</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> StatisticSlot());</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> AuthoritySlot());</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> SystemSlot());</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> FlowSlot());</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> DegradeSlot());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> chain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>默认的实现，这里的 <code>Slot</code> 是限流的规则处理  </p>
<h3 id="NodeSelectorSlot"><a href="#NodeSelectorSlot" class="headerlink" title="NodeSelectorSlot"></a>NodeSelectorSlot</h3><p>这个插槽记录调用链，设置当前的 node<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node 记录统计信息，因此需要缓存</span></span><br><span class="line"> DefaultNode node = map.get(context.getName());</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            node = map.get(context.getName());</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node = <span class="keyword">new</span> DefaultNode(resourceWrapper, <span class="keyword">null</span>);</span><br><span class="line">                HashMap&lt;String, DefaultNode&gt; cacheMap = <span class="keyword">new</span> HashMap&lt;String, DefaultNode&gt;(map.size());</span><br><span class="line">                cacheMap.putAll(map);</span><br><span class="line">                cacheMap.put(context.getName(), node);</span><br><span class="line">                map = cacheMap;</span><br><span class="line">                <span class="comment">// 构建调用树</span></span><br><span class="line">                <span class="comment">// Build invocation tree</span></span><br><span class="line">                ((DefaultNode) context.getLastNode()).addChild(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置当前节点</span></span><br><span class="line">    context.setCurNode(node);</span><br><span class="line">    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br></pre></td></tr></table></figure></p>
<h3 id="ClusterBuilderSlot"><a href="#ClusterBuilderSlot" class="headerlink" title="ClusterBuilderSlot"></a>ClusterBuilderSlot</h3><p>构建 <code>ClusterNode</code> 这里每个资源对应一个，可以看到这里就是一个对象<br>这里是本资源的统计汇总<br>然后根据 <code>origin</code> 构建 <code>OriginNode</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (clusterNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (clusterNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Create the cluster node.</span></span><br><span class="line">            clusterNode = <span class="keyword">new</span> ClusterNode(resourceWrapper.getName(), resourceWrapper.getResourceType());</span><br><span class="line">            HashMap&lt;ResourceWrapper, ClusterNode&gt; newMap = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max(clusterNodeMap.size(), <span class="number">16</span>));</span><br><span class="line">            newMap.putAll(clusterNodeMap);</span><br><span class="line">            newMap.put(node.getId(), clusterNode);</span><br><span class="line"></span><br><span class="line">            clusterNodeMap = newMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">node.setClusterNode(clusterNode);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * if context origin is set, we should get or create a new &#123;@link Node&#125; of</span></span><br><span class="line"><span class="comment">    * the specific origin.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="string">""</span>.equals(context.getOrigin())) &#123;</span><br><span class="line">    Node originNode = node.getClusterNode().getOrCreateOriginNode(context.getOrigin());</span><br><span class="line">    context.getCurEntry().setOriginNode(originNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br></pre></td></tr></table></figure></p>
<h3 id="StatisticSlot"><a href="#StatisticSlot" class="headerlink" title="StatisticSlot"></a>StatisticSlot</h3><p><code>LogSlot</code> 就是记录日志的.<br><code>StatisticSlot</code> 是记录统计信息，供后面的规则做决策<br>主要记录通过资源的 <code>succ</code> <code>threadNum</code> <code>blocked</code> 等信息<br>这些信息是在 <code>node</code> 处理</p>
<p>同时会触发<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProcessorSlotEntryCallback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onPass</span><span class="params">(Context context, ResourceWrapper resourceWrapper, T param, <span class="keyword">int</span> count, Object... args)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onBlocked</span><span class="params">(BlockException ex, Context context, ResourceWrapper resourceWrapper, T param, <span class="keyword">int</span> count, Object... args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回调，可以通过 <code>StatisticSlotCallbackRegistry</code> 注册 </p>
<h3 id="限流插槽"><a href="#限流插槽" class="headerlink" title="限流插槽"></a>限流插槽</h3><ol>
<li>AuthoritySlot<br>对应 <code>AuthorityRule</code> 处理黑白名单</li>
<li>SystemSlot<br>对应 <code>SystemRule</code> ,根据系统整体性能指标 cpu 线程 等限流</li>
<li>FlowSlot<br>对应 <code>FlowRule</code>,很多限流规则，处理策略，后面细看</li>
<li>DegradeSlot<br>对应 <code>DegradeRule</code>,这里是熔断规则，满足条件，断开一段时间，然后再次开启</li>
</ol>
<p>上面 <code>FlowSlot</code> 是复杂点，可以集群限流  </p>
<h3 id="FlowSlot"><a href="#FlowSlot" class="headerlink" title="FlowSlot"></a>FlowSlot</h3><p>可以根据 <code>FlowRule</code> 里面的 <code>clusterMode</code> 来判断是本地限流还是集群限流<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPassCheck</span><span class="params">(<span class="comment">/*@NonNull*/</span> FlowRule rule, Context context, DefaultNode node, <span class="keyword">int</span> acquireCount,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    String limitApp = rule.getLimitApp();</span><br><span class="line">    <span class="keyword">if</span> (limitApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 集群限流</span></span><br><span class="line">    <span class="keyword">if</span> (rule.isClusterMode()) &#123;</span><br><span class="line">        <span class="keyword">return</span> passClusterCheck(rule, context, node, acquireCount, prioritized);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 本地限流</span></span><br><span class="line">    <span class="keyword">return</span> passLocalCheck(rule, context, node, acquireCount, prioritized);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里先只看本地检查<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">passLocalCheck</span><span class="params">(FlowRule rule, Context context, DefaultNode node, <span class="keyword">int</span> acquireCount,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 选择使用哪个 Node 里面的统计信息进行决策</span></span><br><span class="line">    <span class="comment">// 之前说过了，有 Cluster 资源总的统计 Origin 根据来源统计 </span></span><br><span class="line">    <span class="comment">// 使用其他相关资源的 Cluster ,或者 根据</span></span><br><span class="line">    Node selectedNode = selectNodeByRequesterAndStrategy(rule, context, node);</span><br><span class="line">    <span class="keyword">if</span> (selectedNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 然后使用限流器决策，这里的限流器又有多个选择</span></span><br><span class="line">    <span class="keyword">return</span> rule.getRater().canPass(selectedNode, acquireCount, prioritized);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个的 <code>getRater()</code> 返回的是 <code>TrafficShapingController</code> </p>
<p>有以下几个实现  </p>
<ol>
<li><code>DefaultController</code> 只有超过设置的阈值，直接拒绝</li>
<li><code>RateLimiterController</code> 均匀限流，固定每个请求之间的最小间隔</li>
<li><code>WarmUpController</code> 预热,缓慢达到预设的最大值</li>
<li><code>WarmUpRateLimiterController</code> 看名字，里面涉及到限流算法</li>
</ol>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>sentinel</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>sentinel 学习-上</title>
    <url>/2019/11/12/sentinel-%E5%AD%A6%E4%B9%A0-%E4%B8%8A/</url>
    <content><![CDATA[<h1 id="sentinel-学习"><a href="#sentinel-学习" class="headerlink" title="sentinel 学习"></a>sentinel 学习</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这是一个 <code>spring-boot-start</code> 模块，依赖了<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在包里面看到 <code>spring.factories</code> ，这里是集成 <code>spring-boot</code> 的入口    </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line">org.springframework.cloud.alibaba.sentinel.SentinelWebAutoConfiguration,\</span><br><span class="line">org.springframework.cloud.alibaba.sentinel.endpoint.SentinelEndpointAutoConfiguration,\</span><br><span class="line">org.springframework.cloud.alibaba.sentinel.custom.SentinelAutoConfiguration,\</span><br><span class="line"><span class="attr">org.springframework.cloud.alibaba.sentinel.feign.SentinelFeignAutoConfiguration</span></span><br><span class="line"></span><br><span class="line"><span class="meta">org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">org.springframework.cloud.alibaba.sentinel.custom.SentinelCircuitBreakerConfiguration</span></span><br></pre></td></tr></table></figure>
<h3 id="SentinelWebAutoConfiguration"><a href="#SentinelWebAutoConfiguration" class="headerlink" title="SentinelWebAutoConfiguration"></a>SentinelWebAutoConfiguration</h3><p>这个配置默认开启，作用是添加了一个 <code>CommonFilter</code><br>这里过滤器的作用是基于 <code>url</code> 的限流   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    HttpServletRequest sRequest = (HttpServletRequest) request;</span><br><span class="line">    Entry entry = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Entry methodEntry = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里是获取 uri  就是排除 contextPath 后面的 uri ，剔除掉 query 参数</span></span><br><span class="line">        String target = FilterUtil.filterTarget(sRequest);</span><br><span class="line">        <span class="comment">// Clean and unify the URL.</span></span><br><span class="line">        <span class="comment">// For REST APIs, you have to clean the URL (e.g. `/foo/1` and `/foo/2` -&gt; `/foo/:id`), or</span></span><br><span class="line">        <span class="comment">// the amount of context and resources will exceed the threshold.</span></span><br><span class="line">        UrlCleaner urlCleaner = WebCallbackManager.getUrlCleaner();</span><br><span class="line">        <span class="comment">// 默认的 UrlCleaner 啥都不做，可以自己做处理， 譬如上面注释里面的路径参数</span></span><br><span class="line">        <span class="keyword">if</span> (urlCleaner != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target = urlCleaner.clean(target);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析 origin 自己配置的 RequestOriginParser 实现，如果没有，默认就是 "" 了</span></span><br><span class="line">        <span class="comment">// Parse the request origin using registered origin parser.</span></span><br><span class="line">        String origin = parseOrigin(sRequest);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里就是限流控制了，context 和 resourceName 都是 uri  类型是 EntryType.IN   ，默认的类型是 OUT</span></span><br><span class="line">        ContextUtil.enter(target, origin);</span><br><span class="line">        entry = SphU.entry(target, EntryType.IN);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否基于 HTTP METHOD 区分 uri</span></span><br><span class="line">        <span class="comment">// Add method specification if necessary</span></span><br><span class="line">        <span class="keyword">if</span> (httpMethodSpecify) &#123;</span><br><span class="line">          <span class="comment">// 如果需要的话，继续请求限流控制</span></span><br><span class="line">            methodEntry = SphU.entry(sRequest.getMethod().toUpperCase() + COLON + target,</span><br><span class="line">                    EntryType.IN);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BlockException e) &#123;</span><br><span class="line">        <span class="comment">// 阻塞了，代表本次请求被限流了，限流的原因有多个，大部分是基于 QPS 的</span></span><br><span class="line">        HttpServletResponse sResponse = (HttpServletResponse) response;</span><br><span class="line">        <span class="comment">// Return the block page, or redirect to another URL.</span></span><br><span class="line">        WebCallbackManager.getUrlBlockHandler().blocked(sRequest, sResponse, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">        Tracer.trace(e2);</span><br><span class="line">        <span class="keyword">throw</span> e2;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServletException e3) &#123;</span><br><span class="line">        Tracer.trace(e3);</span><br><span class="line">        <span class="keyword">throw</span> e3;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e4) &#123;</span><br><span class="line">        Tracer.trace(e4);</span><br><span class="line">        <span class="keyword">throw</span> e4;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (methodEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            methodEntry.exit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            entry.exit();</span><br><span class="line">        &#125;</span><br><span class="line">        ContextUtil.exit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SentinelEndpointAutoConfiguration"><a href="#SentinelEndpointAutoConfiguration" class="headerlink" title="SentinelEndpointAutoConfiguration"></a>SentinelEndpointAutoConfiguration</h3><p>这个配置是对 <code>spring-boot-starter-actuator</code> 的一个扩展。添加了一个 <code>SentinelEndpoint</code>,用来返回展示一些基本配置和规则配置  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ReadOperation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Map&lt;String, Object&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span> (sentinelProperties.isEnabled()) &#123;</span><br><span class="line"></span><br><span class="line">    result.put(<span class="string">"appName"</span>, AppNameUtil.getAppName());</span><br><span class="line">    result.put(<span class="string">"logDir"</span>, LogBase.getLogBaseDir());</span><br><span class="line">    result.put(<span class="string">"logUsePid"</span>, LogBase.isLogNameUsePid());</span><br><span class="line">    result.put(<span class="string">"blockPage"</span>, WebServletConfig.getBlockPage());</span><br><span class="line">    result.put(<span class="string">"metricsFileSize"</span>, SentinelConfig.singleMetricFileSize());</span><br><span class="line">    result.put(<span class="string">"metricsFileCharset"</span>, SentinelConfig.charset());</span><br><span class="line">    result.put(<span class="string">"totalMetricsFileCount"</span>, SentinelConfig.totalMetricFileCount());</span><br><span class="line">    result.put(<span class="string">"consoleServer"</span>, TransportConfig.getConsoleServer());</span><br><span class="line">    result.put(<span class="string">"clientIp"</span>, TransportConfig.getHeartbeatClientIp());</span><br><span class="line">    result.put(<span class="string">"heartbeatIntervalMs"</span>, TransportConfig.getHeartbeatIntervalMs());</span><br><span class="line">    result.put(<span class="string">"clientPort"</span>, TransportConfig.getPort());</span><br><span class="line">    result.put(<span class="string">"coldFactor"</span>, sentinelProperties.getFlow().getColdFactor());</span><br><span class="line">    result.put(<span class="string">"filter"</span>, sentinelProperties.getFilter());</span><br><span class="line">    result.put(<span class="string">"datasource"</span>, sentinelProperties.getDatasource());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, Object&gt; rules = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    result.put(<span class="string">"rules"</span>, rules);</span><br><span class="line">    rules.put(<span class="string">"flowRules"</span>, FlowRuleManager.getRules());</span><br><span class="line">    rules.put(<span class="string">"degradeRules"</span>, DegradeRuleManager.getRules());</span><br><span class="line">    rules.put(<span class="string">"systemRules"</span>, SystemRuleManager.getRules());</span><br><span class="line">    rules.put(<span class="string">"authorityRule"</span>, AuthorityRuleManager.getRules());</span><br><span class="line">    rules.put(<span class="string">"paramFlowRule"</span>, ParamFlowRuleManager.getRules());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SentinelAutoConfiguration"><a href="#SentinelAutoConfiguration" class="headerlink" title="SentinelAutoConfiguration"></a>SentinelAutoConfiguration</h3><p>这个是比较核心的配置，与 <code>spring</code> 集成的 <code>bean</code> 基本都是在这里注册的<br>还有 <code>sentinel</code> 本身的初始化，也在这里执行<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 省略一堆配置</span></span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasText(properties.getServlet().getBlockPage())) &#123;</span><br><span class="line">    WebServletConfig.setBlockPage(properties.getServlet().getBlockPage());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  urlBlockHandlerOptional.ifPresent(WebCallbackManager::setUrlBlockHandler);</span><br><span class="line">  urlCleanerOptional.ifPresent(WebCallbackManager::setUrlCleaner);</span><br><span class="line">  requestOriginParserOptional.ifPresent(WebCallbackManager::setRequestOriginParser);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// earlier initialize</span></span><br><span class="line">  <span class="keyword">if</span> (properties.isEager()) &#123;</span><br><span class="line">    <span class="comment">// 核心，这里使用 SPI 加载 InitFunc 的实现，然后初始</span></span><br><span class="line">    InitExecutor.doInit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持 @SentinelResource 注解的 Aspect 类</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SentinelResourceAspect <span class="title">sentinelResourceAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SentinelResourceAspect();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看名字就知道是处理 RestTemplate 的，支持 @SentinelRestTemplate 注解，可以指定 block 或者 fallback 处理方法</span></span><br><span class="line"><span class="comment">// 参数类型为 HttpRequest.class, byte[].class, ClientHttpRequestExecution.class, BlockException.class </span></span><br><span class="line"><span class="comment">// 返回类型   ClientHttpResponse.class</span></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"><span class="comment">// 然后添加 SentinelProtectInterceptor</span></span><br><span class="line"><span class="comment">// 这里请求外部资源的时候，要经过两个 entry  1. hostResource (httpMethod):(schema)://(host):(port) 2. hostResource + path</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(name = <span class="string">"org.springframework.web.client.RestTemplate"</span>)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(name = <span class="string">"resttemplate.sentinel.enabled"</span>, havingValue = <span class="string">"true"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> SentinelBeanPostProcessor <span class="title">sentinelBeanPostProcessor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SentinelBeanPostProcessor(applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是加载配置规则源，规则可以存放在 naco ，apollo 等地方</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SentinelDataSourceHandler <span class="title">sentinelDataSourceHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SentinelDataSourceHandler(beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规则序列化的地方</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(ObjectMapper<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">protected</span> <span class="title">static</span> <span class="title">class</span> <span class="title">SentinelConverterConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span>(<span class="string">"sentinel-json-flow-converter"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> JsonConverter <span class="title">jsonFlowConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonConverter(objectMapper, FlowRule<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span>(<span class="string">"sentinel-json-degrade-converter"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> JsonConverter <span class="title">jsonDegradeConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonConverter(objectMapper, DegradeRule<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span>(<span class="string">"sentinel-json-system-converter"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> JsonConverter <span class="title">jsonSystemConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonConverter(objectMapper, SystemRule<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span>(<span class="string">"sentinel-json-authority-converter"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> JsonConverter <span class="title">jsonAuthorityConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonConverter(objectMapper, AuthorityRule<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span>(<span class="string">"sentinel-json-param-flow-converter"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> JsonConverter <span class="title">jsonParamFlowConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonConverter(objectMapper, ParamFlowRule<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的 <code>InitExecutor.doInit()</code> 触发的是 <code>sentinel</code> 核心的初始化，后面再看 </p>
<h3 id="SentinelFeignAutoConfiguration"><a href="#SentinelFeignAutoConfiguration" class="headerlink" title="SentinelFeignAutoConfiguration"></a>SentinelFeignAutoConfiguration</h3><p>这里是跟 <code>feign</code> 集成，核心类是 <code>SentinelInvocationHandler</code><br><code>feign</code>,<code>ribbon</code>,<code>hystrix</code> 这里几个是 <code>netflix</code> 的组件，其中 <code>sentinel</code> 替换掉的是 <code>hystrix</code><br>详细的后面梳理完 <code>feign</code> 后再看</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结一下上面的自动配置  </p>
<ol>
<li>系统开放的 <code>rest</code> 接口，根据 <code>path</code> 会过一遍限流（如果区分 <code>http method</code> 则是两遍）</li>
<li>系统注册的 <code>RestTempate</code> 的时候，如果加上了 <code>@SentinelRestTemplate</code> 注解，则会添加拦截器 <code>SentinelProtectInterceptor</code>,经过两个限流</li>
<li>使用 <code>feign</code>，<code>@FeignClient</code> 标记的 <code>bean</code>,这里会经过一层限流</li>
<li>使用 <code>@SentinelResource</code> 注解标记的方法  </li>
</ol>
<p>那么问题来了，限流规则是在哪里配置的呢？  </p>
<p>首先看看 <code>sentinel</code> 支持哪些规则配置  </p>
<h3 id="AuthorityRule"><a href="#AuthorityRule" class="headerlink" title="AuthorityRule"></a>AuthorityRule</h3><p>权限配置，就是配置黑白名单<br>先看下示例配置<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"resource"</span>: <span class="string">"good"</span>,</span><br><span class="line">    <span class="attr">"limitApp"</span>: <span class="string">"abc"</span>,</span><br><span class="line">    <span class="attr">"strategy"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"resource"</span>: <span class="string">"bad"</span>,</span><br><span class="line">    <span class="attr">"limitApp"</span>: <span class="string">"bcd"</span>,</span><br><span class="line">    <span class="attr">"strategy"</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"resource"</span>: <span class="string">"terrible"</span>,</span><br><span class="line">    <span class="attr">"limitApp"</span>: <span class="string">"aaa"</span>,</span><br><span class="line">    <span class="attr">"strategy"</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br>对应的规则类为 <code>AuthorityRule</code>,经过的 <code>slot</code> 为 <code>AuthoritySlot</code><br>其中:</p>
<ol>
<li>resource  为资源名，每个规则都需要配置</li>
<li>limitApp  限制的 app，其实就是针对 <code>origin</code> 来限制的，可以用来限制接入系统，需要提供一个 <code>RequestOriginParser</code> 来获取 <code>origin</code>,如果没有，那么规则配置是无效的</li>
<li>strategy  不同规则配置，含义不一样。这里 0：白名单 1：黑名单</li>
</ol>
<h3 id="SystemRule"><a href="#SystemRule" class="headerlink" title="SystemRule"></a>SystemRule</h3><p>配置示例<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"highestSystemLoad"</span>: <span class="number">-1</span>,</span><br><span class="line">    <span class="attr">"highestCpuUsage"</span>: <span class="number">-1</span>,</span><br><span class="line">    <span class="attr">"qps"</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">"avgRt"</span>: <span class="number">-1</span>,</span><br><span class="line">    <span class="attr">"maxThread"</span>: <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>这里虽然是一个数组，但是配置多个规则其实没啥用，总是使用最小有效配置来判断的<br>经过的 <code>slot</code> 为 <code>SystemSlot</code>,根据系统的负载来限流的，只针对 <code>EntryType.IN</code> 类型才有效，默认的都是 <code>OUT</code>,在 <code>CommonFilter</code> 里面为 <code>IN</code><br>配置含义其实看名字就知道了： </p>
<ol>
<li>highestSystemLoad  系统负载</li>
<li>highestCpuUsage   cpu 使用率</li>
<li>qps 每秒请求数，这里是有效的，被拦截的请求不算在里面</li>
<li>avgRt 平均响应时间</li>
<li>maxThread 当前出现线程数</li>
</ol>
<p>这里开看成应用总的负载限流  </p>
<h3 id="FlowRule"><a href="#FlowRule" class="headerlink" title="FlowRule"></a>FlowRule</h3><p>配置示例：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"resource"</span>: <span class="string">"/hello"</span>,</span><br><span class="line">    <span class="attr">"controlBehavior"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"count"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"grade"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"limitApp"</span>: <span class="string">"default"</span>,</span><br><span class="line">    <span class="attr">"strategy"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"resource"</span>: <span class="string">"/test"</span>,</span><br><span class="line">    <span class="attr">"controlBehavior"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"count"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"grade"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"limitApp"</span>: <span class="string">"default"</span>,</span><br><span class="line">    <span class="attr">"strategy"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"resource"</span>: <span class="string">"GET:http://www.taobao.com"</span>,</span><br><span class="line">    <span class="attr">"controlBehavior"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"count"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"grade"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"limitApp"</span>: <span class="string">"default"</span>,</span><br><span class="line">    <span class="attr">"strategy"</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>这个规则是针对每个资源，独立的限流配置  </p>
<ol>
<li>resource  资源名，可以看上面，默认的资源名生产规则</li>
<li>grade   配置类型，0：线程数量 1：QPS</li>
<li>count   配置数量</li>
<li>strategy  0：用于直接流量控制 默认，1：相关流量控制，2：链流量控制  配置了 1 或者 2，需要配置 refResource,如果配 1，那么直接取对应资源的 ClusterNode，2的话，需要 contextName == refResource</li>
<li>limitApp  这个必须配，默认 default 如果不配，规则不生效，如果不为 default 或者 other 那么，限流配置单独适应 origin 的限流，例如 配置 app1，那么 app1 的请求信息单独记录，也只根据这个记录来限流控制，不需要管资源的整体调用情况</li>
<li>refResource  与 strategy 共同起作用</li>
<li>controlBehavior  限流器的类型 0. default(reject directly), 1. warm up, 2. rate limiter, 3. warm up + rate limiter</li>
</ol>
<p>还有一些其他的，在需要特殊用法的时候再看</p>
<h3 id="DegradeRule"><a href="#DegradeRule" class="headerlink" title="DegradeRule"></a>DegradeRule</h3><p>降级规则<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"resource"</span>: <span class="string">"abc0"</span>,</span><br><span class="line">    <span class="attr">"count"</span>: <span class="number">20.0</span>,</span><br><span class="line">    <span class="attr">"grade"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"passCount"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"timeWindow"</span>: <span class="number">10</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"resource"</span>: <span class="string">"abc1"</span>,</span><br><span class="line">    <span class="attr">"count"</span>: <span class="number">15.0</span>,</span><br><span class="line">    <span class="attr">"grade"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"passCount"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"timeWindow"</span>: <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br>这个规则是用来断路的，当超过配置的规则时间，直接断路 <code>timeWindow</code> 时间后再开启<br>规则配置：</p>
<ol>
<li>resource  资源名</li>
<li>grade     0: 平均响应时间, 1: 异常比例</li>
<li>count     配置的阈值</li>
<li>timeWindow  时间窗口</li>
</ol>
<p>除了上面的规则外，还可以有自定义的规则。。    </p>
<p>刚刚上面的属于本地文件配置，在应用中如下配置<br><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds1.file.file</span>=<span class="string">classpath: flowrule.json</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds1.file.data-type</span>=<span class="string">json</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds1.file.rule-type</span>=<span class="string">flow</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds2.file.file</span>=<span class="string">classpath: degraderule.json</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds2.file.data-type</span>=<span class="string">json</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds2.file.rule-type</span>=<span class="string">degrade</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds3.file.file</span>=<span class="string">classpath: authority.json</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds3.file.rule-type</span>=<span class="string">authority</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds4.file.file</span>=<span class="string">classpath: system.json</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds4.file.rule-type</span>=<span class="string">system</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds5.file.file</span>=<span class="string">classpath: param-flow.json</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds5.file.rule-type</span>=<span class="string">param_flow</span></span><br></pre></td></tr></table></figure></p>
<p>还支持 <code>apollo</code>, <code>nacos</code>, <code>redis</code>, <code>zk</code> 等  </p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>sentinel</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>由 spring-cloud-alibaba sentinel 示例启动失败引起的研究</title>
    <url>/2019/11/12/%E7%94%B1-spring-cloud-alibaba-sentinel-%E7%A4%BA%E4%BE%8B%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E5%BC%95%E8%B5%B7%E7%9A%84%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="问题起因"><a href="#问题起因" class="headerlink" title="问题起因"></a>问题起因</h2><p>在看 <code>sentinel</code> 的时候，写了一个示例，添加以下配置<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sentinel 测试</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="comment"># 名称随意</span></span><br><span class="line">        <span class="attr">ds1:</span></span><br><span class="line">          <span class="attr">file:</span></span><br><span class="line">            <span class="attr">file:</span> <span class="string">"classpath: rules/flowRules.json"</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">flow</span></span><br></pre></td></tr></table></figure></p>
<p>这是一个本地配置文件来配置 <code>sentinel</code> 规则的示例<br>然后启动应用，发现异常  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Failed to bind properties under &apos;spring.cloud.sentinel.datasource.ds1.file.rule-type&apos; to org.springframework.cloud.alibaba.sentinel.datasource.RuleType:</span><br><span class="line"></span><br><span class="line">    Property: spring.cloud.sentinel.datasource.ds1.file.rule-type</span><br><span class="line">    Value: flow</span><br><span class="line">    Origin: class path resource [application.yml]:23:24</span><br><span class="line">    Reason: 2</span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Update your application&apos;s configuration</span><br></pre></td></tr></table></figure>
<p><code>sentinel</code> 的配置类是 <code>SentinelProperties</code>, <code>ruleType</code> 所在类为 <code>AbstractDataSourceProperties</code>,类型为枚举 <code>RuleType</code>  </p>
<p>上面，没有任何异常信息，只是一个绑定错误，我还以为哪里拼写错了。<br>最后实在没办法，直接进 <code>spring</code> 处理 <code>@EnableConfigurationProperties(SentinelProperties.class)</code> 的地方  </p>
<p>在类 <code>ConfigurationPropertiesBindingPostProcessor</code> 的 <code>bind</code> 方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Object bean, String beanName, ConfigurationProperties annotation)</span> </span>&#123;</span><br><span class="line">	ResolvableType type = getBeanType(bean, beanName);</span><br><span class="line">	Validated validated = getAnnotation(bean, beanName, Validated<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	Annotation[] annotations = (validated != <span class="keyword">null</span>)</span><br><span class="line">			? <span class="keyword">new</span> Annotation[] &#123; annotation, validated &#125;</span><br><span class="line">			: <span class="keyword">new</span> Annotation[] &#123; annotation &#125;;</span><br><span class="line">	Bindable&lt;?&gt; target = Bindable.of(type).withExistingValue(bean)</span><br><span class="line">			.withAnnotations(annotations);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.configurationPropertiesBinder.bind(target);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationPropertiesBindException(beanName, bean, annotation,</span><br><span class="line">				ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以根据条件断点，然后在异常那里打印堆栈日志，发现是一个数组越界。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.ArrayIndexOutOfBoundsException: <span class="number">2</span></span><br><span class="line">	at java.lang.reflect.Parameter.getAnnotatedType(Parameter.java:<span class="number">237</span>)</span><br><span class="line">	at org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider.getParameterMetaData(AnnotationMetaDataProvider.java:<span class="number">427</span>)</span><br><span class="line">	at org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider.findExecutableMetaData(AnnotationMetaDataProvider.java:<span class="number">300</span>)</span><br><span class="line">	at org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider.getMetaData(AnnotationMetaDataProvider.java:<span class="number">285</span>)</span><br><span class="line">	at org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider.getConstructorMetaData(AnnotationMetaDataProvider.java:<span class="number">266</span>)</span><br><span class="line">	at org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider.retrieveBeanConfiguration(AnnotationMetaDataProvider.java:<span class="number">135</span>)</span><br><span class="line">	at org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider.getBeanConfiguration(AnnotationMetaDataProvider.java:<span class="number">124</span>)</span><br><span class="line">	at org.hibernate.validator.internal.metadata.BeanMetaDataManager.getBeanConfigurationForHierarchy(BeanMetaDataManager.java:<span class="number">232</span>)</span><br><span class="line">	at org.hibernate.validator.internal.metadata.BeanMetaDataManager.createBeanMetaData(BeanMetaDataManager.java:<span class="number">199</span>)</span><br><span class="line">	at org.hibernate.validator.internal.metadata.BeanMetaDataManager.getBeanMetaData(BeanMetaDataManager.java:<span class="number">166</span>)</span><br><span class="line">	at org.hibernate.validator.internal.engine.ValidatorImpl.validate(ValidatorImpl.java:<span class="number">157</span>)</span><br><span class="line">	at org.springframework.validation.beanvalidation.SpringValidatorAdapter.validate(SpringValidatorAdapter.java:<span class="number">108</span>)</span><br></pre></td></tr></table></figure></p>
<p>但是。越界发生在内部，我也无法干预，为了具体定位越界到底在哪里出现，跟踪调试<br>最后定位到 <code>org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider</code>  的方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;ConstrainedParameter&gt; <span class="title">getParameterMetaData</span><span class="params">(Executable executable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( executable.getParameterCount() == <span class="number">0</span> ) &#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ****  这里返回的构造方法参数是 4 引起了疑惑 ****</span></span><br><span class="line">  Parameter[] parameters = executable.getParameters();</span><br><span class="line"></span><br><span class="line">  List&lt;ConstrainedParameter&gt; metaData = <span class="keyword">new</span> ArrayList&lt;&gt;( parameters.length );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( Parameter parameter : parameters ) &#123;</span><br><span class="line">    Annotation[] parameterAnnotations;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      parameterAnnotations = parameter.getAnnotations();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">      LOG.warn( MESSAGES.constraintOnConstructorOfNonStaticInnerClass(), ex );</span><br><span class="line">      parameterAnnotations = EMPTY_PARAMETER_ANNOTATIONS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;MetaConstraint&lt;?&gt;&gt; parameterConstraints = newHashSet();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( annotationProcessingOptions.areParameterConstraintsIgnoredFor( executable, i ) ) &#123;</span><br><span class="line">      Type type = ReflectionHelper.typeOf( executable, i );</span><br><span class="line">      metaData.add(</span><br><span class="line">          <span class="keyword">new</span> ConstrainedParameter(</span><br><span class="line">              ConfigurationSource.ANNOTATION,</span><br><span class="line">              executable,</span><br><span class="line">              type,</span><br><span class="line">              i,</span><br><span class="line">              parameterConstraints,</span><br><span class="line">              Collections.emptySet(),</span><br><span class="line">              CascadingMetaDataBuilder.nonCascading()</span><br><span class="line">          )</span><br><span class="line">      );</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ConstraintLocation location = ConstraintLocation.forParameter( executable, i );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( Annotation parameterAnnotation : parameterAnnotations ) &#123;</span><br><span class="line">      <span class="comment">// collect constraints if this annotation is a constraint annotation</span></span><br><span class="line">      List&lt;ConstraintDescriptorImpl&lt;?&gt;&gt; constraints = findConstraintAnnotations(</span><br><span class="line">          executable, parameterAnnotation, ElementType.PARAMETER</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">for</span> ( ConstraintDescriptorImpl&lt;?&gt; constraintDescriptorImpl : constraints ) &#123;</span><br><span class="line">        parameterConstraints.add(</span><br><span class="line">            MetaConstraints.create( typeResolutionHelper, valueExtractorManager, constraintDescriptorImpl, location )</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// **** 问题出在这里  ****</span></span><br><span class="line">    AnnotatedType parameterAnnotatedType = parameter.getAnnotatedType();</span><br><span class="line"></span><br><span class="line">    Set&lt;MetaConstraint&lt;?&gt;&gt; typeArgumentsConstraints = findTypeAnnotationConstraintsForExecutableParameter( executable, i, parameterAnnotatedType );</span><br><span class="line">    CascadingMetaDataBuilder cascadingMetaData = findCascadingMetaData( executable, parameters, i, parameterAnnotatedType );</span><br><span class="line"></span><br><span class="line">    metaData.add(</span><br><span class="line">        <span class="keyword">new</span> ConstrainedParameter(</span><br><span class="line">            ConfigurationSource.ANNOTATION,</span><br><span class="line">            executable,</span><br><span class="line">            ReflectionHelper.typeOf( executable, i ),</span><br><span class="line">            i,</span><br><span class="line">            parameterConstraints,</span><br><span class="line">            typeArgumentsConstraints,</span><br><span class="line">            cascadingMetaData</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> metaData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面有两个中文注释，就是问题所在。<br>首先，第一个问题，参数是 4 引起了我的疑惑。我们看下 <code>RuleType</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RuleType &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * flow</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	FLOW(<span class="string">"flow"</span>, FlowRule<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">	/**</span></span><br><span class="line"><span class="class">	 * <span class="title">degrade</span></span></span><br><span class="line"><span class="class">	 */</span></span><br><span class="line">	DEGRADE("degrade", DegradeRule.class),</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * param flow</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	PARAM_FLOW(<span class="string">"param-flow"</span>, ParamFlowRule<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">	/**</span></span><br><span class="line"><span class="class">	 * <span class="title">system</span></span></span><br><span class="line"><span class="class">	 */</span></span><br><span class="line">	SYSTEM("system", SystemRule.class),</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * authority</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	AUTHORITY(<span class="string">"authority"</span>, AuthorityRule<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * alias for &#123;<span class="doctag">@link</span> AbstractRule&#125;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * concrete &#123;<span class="doctag">@link</span> AbstractRule&#125; class</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Class clazz;</span><br><span class="line"></span><br><span class="line">	RuleType(String name, Class clazz) &#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Class <span class="title">getClazz</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> clazz;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;RuleType&gt; <span class="title">getByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">			<span class="keyword">return</span> Optional.empty();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Arrays.stream(RuleType.values())</span><br><span class="line">				.filter(ruleType -&gt; name.equals(ruleType.getName())).findFirst();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;RuleType&gt; <span class="title">getByClass</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Arrays.stream(RuleType.values())</span><br><span class="line">				.filter(ruleType -&gt; clazz == ruleType.getClazz()).findFirst();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只有一个构造方法，两个构造参数，为啥这里是 4 呢？<br>调试的时候可以看到 前面两个参数 ，一个是枚举的 name ,一个是 ordinal 坐标<br>说实话，以前还真没注意这个细节  </p>
<p>继续找问题所在<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotatedType parameterAnnotatedType = parameter.getAnnotatedType();</span><br></pre></td></tr></table></figure></p>
<p>上面就是跑异常的地方<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AnnotatedType <span class="title">getAnnotatedType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// no caching for now</span></span><br><span class="line">    <span class="keyword">return</span> executable.getAnnotatedParameterTypes()[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里已经是 <code>jdk</code> 源码了<br>最后发现，问题在这里 <code>executable.getAnnotatedParameterTypes()</code> 这个方法返回的数组长度为 2<br>但是，我们可以看到，外层是在遍历 <code>executable.getParameters()</code> 这里返回的是 4 个元素，因此越界 </p>
<p>去获取 <code>spring-cloud-alibaba</code> 的源码，运行 <code>sentinel</code> 示例，也出现同样的问题  </p>
<p>写了一个测试例子<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">enum</span> EnumTest &#123;</span><br><span class="line"></span><br><span class="line">    A(<span class="number">0</span>, <span class="string">"A"</span>),</span><br><span class="line"></span><br><span class="line">    B(<span class="number">1</span>, <span class="string">"B"</span>)</span><br><span class="line"></span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String msg;</span><br><span class="line"></span><br><span class="line">    EnumTest(<span class="keyword">int</span> code, String msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">enum</span> Enum2 &#123;</span><br><span class="line">    A</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class="line">    Constructor&lt;?&gt;[] declaredConstructors = aClass.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : declaredConstructors) &#123;</span><br><span class="line">        <span class="keyword">int</span> parameterCount = constructor.getParameterCount();</span><br><span class="line">        System.out.printf(<span class="string">"parameterCount:%s\n"</span>, parameterCount);</span><br><span class="line">        <span class="keyword">int</span> length = constructor.getAnnotatedParameterTypes().length;</span><br><span class="line">        System.out.printf(<span class="string">"length:%s\n"</span>, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        show(EnumTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"---"</span>);</span><br><span class="line">        show(Enum2<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>怀疑可能是 <code>jdk</code> 小版本的问题,目前用的 <code>jdk</code> 版本为 <code>1.8.25</code><br>因此去网上下载一个 <code>1.8.172</code> 发现没有问题<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.8.25    parameterCount = 4,  length = 2</span><br><span class="line">1.8.172   parameterCount = 4,  length = 4</span><br></pre></td></tr></table></figure></p>
<p>到此，问题定位完毕。<br>然而 <code>1.8.25</code> 是公司定的版本。<br>通常搜索查询，这个 bug 在 <code>JDK 1.8.0_40</code> 之后修复了 </p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>sentinel</tag>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2019/11/10/leetcode/1/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p><em>示例</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure></p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>最简单的思路就是两层 <code>for</code> 循环比较。时间复杂度 <code>n * n</code> </p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		first := nums[i]</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">			second := nums[j]</span><br><span class="line">			<span class="keyword">if</span> target == first+second &#123;</span><br><span class="line">				<span class="keyword">return</span> []<span class="keyword">int</span>&#123;i, j&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个思路，使用 <code>map</code> 遍历两次.<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">  ints := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第一遍 记录需要于谁配对，并记录坐标</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">    first := nums[i]</span><br><span class="line">    <span class="comment">// key 是 expect  value 为 坐标</span></span><br><span class="line">		ints[target-first] = i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第二遍 判断当前值是否为别人的预期 利用 map ，访问时间复杂度为 O(1)</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		second := nums[i]</span><br><span class="line">    expect, ok := ints[second]</span><br><span class="line">    <span class="comment">// 注意，坐标不能为 自己</span></span><br><span class="line">		<span class="keyword">if</span> ok &amp;&amp; i != expect &#123;</span><br><span class="line">			<span class="keyword">return</span> []<span class="keyword">int</span>&#123;expect, i&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于上面的思路扩展，由于配对是相互的，因此可以边记录 <code>expect</code> 边判断是否满足条件<br>只用一次遍历<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	ints := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">    first := nums[i]</span><br><span class="line">    <span class="comment">// 判断本值 是否为其他的配对值 ，如果是，就直接返回另</span></span><br><span class="line">		<span class="keyword">if</span> expect, ok := ints[first]; ok &#123;</span><br><span class="line">			<span class="keyword">return</span> []<span class="keyword">int</span>&#123;expect, i&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不是，记录本值 预期的配对值，记录坐标</span></span><br><span class="line">			ints[target-first] = i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 练习</title>
    <url>/2019/11/10/leetcode/0/</url>
    <content><![CDATA[<p>开辟一个新的模块练习算法，准备用 <code>go</code> 语言来写。<br>主要是为了熟悉 <code>go</code> 语言,还有算法，不至于每次看到算法题就完全没有思路。<br>顺序的话，按照不同类型训练，先练习数组类的，目标先订 20 题    </p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>目标</th>
<th>完成</th>
</tr>
</thead>
<tbody>
<tr>
<td>数组</td>
<td>20</td>
<td>20</td>
</tr>
</tbody>
</table>
</div>
<h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>难度</th>
<th>博文</th>
<th>leetcode 地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>数组</td>
<td>简单</td>
<td><a href="/2019/11/10/leetcode/1">两数之和</a></td>
<td><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">两数之和</a></td>
</tr>
<tr>
<td>数组</td>
<td>困难</td>
<td><a href="/2019/11/16/leetcode/4">寻找两个有序数组的中位数</a></td>
<td><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">寻找两个有序数组的中位数</a></td>
</tr>
<tr>
<td>数组</td>
<td>中等</td>
<td><a href="/2019/11/16/leetcode/11">盛最多水的容器</a></td>
<td><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">盛最多水的容器</a></td>
</tr>
<tr>
<td>数组</td>
<td>中等</td>
<td><a href="/2019/11/18/leetcode/15">三数之和</a></td>
<td><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">三数之和</a></td>
</tr>
<tr>
<td>数组</td>
<td>中等</td>
<td><a href="/2019/11/19/leetcode/16">最接近的三数之和</a></td>
<td><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">最接近的三数之和</a></td>
</tr>
<tr>
<td>数组</td>
<td>中等</td>
<td><a href="/2019/11/20/leetcode/18">四数之和</a></td>
<td><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">四数之和</a></td>
</tr>
<tr>
<td>数组</td>
<td>简单</td>
<td><a href="/2019/11/21/leetcode/26">删除排序数组中的重复项</a></td>
<td><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">删除排序数组中的重复项</a></td>
</tr>
<tr>
<td>数组</td>
<td>简单</td>
<td><a href="/2019/11/23/leetcode/27">移除元素</a></td>
<td><a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">移除元素</a></td>
</tr>
<tr>
<td>数组</td>
<td>中等</td>
<td><a href="/2019/11/24/leetcode/31">下一个排列</a></td>
<td><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">下一个排列</a></td>
</tr>
<tr>
<td>数组</td>
<td>中等</td>
<td><a href="/2019/11/26/leetcode/33">搜索旋转排序数组</a></td>
<td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">搜索旋转排序数组</a></td>
</tr>
<tr>
<td>数组</td>
<td>中等</td>
<td><a href="/2019/11/28/leetcode/34">在排序数组中查找元素的第一个和最后一个位置</a></td>
<td><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">在排序数组中查找元素的第一个和最后一个位置</a></td>
</tr>
<tr>
<td>数组</td>
<td>简单</td>
<td><a href="/2019/11/30/leetcode/35">搜索插入位置</a></td>
<td><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">搜索插入位置</a></td>
</tr>
<tr>
<td>数组</td>
<td>中等</td>
<td><a href="/2019/12/01/leetcode/39">组合总和</a></td>
<td><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">组合总和</a></td>
</tr>
<tr>
<td>数组</td>
<td>中等</td>
<td><a href="/2019/12/02/leetcode/40">组合总和II</a></td>
<td><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">组合总和II</a></td>
</tr>
<tr>
<td>数组</td>
<td>困难</td>
<td><a href="/2019/12/04/leetcode/41">缺失的第一个正数</a></td>
<td><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">缺失的第一个正数</a></td>
</tr>
<tr>
<td>数组</td>
<td>困难</td>
<td><a href="/2019/12/08/leetcode/42">接雨水</a></td>
<td><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">接雨水</a></td>
</tr>
<tr>
<td>数组</td>
<td>困难</td>
<td><a href="/2019/12/11/leetcode/45">跳跃游戏 II</a></td>
<td><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">跳跃游戏 II</a></td>
</tr>
<tr>
<td>数组</td>
<td>中等</td>
<td><a href="/2019/12/18/leetcode/48">旋转图像</a></td>
<td><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">旋转图像</a></td>
</tr>
<tr>
<td>数组</td>
<td>中等</td>
<td><a href="/2019/12/24/leetcode/53">最大子序和</a></td>
<td><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">最大子序和</a></td>
</tr>
<tr>
<td>数组</td>
<td>中等</td>
<td><a href="/2019/12/26/leetcode/54">螺旋矩阵</a></td>
<td><a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">螺旋矩阵</a></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>开发笔记</title>
    <url>/2019/11/10/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>这里记录一下之前遇到的开发上的问题  </p>
<h2 id="JPA-的时区问题"><a href="#JPA-的时区问题" class="headerlink" title="JPA 的时区问题"></a>JPA 的时区问题</h2><p>表现为表中的时间字段，在数据库中存储的是 0 时区的（比北京时间少了8小时），查询出来展示没有问题。<br><code>jdbcurl</code> 已经加上了 <code>serverTimezone=GMT%2B8</code>    </p>
<p>最后定位在配置<br><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.jpa.properties.hibernate.jdbc.time_zone</span>=<span class="string">UTC</span></span><br></pre></td></tr></table></figure><br>这个配置，会导致，插入数据库的时候，将时间转换为 0 时区</p>
<h2 id="gson-的泛型处理"><a href="#gson-的泛型处理" class="headerlink" title="gson 的泛型处理"></a>gson 的泛型处理</h2><p>在提交安全测试的时候，被检测到 <code>fastjson</code> 的安全漏洞，之前其实已经暴漏过了，因此，已经调整到版本 <code>1.2.60</code> ，但是不知道为啥又检测到了。<br>当前到最新版本为 <code>1.2.62</code> 。不过，我们只是在打印日志，或者外部对接到时候用到了 <code>fastjson</code>，只是当作一个 <code>jsonutil</code> 来用，<br>因此，为了防止以后又检测出安全漏洞，使用 <code>gson</code> 代替。<br>这里记录一下 <code>gson</code> 的简单用法。主要是泛型相关的。      </p>
<p><em>实例话</em><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Gson();</span><br><span class="line"><span class="keyword">new</span> GsonBuilder().setDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).create();</span><br></pre></td></tr></table></figure></p>
<p><em>序列化</em><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">gson.toJson(request);</span><br></pre></td></tr></table></figure></p>
<p><em>反序列化</em><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本用法  如果暂时不知道内部的具体类型，可以使用 JsonObject</span></span><br><span class="line">fromJson(String json, Class&lt;T&gt; classOfT);</span><br><span class="line"><span class="comment">// 带有泛型的用法 如 List&lt;T&gt;   JsonObject 可以替换为自己的类型</span></span><br><span class="line"><span class="comment">// 这个应该是新版本的，如果在 百度上 搜索，大部分好像是 new TypeToken 的示例</span></span><br><span class="line">gson.fromJson(resp, TypeToken.getParameterized(ArrayList<span class="class">.<span class="keyword">class</span>, <span class="title">JsonObject</span>.<span class="title">class</span>).<span class="title">getType</span>())</span></span><br></pre></td></tr></table></figure></p>
<h2 id="spring-RestTemplate-日志拦截"><a href="#spring-RestTemplate-日志拦截" class="headerlink" title="spring RestTemplate 日志拦截"></a>spring RestTemplate 日志拦截</h2><p>其实可以通过调整日志等级来展示 <code>RestTemplate</code> 的日志,但是我进源码稍微看了一下，只发现打印了请求日志，没有看到响应日志<br>请求日志的打印，也不是我们响应的信息，因此，就加拦截器自己打印日志了。<br>下面的代码，也是参考其他的博文。不过具体是谁的。忘记了。  </p>
<p><em>拦截器</em><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.client.ClientHttpRequestExecution;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.client.ClientHttpRequestInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.client.ClientHttpResponse;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: luolei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/10/24 14:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingRequestInterceptor</span> <span class="keyword">implements</span> <span class="title">ClientHttpRequestInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(LoggingRequestInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">intercept</span><span class="params">(HttpRequest request, <span class="keyword">byte</span>[] body, ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        traceRequest(request, body);</span><br><span class="line">        ClientHttpResponse response = execution.execute(request, body);</span><br><span class="line">        traceResponse(response);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traceRequest</span><span class="params">(HttpRequest request, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"===========================request begin================================================"</span>);</span><br><span class="line">        log.debug(<span class="string">"URI         : &#123;&#125;"</span>, request.getURI());</span><br><span class="line">        log.debug(<span class="string">"Method      : &#123;&#125;"</span>, request.getMethod());</span><br><span class="line">        log.debug(<span class="string">"Headers     : &#123;&#125;"</span>, request.getHeaders() );</span><br><span class="line">        log.debug(<span class="string">"Request body: &#123;&#125;"</span>, <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>));</span><br><span class="line">        log.debug(<span class="string">"==========================request end================================================"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traceResponse</span><span class="params">(ClientHttpResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        StringBuilder inputStringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(response.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">        String line = bufferedReader.readLine();</span><br><span class="line">        <span class="keyword">while</span> (line != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inputStringBuilder.append(line);</span><br><span class="line">            inputStringBuilder.append(<span class="string">'\n'</span>);</span><br><span class="line">            line = bufferedReader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">"============================response begin=========================================="</span>);</span><br><span class="line">        log.debug(<span class="string">"Status code  : &#123;&#125;"</span>, response.getStatusCode());</span><br><span class="line">        log.debug(<span class="string">"Status text  : &#123;&#125;"</span>, response.getStatusText());</span><br><span class="line">        log.debug(<span class="string">"Headers      : &#123;&#125;"</span>, response.getHeaders());</span><br><span class="line">        log.debug(<span class="string">"Response body: &#123;&#125;"</span>, inputStringBuilder.toString());</span><br><span class="line">        log.debug(<span class="string">"=======================response end================================================="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>构造</em><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BufferingClientHttpRequestFactory 使用这个 requestFactory 是为了允许重复读取</span></span><br><span class="line"><span class="keyword">this</span>.restTemplate = builder.requestFactory(() -&gt; <span class="keyword">new</span> BufferingClientHttpRequestFactory(<span class="keyword">new</span> SimpleClientHttpRequestFactory()))</span><br><span class="line">                .interceptors(<span class="keyword">new</span> LoggingRequestInterceptor())</span><br><span class="line">                .rootUri(properties.getUrl())</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure></p>
<p>然后修改日志等级就可以了。</p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jpa</tag>
        <tag>gson</tag>
        <tag>RestTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 使用笔记</title>
    <url>/2019/11/10/hexo-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>参考 <a href="https://www.cxyxiaowu.com/6407.html" target="_blank" rel="noopener">https://www.cxyxiaowu.com/6407.html</a><br>防止链接挂了，自己复制一份。在上面的基础上添加了图片的配置。   </p>
<blockquote>
<p>_config.yml<br>post_asset_folder: true</p>
</blockquote>
<p>然后使用 <code>hexo new &quot;page&quot;</code> 的时候会建一个同名文件夹，可以放本文章使用的静态资源。<br>使用方式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用图片的示例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="复制内容"><a href="#复制内容" class="headerlink" title="复制内容"></a>复制内容</h2><p>使用 hexo 搭建的步骤，删去一些内容。留下关键步骤<br>node 环境之类的就不说了。</p>
<h3 id="安装-Hexo-初始化项目"><a href="#安装-Hexo-初始化项目" class="headerlink" title="安装 Hexo 初始化项目"></a>安装 Hexo 初始化项目</h3><p><em>安装 hexo</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p>
<p><em>初始化项目</em><br>也就是你的笔记保存的地方<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init &#123;name&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>生成网站</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><br>生成 <code>public</code> 目录，部署的时候是上传这个目录，本地的时候通常不用  </p>
<p><em>预览</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo serve</span><br></pre></td></tr></table></figure></p>
<p>然后去 <code>http://localhost:4000</code> 看自己写的东西</p>
<p><em>部署</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>当然，前提是要配置好 <code>git</code> 地址<br>去了解 <code>github pages</code>,就是建一个 <code>{username}.github.io</code> 仓库<br>然后去 <code>_config.yml</code> 配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &#123;git repo ssh address&#125;</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<p>需要额外安装插件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">最后部署执行</span><br></pre></td></tr></table></figure><br>hexo deploy<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">*配置站点信息*</span><br><span class="line">修改 `_config.yml` 里面的配置</span><br><span class="line">```yml</span><br><span class="line">title: Askluolei</span><br><span class="line">subtitle: &apos;个人的学习吐槽网站&apos;</span><br><span class="line">description: &apos;主要涉猎的编程语言为 java ，js，go 主要是服务端开发和一丢丢前端，外加一些读书笔记和吐槽&apos;</span><br><span class="line">keywords: &apos;java, js, vue, go, 读书, 笔记&apos;</span><br><span class="line">author: Luo lei</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: &apos;&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="主题-Next"><a href="#主题-Next" class="headerlink" title="主题 Next"></a>主题 Next</h3><p>修改主题<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p>
<p>然后在 <code>_config.yml</code> 里面修改配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></p>
<p>然后可以在 <code>themes/next/_config.yml</code> 里面调整主题的相关配置了 </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调整布局</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Pisces</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网站图标，图片放在 themes/next/source/images 目录，然后修改下面的配置</span></span><br><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/safari-pinned-tab.svg</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 头像 放在 themes/next/source/images/avatar.png 然后修改配置</span></span><br><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># In theme directory (source/images): /images/avatar.gif</span></span><br><span class="line">  <span class="comment"># In site directory (source/uploads): /uploads/avatar.gif</span></span><br><span class="line">  <span class="comment"># You can also use other linking images.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.png</span></span><br><span class="line">  <span class="comment"># If true, the avatar would be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, the avatar would be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码块的展示，使用 mac 类型的</span></span><br><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="comment"># Available values: normal | night | night eighties | night blue | night bright</span></span><br><span class="line">  <span class="comment"># See: https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line">  <span class="attr">highlight_theme:</span> <span class="string">night</span> <span class="string">bright</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Show text copy result.</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">mac</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回到顶端 ，开启配置</span></span><br><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Back to top in sidebar.</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 阅读进度条配置</span></span><br><span class="line"><span class="attr">reading_progress:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Available values: top | bottom</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">top</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">"#222"</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">2px</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 右上角加上 github 地址</span></span><br><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">https://github.com/askluolei</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 评论插件，开启 gitalk</span></span><br><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Available values: tabs | buttons</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">tabs</span></span><br><span class="line">  <span class="comment"># Choose a comment system to be displayed by default.</span></span><br><span class="line">  <span class="comment"># Available values: changyan | disqus | disqusjs | facebook_comments_plugin | gitalk | livere | valine | vkontakte</span></span><br><span class="line">  <span class="attr">active:</span> <span class="string">gitalk</span></span><br><span class="line"><span class="comment"># 然后补充相关配置</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github_id:</span> <span class="string">NightTeam</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">nightteam.github.io</span> <span class="comment"># Repository name to store issues</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">&#123;your</span> <span class="string">client</span> <span class="string">id&#125;</span> <span class="comment"># GitHub Application Client ID</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">&#123;your</span> <span class="string">client</span> <span class="string">secret&#125;</span> <span class="comment"># GitHub Application Client Secret</span></span><br><span class="line">  <span class="attr">admin_user:</span> <span class="string">germey</span> <span class="comment"># GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span></span><br><span class="line">  <span class="attr">distraction_free_mode:</span> <span class="literal">true</span> <span class="comment"># Facebook-like distraction free mode</span></span><br><span class="line">  <span class="comment"># Gitalk's display language depends on user's browser or system environment</span></span><br><span class="line">  <span class="comment"># If you want everyone visiting your site to see a uniform language, you can set a force language value</span></span><br><span class="line">  <span class="comment"># Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中英文之间有空格</span></span><br><span class="line"><span class="attr">pangu:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数学公式 </span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Default (true) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in Front-matter.</span></span><br><span class="line">  <span class="comment"># If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># See: https://mhchem.github.io/MathJax-mhchem/</span></span><br><span class="line">    <span class="attr">mhchem:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 局部刷新</span></span><br><span class="line"><span class="attr">pjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="其他插件"><a href="#其他插件" class="headerlink" title="其他插件"></a>其他插件</h3><p><em>rss</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure></p>
<p><em>数学公式</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm i hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure></p>
<p><em>pjax</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd themes/next</span><br><span class="line">git clone https://github.com/theme-next/theme-next-pjax source/lib/pjax</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>maven 插件笔记</title>
    <url>/2019/11/07/maven-%E6%8F%92%E4%BB%B6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>maven 相关的插件使用</p>
<h2 id="jdk-等级"><a href="#jdk-等级" class="headerlink" title="jdk 等级"></a>jdk 等级</h2><p>在新建项目的时候，总是 <code>maven</code> 默认使用的编译等级和 <code>jdk</code> 为全局配置的，默认是 <code>5</code><br>可以修改全局配置，或者项目的 <code>pom</code>文件，推荐后一种，因为无法保证项目的每个人都会去配相同的全局配置，所以，一些配置尽量在项目配置里面完成<br>添加以下配置  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="项目报告"><a href="#项目报告" class="headerlink" title="项目报告"></a>项目报告</h2><p>检查代码重复率，findbugs，p3c检查等<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-pmd-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">rulesets</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/java/ali-comment.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/java/ali-concurrent.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/java/ali-constant.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/java/ali-exception.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/java/ali-flowcontrol.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/java/ali-naming.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/java/ali-oop.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/java/ali-orm.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/java/ali-other.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/java/ali-set.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">rulesets</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">printFailingErrors</span>&gt;</span>true<span class="tag">&lt;/<span class="name">printFailingErrors</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">goal</span>&gt;</span>check<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.p3c<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>p3c-pmd<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">&lt;!-- 可以使用 mvn site 生成报告，包含重复代码检测，p3c 检查，基本信息 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-site-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 生成项目报告 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 项目总览，包括基本信息，依赖，使用的插件等 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">&lt;!-- 源码关联，当使用检测插件的时候，发现问题代码行数，可以直接点击行数去看源码 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jxr-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">&lt;!-- p3c 的代码质量检测 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-pmd-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">rulesets</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/java/ali-comment.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/java/ali-concurrent.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/java/ali-constant.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/java/ali-exception.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/java/ali-flowcontrol.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/java/ali-naming.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/java/ali-oop.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/java/ali-orm.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/java/ali-other.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/java/ali-set.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">rulesets</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">printFailingErrors</span>&gt;</span>true<span class="tag">&lt;/<span class="name">printFailingErrors</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>findbugs-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">					<span class="comment">&lt;!-- &lt;configLocation&gt;$&#123;basedir&#125;/springside-findbugs.xml&lt;/configLocation&gt; --&gt;</span></span><br><span class="line">					<span class="comment">&lt;!-- Low、Medium和High (Low最严格) --&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">threshold</span>&gt;</span>Medium和High<span class="tag">&lt;/<span class="name">threshold</span>&gt;</span></span><br><span class="line">					<span class="comment">&lt;!-- 设置分析工作的等级，可以为Min、Default和Max --&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">effort</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">effort</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">findbugsXmlOutput</span>&gt;</span>true<span class="tag">&lt;/<span class="name">findbugsXmlOutput</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">findbugsXmlOutputDirectory</span>&gt;</span>target/site<span class="tag">&lt;/<span class="name">findbugsXmlOutputDirectory</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="maven-多模块的版本号管理问题"><a href="#maven-多模块的版本号管理问题" class="headerlink" title="maven 多模块的版本号管理问题"></a>maven 多模块的版本号管理问题</h2><p>当存在多模块，每个模块之间还有依赖的时候，如果要升级版本号，则需要很多地方都要改动。  </p>
<p>使用配置，和如下规则，避免<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根目录执行 mvn versions:set -DnewVersion=1.0.0.RELEASE 修改版本号 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 子模块不要自己定义独立的版本号，公用父模块的版本号--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 子模块相互依赖，一律使用 project.version 定义版本号 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>versions-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generateBackupPoms</span>&gt;</span>false<span class="tag">&lt;/<span class="name">generateBackupPoms</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这个配置放到顶层项目。使用<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn versions:<span class="built_in">set</span> -DnewVersion=1.0.0.RELEASE</span><br></pre></td></tr></table></figure></p>
<p>修改版本号</p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm 学习笔记</title>
    <url>/2019/10/26/jvm-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><code>深入理解 java 虚拟机</code>  这本书看了也有几遍了，说实话，每次都是面试前看的（我也没面几次试)<br>虽然每次看，感觉都可以多理解一点东西，但还是很虚。。先做个笔记，以后面试看笔记就行  </p>
<h2 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h2><p>这个是面试但时候常问的，也是比较好理解的<br>运行时数据区域分为  </p>
<ol>
<li>程序计数器<br>可以看作当前线程执行字节码的行号指示器，字节码在jvm内部是解释执行的（没 jit 之前）</li>
<li>java 虚拟机栈<br>也是线程私有的，每个方法创建一个栈帧，用于存储 局部变量表，操作数栈，动态链接，方法出口<br>局部变量表存放编译器可知的各种基本数据类型，对象引用，变量表的空间按 slot 分配，一个 slot 4个字节<br>当线程请求的栈深度大于虚拟机所允许的深度抛 StackOverflowError 栈溢出异常，如果是动态扩展栈空间的时候内存不足，则是 OOM 异常</li>
<li>本地方法栈<br>native 方法栈</li>
<li>java 堆<br>这个是最需要关系的区域<br>也是共享的一块内存区域，存放对象实例，也是 垃圾回收的主要区域<br>堆还可以细分为 新生代 老年代，注意是为了方便 gc 可以通过 -Xmx -Xms 控制，这个两个是常用的控制最大最小堆内存空间的jvm参数</li>
<li>方法区，也是元空间<br>通常用于存储已经被虚拟机加载的 类信息，常量信息，静态变量，即使编译器后的代码，也叫 非堆 NonHeap ，也被称为永久代，通常这部分内容很难被回收掉，要回收的条件也比较严格</li>
<li>直接内存<br>也是对外内存，nio 的时候会用到</li>
</ol>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾回收其实可以分为两部分看，一个是怎么判断一个对象已经失效了，另一个才是实际回收内存操作  </p>
<p><strong>对象已死吗</strong></p>
<ol>
<li>引用计数<br>就算对象每被引用一次，就 + 1，释放就 -1 到0 到 0 到时候代表没用了<br>这是一个思路，jvm 内部不使用这种策略，在 netty 中，只用 pooled** 到内存池的时候使用的就是引用计数来判断的</li>
<li>可达性分析<br>这个是主流的方法，根据 GC Root 对象为起点，往下搜索，走过的路径代表引用链，不在引用链上的对象可以认为死对象<br>那么哪些对象是在 GC Root 呢<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中类静态属性引用的变量</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中 JNI 引用的对象<br>这里面其实可以看到后期的一个优化，栈上分配，当方法执行完成后，对象就失效了，因此在方法内部分配的对象，生命周期是短暂的</li>
</ul>
</li>
</ol>
<p><strong>引用</strong><br>java 内部将引用分为4种</p>
<ol>
<li>强引用<br>这也是最常见的，通常 new 出来的都是这种，只要强引用还在，垃圾回收器永远不会回收</li>
<li>软引用<br>提供 SoftReference 来实现软引用，在将要内存溢出的情况下，才去回收这块内存</li>
<li>弱引用<br>提供 WeakReference 来实现弱引用，下次 gc 的时候，就会回收这块内容</li>
<li>虚引用<br>PhantomReference 基本就只是在回收的时候获得一个通知 </li>
</ol>
<p><strong>回收方法区</strong><br>由于在 jdk8 中，字符串常量池已经从方法区（元空间）移到堆了，这里说下类被回收（卸载）<br>满足3个条件</p>
<ol>
<li>类的所有实例已经被回收</li>
<li>类的 classloader 已经被回收</li>
<li>类 class 对象没有被引用</li>
</ol>
<p>就可以被回收了，注意是 可以，并不一定 </p>
<h2 id="垃圾搜集算法"><a href="#垃圾搜集算法" class="headerlink" title="垃圾搜集算法"></a>垃圾搜集算法</h2><ol>
<li><p>标记清除<br>跟名字已有，分为两个过程，标记阶段，标记需要回收的对象，然后统一清除被标记的对象<br>有两个问题，1. 标记和清除的效率不高 2. 会产生很多内存碎片</p>
</li>
<li><p>复制算法<br>将内存分为2块相同的区域，先用一块，用完的时候，将还存活的对象复制到另一半，然后将之前使用过的内存区域一次性清除。<br>问题也很大，内存缩小为原来的一半了</p>
</li>
<li><p>标记整理<br>与标记清除类似，不过后续步骤不是清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界外的内存</p>
</li>
<li><p>分代算法<br>就是将内存划分为几块区域，一般分为新生代和老年代，针对不同区域使用不同的垃圾回收算法</p>
</li>
</ol>
<p><strong>枚举根节点</strong><br>GC Root 的节点主要在全局性的引用和执行上下文中。<br>当在进行可达性分析的时候，需要 GC 停顿，不可以在分析过程中对象关系引用还在不断变化中。  </p>
<p><strong>安全点</strong><br>虚拟机将在特定位置记录协助 GC Root 枚举信息，这些位置称为 Sofapoint 安全点  </p>
<p><strong>安全区域</strong><br>安全区域是指在一段代码片段中国，引用关系不会发生变化</p>
<h2 id="垃圾搜集器"><a href="#垃圾搜集器" class="headerlink" title="垃圾搜集器"></a>垃圾搜集器</h2><p>新生代：Serial，ParNew，Parallel Scavenge<br>老年代：CMS，Serial Old，Parallel Old<br>全部：G1</p>
<p><strong>Serial</strong><br>这是一个单线程的搜集器，在进行垃圾搜集的时候需要进行暂停所有的工作线程。<br>这是在 Client 模式下默认的垃圾搜集器<br>能与老年代的 CMS，Serial Old 共用 </p>
<p><strong>ParNew</strong><br>其实就是 Serial 的多线程版本</p>
<p><strong>Parallel Scavenge</strong><br>目标是达到一个可控制的吞吐量，也就是 cpu 运行用户代码与 cpu 总消耗时间的比值<br>停顿时间越短适合需要与用户交互的程序，高吞吐量则是高效率的利用 cpu 时间 </p>
<p><strong>Serial Old</strong><br>单线程搜集器，使用标记整理算法，也是给 client 模式的虚拟机用的</p>
<p><strong>Parallel Old</strong><br>多线程加标记整理算法</p>
<p><strong>CMS</strong><br>是一种以获取最短回收停顿时间为目标的搜集器<br>使用标记清除算法。整个过程分为4个步骤：</p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除<br>初始标记和重新标记需要 stop the world<br>整个初始标记时间很短<br>整个过程耗时最长的并发标记和并发清除过程，gc 线程可以和用户线程同时工作<br>问题：</li>
<li>cpu 资源敏感，gc 会占用 cpu 资源</li>
<li>无法清除浮动垃圾，也就是在并发清理过程中产生的垃圾要在下次 gc 清除</li>
<li>标记清除，没做整理，可以设置参数</li>
</ol>
<p><strong>G1</strong><br>这个垃圾回收器与之前的都不一样内存划分不同，将堆划分为一个个 Region,默认 512k<br>在逻辑上连续，物理上不连续，同时每个 Regin 被标记为 E，S，O，H，分别表示 Eden，survivor，old，Humongous（大对象）<br>大于等于 region 一半大小的对象为 大对象，分配在老年代 </p>
<p>eden 出生的对象， 经过一次 Minor GC 还存活，如果 Survivor 还能容纳，就进入 Survivor，年龄设置为 1<br>每在 Suvivor 熬过一次 Minor GC，年龄 +1，增加到一定程度 默认 15 晋升老年代。  </p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><ol>
<li>加载</li>
<li>链接<ul>
<li>验证</li>
<li>准备</li>
<li>解析</li>
</ul>
</li>
<li>初始化<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2></li>
<li>取得类的二进制流</li>
<li>转为方法区（元空间）的数据结构</li>
<li>生成 class 对象<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3></li>
<li>文件格式正确<ul>
<li>是否已 0xCAFEBABE 开头</li>
<li>版本号是否合理</li>
<li>。。。</li>
</ul>
</li>
<li>元数据验证<ul>
<li>是否有父类</li>
<li>继承了 final 类？</li>
<li>非抽象实现了所有的抽象方法</li>
<li>。。</li>
</ul>
</li>
<li>字节码验证（很复杂）<ul>
<li>运行检查</li>
<li>栈数据类型和操作码数据参数吻合</li>
<li>跳转指令到合理位置</li>
<li>。。</li>
</ul>
</li>
<li>符号引用验证<ul>
<li>常量池中描述类是否存在</li>
<li>访问的方法或字段是否存在且有足够的权限</li>
<li>。。<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3>分配内存，并为类赋值初值<br>public static int v = 1<br>在 准备阶段 v 会被设置为 0<br>在初始化的<clinit> 中才会设置为1<br>对于 static final 类型，在准备阶段就会被赋值正确的值<br>public static int v = 1<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3>符号引用替换为直接引用<br>符号引用：字符串，引用对象不一定被加载<br>直接引用：指针或者地址便宜，引用对象一定在内存<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2></li>
</ul>
</li>
</ol>
<ul>
<li>执行类构造器 <clinit><ul>
<li>static 变量赋值语句</li>
<li>static {} 语句</li>
</ul>
</li>
<li>子类的 <clinit> 调用前保证父类的 <clinit> 被调用</li>
<li><clinit> 是线程安全的</li>
</ul>
<h2 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h2><p>一堆 JIT 优化，然鹅记不住 </p>
<ol>
<li>公共子表达式消除</li>
<li>数组边界检查消除</li>
<li>方法内联</li>
<li>。。一大堆优化手段 </li>
</ol>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>java 内存模型主要用来屏蔽底层各种硬件和操作系统的差异，给java程序在各个平台都能达到一致的内存访问效果。<br>以下指令是原子的：</p>
<ol>
<li>lock</li>
<li>unlock</li>
<li>read</li>
<li>load</li>
<li>use</li>
<li>assign</li>
<li>store</li>
<li>write</li>
</ol>
<p>要将一个变量从主内存复制到工作内存，需要 read + load<br>将工作内存的变量写回主内存需要 store + write<br>这上面两个是不可拆分使用的<br>volatile 变量将保证可见性 </p>
<p>并发的3个关键特性</p>
<ol>
<li>原子性</li>
<li>可见性</li>
<li>有序性</li>
</ol>
<p>几个先行发生原则，关注几个：</p>
<ol>
<li>单线程的代码顺序性</li>
<li>加锁先于解锁</li>
<li>volatile 写先于读</li>
<li>线程 start 先于每个动作</li>
<li>所有操作先于线程终止</li>
<li>线程中断限于被中断线程的代码检查中断事件发生</li>
<li>对象的初始化完成先于终结（finalize）</li>
<li>a 先于 b，b先于 c 那么 a 先于 c  </li>
</ol>
<p>无论是编译重排序还是cpu 的指令重排序，java 内存模型保证上面的先行发生原则。<br>使用在适当的位置插入内存屏障来实现。  </p>
<p>好吧，上面基本就是一些提纲，没啥具体内容，主要是为了看到这些，想到需要了解的知识  </p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>artha 学习</title>
    <url>/2019/10/23/artha-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="artha-文档地址"><a href="#artha-文档地址" class="headerlink" title="artha 文档地址"></a><a href="https://alibaba.github.io/arthas/index.html" target="_blank" rel="noopener">artha 文档地址</a></h2><h2 id="artha-能做什么"><a href="#artha-能做什么" class="headerlink" title="artha 能做什么"></a>artha 能做什么</h2><p>官网摘抄：</p>
<blockquote>
<p>Arthas 是Alibaba开源的Java诊断工具<br>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p>
<ol>
<li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li>
<li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li>
<li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li>
<li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li>
<li>是否有一个全局视角来查看系统的运行状况？</li>
<li>有什么办法可以监控到JVM的实时运行状态？<br>说简单点，就是针对正在运行的 <code>jvm</code> 进程,当无法使用日志分析出问题，本地没法或者很难重现的情况下，观察正在运行的 <code>jvm</code> 内部信息，包括整体情况，方法执行，变量信息等</li>
</ol>
<hr>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>基于 <code>JDK6</code> 开始的 <code>Instrumentation</code> 功能<br>关于 <code>Instrumentation</code> 的介绍可以看 <a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html" target="_blank" rel="noopener">Instrumentation 新功能</a><br>摘抄:<br>总的来说，基于 <code>Instrumentation</code> 功能，开发者可以构建一个独立于应用程序的代理程序（Agent），用来监测和协助运行在 JVM 上的程序，甚至能够替换和修改某些类的定义。<br>有了这样的功能，开发者就可以实现更为灵活的运行时虚拟机监控和 Java 类操作了，这样的特性实际上提供了一种虚拟机级别支持的 AOP 实现方式，使得开发者无需对 JDK 做任何升级和改动，就可以实现某些 AOP 的功能了。<br>独立开发的代理程序，可以通过应用启动的时候指定，或者对运行中的 <code>JVM</code> 进行 <code>attach</code>。<br>基于 <code>artha</code> 大部分时候都是动态载入的，允许远程载入（没做测试）<br>其实，简单点说，就是在应用程序运行中的时候，加载代理（<code>artha</code>），然后 <code>artha</code> 启动 <code>tcp</code> 监听,接受各种命令，根据命令对相应的类做修改（本质就是 <code>aop</code> ）。</p>
<h2 id="至于有什么功能，就看代理的实现了，Instrumentation-的-api-完全可以做到修改线程代码逻辑，运行时的数据。不过大部分这类代理通常只做局部修改查询，不修改数据，防止对线上应用造成严重影响。"><a href="#至于有什么功能，就看代理的实现了，Instrumentation-的-api-完全可以做到修改线程代码逻辑，运行时的数据。不过大部分这类代理通常只做局部修改查询，不修改数据，防止对线上应用造成严重影响。" class="headerlink" title="至于有什么功能，就看代理的实现了，Instrumentation 的 api 完全可以做到修改线程代码逻辑，运行时的数据。不过大部分这类代理通常只做局部修改查询，不修改数据，防止对线上应用造成严重影响。"></a>至于有什么功能，就看代理的实现了，<code>Instrumentation</code> 的 <code>api</code> 完全可以做到修改线程代码逻辑，运行时的数据。不过大部分这类代理通常只做局部修改查询，不修改数据，防止对线上应用造成严重影响。</h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>参见官方文档<br>不过文档推荐是访问各类镜像网站，下载，针对不能访问这些网站的时候，直接全量下载就可以了<br><a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&amp;g=com.taobao.arthas&amp;a=arthas-packaging&amp;e=zip&amp;c=bin&amp;v=LATEST" target="_blank" rel="noopener">下载地址</a><br>解压到应用服务器上面，<code>as.sh</code> 设置可执行权限</p>
<h2 id="执行-as-sh-选择-jvm-进程，就可以了。"><a href="#执行-as-sh-选择-jvm-进程，就可以了。" class="headerlink" title="执行 ./as.sh ,选择 jvm 进程，就可以了。"></a>执行 <code>./as.sh</code> ,选择 <code>jvm</code> 进程，就可以了。</h2><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h2 id="artha-功能和命令挺多的，但是常用的就是几个，这里简单介绍一下，如果需要用其他命令，可以去看官方文档"><a href="#artha-功能和命令挺多的，但是常用的就是几个，这里简单介绍一下，如果需要用其他命令，可以去看官方文档" class="headerlink" title="artha 功能和命令挺多的，但是常用的就是几个，这里简单介绍一下，如果需要用其他命令，可以去看官方文档"></a><code>artha</code> 功能和命令挺多的，但是常用的就是几个，这里简单介绍一下，如果需要用其他命令，可以去看官方文档</h2><h3 id="ognl"><a href="#ognl" class="headerlink" title="ognl"></a>ognl</h3><p>执行 <code>ognl</code> 表达式<br>格式为 <code>ognl &#39;表达式&#39; 对象展开层次</code><br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用静态函数：</span></span><br><span class="line">$ ognl <span class="string">'@java.lang.System@out.println("hello")'</span></span><br><span class="line">null</span><br><span class="line"><span class="comment"># 获取静态类的静态字段：</span></span><br><span class="line">$ ognl <span class="string">'@demo.MathGame@random'</span></span><br><span class="line">@Random[</span><br><span class="line">  serialVersionUID=@Long[3905348978240129619],</span><br><span class="line">  seed=@AtomicLong[125451474443703],</span><br><span class="line">  multiplier=@Long[25214903917],</span><br><span class="line">  addend=@Long[11],</span><br><span class="line">  mask=@Long[281474976710655],</span><br><span class="line">  DOUBLE_UNIT=@Double[1.1102230246251565E-16],</span><br><span class="line">  BadBound=@String[bound must be positive],</span><br><span class="line">  BadRange=@String[bound must be greater than origin],</span><br><span class="line">  BadSize=@String[size must be non-negative],</span><br><span class="line">  seedUniquifier=@AtomicLong[-3282039941672302964],</span><br><span class="line">  nextNextGaussian=@Double[0.0],</span><br><span class="line">  haveNextNextGaussian=@Boolean[<span class="literal">false</span>],</span><br><span class="line">  serialPersistentFields=@ObjectStreamField[][isEmpty=<span class="literal">false</span>;size=3],</span><br><span class="line">  unsafe=@Unsafe[sun.misc.Unsafe@28ea5898],</span><br><span class="line">  seedOffset=@Long[24],</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 执行多行表达式，赋值给临时变量，返回一个List：</span></span><br><span class="line">$ ognl <span class="string">'#value1=@System@getProperty("java.home"), #value2=@System@getProperty("java.runtime.name"), &#123;#value1, #value2&#125;'</span></span><br><span class="line">@ArrayList[</span><br><span class="line">  @String[/opt/java/8.0.181-zulu/jre],</span><br><span class="line">  @String[OpenJDK Runtime Environment],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<ul>
<li><a href="https://github.com/alibaba/arthas/issues/71" target="_blank" rel="noopener">OGNL特殊用法请参考</a></li>
<li><a href="https://commons.apache.org/proper/commons-ognl/language-guide.html" target="_blank" rel="noopener">OGNL表达式官方指南</a></li>
</ul>
<hr>
<h3 id="getstatic"><a href="#getstatic" class="headerlink" title="getstatic"></a>getstatic</h3><p>下面的内容都是官方文档里面的。<br>通过 <code>getstatic</code> 命令可以方便的查看类的静态属性。使用方法为 <code>getstatic class_name field_name</code><br>简单用法<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ getstatic demo.MathGame random</span><br><span class="line">field: random</span><br><span class="line">@Random[</span><br><span class="line">  serialVersionUID=@Long[3905348978240129619],</span><br><span class="line">  seed=@AtomicLong[120955813885284],</span><br><span class="line">  multiplier=@Long[25214903917],</span><br><span class="line">  addend=@Long[11],</span><br><span class="line">  mask=@Long[281474976710655],</span><br><span class="line">  DOUBLE_UNIT=@Double[1.1102230246251565E-16],</span><br><span class="line">  BadBound=@String[bound must be positive],</span><br><span class="line">  BadRange=@String[bound must be greater than origin],</span><br><span class="line">  BadSize=@String[size must be non-negative],</span><br><span class="line">  seedUniquifier=@AtomicLong[-3282039941672302964],</span><br><span class="line">  nextNextGaussian=@Double[0.0],</span><br><span class="line">  haveNextNextGaussian=@Boolean[<span class="literal">false</span>],</span><br><span class="line">  serialPersistentFields=@ObjectStreamField[][isEmpty=<span class="literal">false</span>;size=3],</span><br><span class="line">  unsafe=@Unsafe[sun.misc.Unsafe@2eaa1027],</span><br><span class="line">  seedOffset=@Long[24],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br>如果是复杂对象，可以使用 <code>ognl</code> 语法<br>例如，假设n是一个Map，Map的Key是一个Enum，我们想过滤出Map中Key为某个Enum的值，可以写如下命令</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ getstatic com.alibaba.arthas.Test n <span class="string">'entrySet().iterator.&#123;? #this.key.name()=="STOP"&#125;'</span></span><br><span class="line">field: n</span><br><span class="line">@ArrayList[</span><br><span class="line">  @Node[STOP=bbb],</span><br><span class="line">]</span><br><span class="line">Affect(row-cnt:1) cost <span class="keyword">in</span> 68 ms.</span><br><span class="line">$ getstatic com.alibaba.arthas.Test m <span class="string">'entrySet().iterator.&#123;? #this.key=="a"&#125;'</span></span><br><span class="line">field: m</span><br><span class="line">@ArrayList[</span><br><span class="line">  @Node[a=aaa],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></h2><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>方法执行数据观测<br>让你能方便的观察到指定方法的调用情况。能观察到的范围为：返回值、抛出异常、入参，通过编写 <code>OGNL</code> 表达式进行对应变量的查看。<br>格式为 <code>watch class-pattern method-pattern express condition-express [-x] x -[b|e|s|f|E] [-n] n</code></p>
<ul>
<li>-x x 代表输出结果的遍历深度，默认是1，就是说如果返回对象层次很深，大部分时候是展示 <code>hashcode</code> ,设置了 这个参数，就可以展示内部信息了</li>
<li>-b 在方法调用之前观察，这个就不会有异常和返回值了</li>
<li>-e 在方法异常之后观察</li>
<li>-s 在方法返回之后观察</li>
<li>-f 在方法结束之后(正常返回和异常返回)观察,这个是默认的，不到任何观察点，那就是这个了</li>
<li>-E 开启正则表达式匹配，默认为通配符匹配</li>
<li>-n n 代表输出次数，默认是一直输出，如果观察的对象调用过于频繁，会刷屏，控制输出次数<br>其中 <code>express</code> 和 <code>condition-express</code> 可以使用 <code>ognl</code> 表达式<br>通常匹配尽量少的类和方法，减少命令影响的类的数量，最好直接定位<br>官方示例：<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 观察方法出参和返回值</span></span><br><span class="line">$ watch demo.MathGame primeFactors <span class="string">"&#123;params,returnObj&#125;"</span> -x 2</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 44 ms.</span><br><span class="line">ts=2018-12-03 19:16:51; [cost=1.280502ms] result=@ArrayList[</span><br><span class="line">@Object[][</span><br><span class="line">  @Integer[535629513],</span><br><span class="line">],</span><br><span class="line">@ArrayList[</span><br><span class="line">  @Integer[3],</span><br><span class="line">  @Integer[19],</span><br><span class="line">  @Integer[191],</span><br><span class="line">  @Integer[49199],</span><br><span class="line">],</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 观察方法入参</span></span><br><span class="line">$ watch demo.MathGame primeFactors <span class="string">"&#123;params,returnObj&#125;"</span> -x 2 -b</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 50 ms.</span><br><span class="line">ts=2018-12-03 19:23:23; [cost=0.0353ms] result=@ArrayList[</span><br><span class="line">@Object[][</span><br><span class="line">  @Integer[-1077465243],</span><br><span class="line">],</span><br><span class="line">null,</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 对比前一个例子，返回值为空（事件点为方法执行前，因此获取不到返回值）</span></span><br><span class="line"><span class="comment"># 同时观察方法调用前和方法返回后</span></span><br><span class="line">$ watch demo.MathGame primeFactors <span class="string">"&#123;params,target,returnObj&#125;"</span> -x 2 -b -s -n 2</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 46 ms.</span><br><span class="line">ts=2018-12-03 19:29:54; [cost=0.01696ms] result=@ArrayList[</span><br><span class="line">@Object[][</span><br><span class="line">  @Integer[1544665400],</span><br><span class="line">],</span><br><span class="line">@MathGame[</span><br><span class="line">  random=@Random[java.util.Random@522b408a],</span><br><span class="line">  illegalArgumentCount=@Integer[13038],</span><br><span class="line">],</span><br><span class="line">null,</span><br><span class="line">]</span><br><span class="line">ts=2018-12-03 19:29:54; [cost=4.277392ms] result=@ArrayList[</span><br><span class="line">@Object[][</span><br><span class="line">  @Integer[1544665400],</span><br><span class="line">],</span><br><span class="line">@MathGame[</span><br><span class="line">random=@Random[java.util.Random@522b408a],</span><br><span class="line">illegalArgumentCount=@Integer[13038],</span><br><span class="line">],</span><br><span class="line">@ArrayList[</span><br><span class="line">  @Integer[2],</span><br><span class="line">  @Integer[2],</span><br><span class="line">  @Integer[2],</span><br><span class="line">  @Integer[5],</span><br><span class="line">  @Integer[5],</span><br><span class="line">  @Integer[73],</span><br><span class="line">  @Integer[241],</span><br><span class="line">  @Integer[439],</span><br><span class="line">],</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 参数里-n 2，表示只执行两次</span></span><br><span class="line"><span class="comment"># 这里输出结果中，第一次输出的是方法调用前的观察表达式的结果，第二次输出的是方法返回后的表达式的结果</span></span><br><span class="line"><span class="comment"># 结果的顺序和命令中 -s -b 的顺序没有关系，只与事件本身的先后顺序有关</span></span><br><span class="line"><span class="comment"># 调整-x的值，观察具体的方法参数值</span></span><br><span class="line">$ watch demo.MathGame primeFactors <span class="string">"&#123;params,target&#125;"</span> -x 3</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 58 ms.</span><br><span class="line">ts=2018-12-03 19:34:19; [cost=0.587833ms] result=@ArrayList[</span><br><span class="line">@Object[][</span><br><span class="line">  @Integer[47816758],</span><br><span class="line">],</span><br><span class="line">@MathGame[</span><br><span class="line">  random=@Random[</span><br><span class="line">  serialVersionUID=@Long[3905348978240129619],</span><br><span class="line">  seed=@AtomicLong[3133719055989],</span><br><span class="line">  multiplier=@Long[25214903917],</span><br><span class="line">  addend=@Long[11],</span><br><span class="line">  mask=@Long[281474976710655],</span><br><span class="line">  DOUBLE_UNIT=@Double[1.1102230246251565E-16],</span><br><span class="line">  BadBound=@String[bound must be positive],</span><br><span class="line">  BadRange=@String[bound must be greater than origin],</span><br><span class="line">  BadSize=@String[size must be non-negative],</span><br><span class="line">  seedUniquifier=@AtomicLong[-3282039941672302964],</span><br><span class="line">  nextNextGaussian=@Double[0.0],</span><br><span class="line">  haveNextNextGaussian=@Boolean[<span class="literal">false</span>],</span><br><span class="line">  serialPersistentFields=@ObjectStreamField[][isEmpty=<span class="literal">false</span>;size=3],</span><br><span class="line">  unsafe=@Unsafe[sun.misc.Unsafe@2eaa1027],</span><br><span class="line">  seedOffset=@Long[24],</span><br><span class="line">],</span><br><span class="line">illegalArgumentCount=@Integer[13159],</span><br><span class="line">],</span><br><span class="line">]</span><br><span class="line"><span class="comment"># -x表示遍历深度，可以调整来打印具体的参数和结果内容，默认值是1</span></span><br><span class="line"><span class="comment"># 条件表达式的例子</span></span><br><span class="line">$ watch demo.MathGame primeFactors <span class="string">"&#123;params[0],target&#125;"</span> <span class="string">"params[0]&lt;0"</span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 68 ms.</span><br><span class="line">ts=2018-12-03 19:36:04; [cost=0.530255ms] result=@ArrayList[</span><br><span class="line">  @Integer[-18178089],</span><br><span class="line">  @MathGame[demo.MathGame@41cf53f9],</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 只有满足条件的调用，才会有响应。</span></span><br><span class="line"><span class="comment"># 观察异常信息的例子</span></span><br><span class="line">$ watch demo.MathGame primeFactors <span class="string">"&#123;params[0],throwExp&#125;"</span> -e -x 2</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 62 ms.</span><br><span class="line">ts=2018-12-03 19:38:00; [cost=1.414993ms] result=@ArrayList[</span><br><span class="line">@Integer[-1120397038],</span><br><span class="line">java.lang.IllegalArgumentException: number is: -1120397038, need &gt;= 2</span><br><span class="line">at demo.MathGame.primeFactors(MathGame.java:46)</span><br><span class="line">at demo.MathGame.run(MathGame.java:24)</span><br><span class="line">at demo.MathGame.main(MathGame.java:16)</span><br><span class="line">,</span><br><span class="line">]</span><br><span class="line"><span class="comment"># -e表示抛出异常时才触发</span></span><br><span class="line"><span class="comment"># express中，表示异常信息的变量是throwExp</span></span><br><span class="line"><span class="comment"># 按照耗时进行过滤</span></span><br><span class="line">$ watch demo.MathGame primeFactors <span class="string">'&#123;params, returnObj&#125;'</span> <span class="string">'#cost&gt;200'</span> -x 2</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 66 ms.</span><br><span class="line">ts=2018-12-03 19:40:28; [cost=2112.168897ms] result=@ArrayList[</span><br><span class="line">@Object[][</span><br><span class="line">  @Integer[2141897465],</span><br><span class="line">],</span><br><span class="line">@ArrayList[</span><br><span class="line">  @Integer[5],</span><br><span class="line">  @Integer[428379493],</span><br><span class="line">],</span><br><span class="line">]</span><br><span class="line"><span class="comment">#cost&gt;200(单位是ms)表示只有当耗时大于200ms时才会输出，过滤掉执行时间小于200ms的调用</span></span><br><span class="line"><span class="comment"># 观察当前对象中的属性</span></span><br><span class="line">$ watch demo.MathGame primeFactors <span class="string">'target'</span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 52 ms.</span><br><span class="line">ts=2018-12-03 19:41:52; [cost=0.477882ms] result=@MathGame[</span><br><span class="line">  random=@Random[java.util.Random@522b408a],</span><br><span class="line">  illegalArgumentCount=@Integer[13355],</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 然后使用 `target.field_name` 访问当前对象的某个属性</span></span><br><span class="line">$ watch demo.MathGame primeFactors <span class="string">'target.illegalArgumentCount'</span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 67 ms.</span><br><span class="line">ts=2018-12-03 20:04:34; [cost=131.303498ms] result=@Integer[8]</span><br><span class="line">ts=2018-12-03 20:04:35; [cost=0.961441ms] result=@Integer[8]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><p>方法执行监控<br>用来统计一段时间内方法的调用情况(耗时，是否成功)<br>格式为 <code>monitor class-pattern method-pattern [-E] [-c] c</code></p>
<ul>
<li>-E 开启正则表达式匹配，默认为通配符匹配</li>
<li>-c c 统计周期，默认值为120秒,就是多长时间统计输出一次<br>统计表格的内容有：<br>| 监控项 | 说明 |<br>| —- | —— |<br>| timestamp | 时间戳 |<br>| class | Java类 |<br>| method | 方法（构造方法、普通方法） |<br>| total | 调用次数 |<br>| success | 成功次数 |<br>| fail | 失败次数 |<br>| rt | 平均RT |<br>| fail-rate | 失败率 |<br>示例:<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ monitor -c 5 demo.MathGame primeFactors</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 94 ms.</span><br><span class="line">timestamp class method total success fail avg-rt(ms) fail-rate</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line">2018-12-03 19:06:38 demo.MathGame primeFactors 5 1 4 1.15 80.00%</span><br><span class="line">timestamp class method total success fail avg-rt(ms) fail-rate</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line">2018-12-03 19:06:43 demo.MathGame primeFactors 5 3 2 42.29 40.00%</span><br><span class="line">timestamp class method total success fail avg-rt(ms) fail-rate</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line">2018-12-03 19:06:48 demo.MathGame primeFactors 5 3 2 67.92 40.00%</span><br><span class="line">timestamp class method total success fail avg-rt(ms) fail-rate</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line">2018-12-03 19:06:53 demo.MathGame primeFactors 5 2 3 0.25 60.00%</span><br><span class="line">timestamp class method total success fail avg-rt(ms) fail-rate</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line">2018-12-03 19:06:58 demo.MathGame primeFactors 1 1 0 0.45 0.00%</span><br><span class="line">timestamp class method total success fail avg-rt(ms) fail-rate</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line">2018-12-03 19:07:03 demo.MathGame primeFactors 2 2 0 3182.72 0.00%</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><p>方法内部调用路径，并输出方法路径上的每个节点上耗时<br><code>trace</code> 能方便的帮助你定位和发现因 RT 高而导致的性能问题缺陷，但其每次只能跟踪一级方法的调用链路。<br>场景就是当一个方法很耗时的时候，通过 <code>trace</code> 命令，查看这个方法内部其他方法调用的耗时，看到底是哪个方法耗时严重<br>格式为 <code>trace class-pattern method-pattern condition-express [-E] [-n] n [-j]</code></p>
<ul>
<li>-E 开启正则表达式匹配，默认为通配符匹配</li>
<li>-n n 命令执行次数,也就是输出次数</li>
<li>-j 过滤掉 <code>jdk</code> 的方法<br>如果内部方法有多次调用，会一起统计<br>统计的时候没有减去自身的开销，统计结果不太精确<br>示例:<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># trace函数</span></span><br><span class="line">$ trace demo.MathGame run</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 42 ms.</span><br><span class="line">`---ts=2018-12-04 00:44:17;thread_name=main;id=1;is_daemon=<span class="literal">false</span>;priority=5;TCCL=sun.misc.Launcher<span class="variable">$AppClassLoader</span>@3d4eac69</span><br><span class="line">`---[10.611029ms] demo.MathGame:run()</span><br><span class="line">+---[0.05638ms] java.util.Random:nextInt()</span><br><span class="line">+---[10.036885ms] demo.MathGame:primeFactors()</span><br><span class="line">`---[0.170316ms] demo.MathGame:<span class="built_in">print</span>()</span><br><span class="line"><span class="comment"># 过滤掉jdk的函数</span></span><br><span class="line">$ trace -j demo.MathGame run</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 31 ms.</span><br><span class="line">`---ts=2018-12-04 01:09:14;thread_name=main;id=1;is_daemon=<span class="literal">false</span>;priority=5;TCCL=sun.misc.Launcher<span class="variable">$AppClassLoader</span>@3d4eac69</span><br><span class="line">`---[5.190646ms] demo.MathGame:run()</span><br><span class="line">+---[4.465779ms] demo.MathGame:primeFactors()</span><br><span class="line">`---[0.375324ms] demo.MathGame:<span class="built_in">print</span>()</span><br><span class="line"><span class="comment"># 据调用耗时过滤</span></span><br><span class="line">$ trace demo.MathGame run <span class="string">'#cost &gt; 10'</span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 41 ms.</span><br><span class="line">`---ts=2018-12-04 01:12:02;thread_name=main;id=1;is_daemon=<span class="literal">false</span>;priority=5;TCCL=sun.misc.Launcher<span class="variable">$AppClassLoader</span>@3d4eac69</span><br><span class="line">`---[12.033735ms] demo.MathGame:run()</span><br><span class="line">+---[0.006783ms] java.util.Random:nextInt()</span><br><span class="line">+---[11.852594ms] demo.MathGame:primeFactors()</span><br><span class="line">`---[0.05447ms] demo.MathGame:<span class="built_in">print</span>()</span><br><span class="line"><span class="comment"># 只会展示耗时大于 10ms 的调用路径，有助于在排查问题的时候，只关注异常情况</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="tt"><a href="#tt" class="headerlink" title="tt"></a>tt</h3><p>方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测<br>举个例子，有一个 <code>hello(String name)</code> 方法，很多人都需要调用，但是每个人的参数都不一样，我只关心我自己的调用<br>虽然 <code>watch</code> 命令可以看到参数，但是需要提前想好过滤条件，也没法重试<br><code>tt</code> 的作用就是记录指定次数的方法调用，记录下来，后面可以查看这些记录，重试调用等<br><strong>记录调用</strong><br>格式 <code>tt -t class-pattern method-pattern [-n] n</code></p>
<ul>
<li>-n n 记录命令执行次数<br>展示:<br>| 表格字段 | 字段解释 |<br>| —- | —— |<br>| INDEX | 时间片段记录编号，每一个编号代表着一次调用，后续tt还有很多命令都是基于此编号指定记录操作，非常重要。 |<br>| TIMESTAMP | 方法执行的本机时间，记录了这个时间片段所发生的本机时间 |<br>| COST(ms) | 方法执行的耗时 |<br>| IS-RET | 方法是否以正常返回的形式结束 |<br>| IS-EXP | 方法是否以抛异常的形式结束 |<br>| OBJECT | 执行对象的hashCode()，注意，曾经有人误认为是对象在JVM中的内存地址，但很遗憾他不是。但他能帮助你简单的标记当前执行方法的类实体 |<br>| CLASS | 执行的类名 |<br>| METHOD | 执行的方法名 |<br>示例：<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ tt -t demo.MathGame primeFactors</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 66 ms.</span><br><span class="line">INDEX TIMESTAMP COST(ms) IS-RET IS-EXP OBJECT CLASS METHOD</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">1000 2018-12-04 11:15:38 1.096236 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1001 2018-12-04 11:15:39 0.191848 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1002 2018-12-04 11:15:40 0.069523 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1003 2018-12-04 11:15:41 0.186073 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1004 2018-12-04 11:15:42 17.76437 <span class="literal">true</span> <span class="literal">false</span> 0x4b67cf4d MathGame primeFactors</span><br></pre></td></tr></table></figure>
<strong>检索调用记录</strong><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有记录</span></span><br><span class="line">$ tt -l</span><br><span class="line">INDEX TIMESTAMP COST(ms) IS-RET IS-EXP OBJECT CLASS METHOD</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">1000 2018-12-04 11:15:38 1.096236 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1001 2018-12-04 11:15:39 0.191848 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1002 2018-12-04 11:15:40 0.069523 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1003 2018-12-04 11:15:41 0.186073 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1004 2018-12-04 11:15:42 17.76437 <span class="literal">true</span> <span class="literal">false</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">9</span><br><span class="line">1005 2018-12-04 11:15:43 0.4776 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">Affect(row-cnt:6) cost <span class="keyword">in</span> 4 ms.</span><br><span class="line"><span class="comment"># 筛选</span></span><br><span class="line">$ tt -s <span class="string">'method.name=="primeFactors"'</span></span><br><span class="line">INDEX TIMESTAMP COST(ms) IS-RET IS-EXP OBJECT CLASS METHOD</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">1000 2018-12-04 11:15:38 1.096236 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1001 2018-12-04 11:15:39 0.191848 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1002 2018-12-04 11:15:40 0.069523 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1003 2018-12-04 11:15:41 0.186073 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">1004 2018-12-04 11:15:42 17.76437 <span class="literal">true</span> <span class="literal">false</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">9</span><br><span class="line">1005 2018-12-04 11:15:43 0.4776 <span class="literal">false</span> <span class="literal">true</span> 0x4b67cf4d MathGame primeFactors</span><br><span class="line">Affect(row-cnt:6) cost <span class="keyword">in</span> 607 ms.</span><br></pre></td></tr></table></figure>
<strong>查看调用信息</strong><br><code>-i</code> 指定 <code>INDEX</code><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ tt -i 1003</span><br><span class="line">INDEX 1003</span><br><span class="line">GMT-CREATE 2018-12-04 11:15:41</span><br><span class="line">COST(ms) 0.186073</span><br><span class="line">OBJECT 0x4b67cf4d</span><br><span class="line">CLASS demo.MathGame</span><br><span class="line">METHOD primeFactors</span><br><span class="line">IS-RETURN <span class="literal">false</span></span><br><span class="line">IS-EXCEPTION <span class="literal">true</span></span><br><span class="line">PARAMETERS[0] @Integer[-564322413]</span><br><span class="line">THROW-EXCEPTION java.lang.IllegalArgumentException: number is: -564322413, need &gt;= 2</span><br><span class="line">at demo.MathGame.primeFactors(MathGame.java:46)</span><br><span class="line">at demo.MathGame.run(MathGame.java:24)</span><br><span class="line">at demo.MathGame.main(MathGame.java:16)</span><br><span class="line">Affect(row-cnt:1) cost <span class="keyword">in</span> 11 ms.</span><br></pre></td></tr></table></figure>
<strong>重做一次调用</strong><br>当你稍稍做了一些调整之后，你可能需要前端系统重新触发一次你的调用，此时得求爷爷告奶奶的需要前端配合联调的同学再次发起一次调用。而有些场景下，这个调用不是这么好触发的。<br>tt 命令由于保存了当时调用的所有现场信息，所以我们可以自己主动对一个 INDEX 编号的时间片自主发起一次调用，从而解放你的沟通成本。此时你需要 -p 参数。<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ tt -i 1004 -p</span><br><span class="line">RE-INDEX 1004</span><br><span class="line">GMT-REPLAY 2018-12-04 11:26:00</span><br><span class="line">OBJECT 0x4b67cf4d</span><br><span class="line">CLASS demo.MathGame</span><br><span class="line">METHOD primeFactors</span><br><span class="line">PARAMETERS[0] @Integer[946738738]</span><br><span class="line">IS-RETURN <span class="literal">true</span></span><br><span class="line">IS-EXCEPTION <span class="literal">false</span></span><br><span class="line">RETURN-OBJ @ArrayList[</span><br><span class="line">@Integer[2],</span><br><span class="line">@Integer[11],</span><br><span class="line">@Integer[17],</span><br><span class="line">@Integer[2531387],</span><br><span class="line">]</span><br><span class="line">Time fragment[1004] successfully replayed.</span><br><span class="line">Affect(row-cnt:1) cost <span class="keyword">in</span> 14 ms.</span><br></pre></td></tr></table></figure>
重做一次调用需要注意的地方：</li>
</ul>
<ol>
<li><code>ThreadLocal</code> 信息丢失<br>很多框架偷偷的将一些环境变量信息塞到了发起调用线程的 <code>ThreadLocal</code> 中，由于调用线程发生了变化，这些 <code>ThreadLocal</code> 线程信息无法通过 <code>Arthas</code> 保存，所以这些信息将会丢失。<br>一些常见的例子 比如：鹰眼的 <code>TraceId</code> 等。</li>
<li>引用的对象<br>需要强调的是，<code>tt</code> 命令是将当前环境的对象引用保存起来，但仅仅也只能保存一个引用而已。如果方法内部对入参进行了变更，或者返回的对象经过了后续的处理，那么在 <code>tt</code> 查看的时候将无法看到当时最准确的值。这也是为什么 <code>watch</code> 命令存在的意义。</li>
</ol>
<hr>
<h2 id="其他可能用到的功能"><a href="#其他可能用到的功能" class="headerlink" title="其他可能用到的功能"></a>其他可能用到的功能</h2><p>详细的可以看官方文档</p>
<h3 id="后台任务"><a href="#后台任务" class="headerlink" title="后台任务"></a>后台任务</h3><ol>
<li>使用&amp;在后台执行任务<br>比如希望执行后台执行trace命令，那么调用下面命令<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">trace Test t &amp;</span><br></pre></td></tr></table></figure>
这时命令在后台执行，可以在console中继续执行其他命令。</li>
<li>通过 <code>jobs</code> 查看任务<br>如果希望查看当前有哪些 <code>arthas</code> 任务在执行，可以执行 <code>jobs</code> 命令，执行结果如下<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">[10]*</span><br><span class="line">Stopped watch com.taobao.container.Test <span class="built_in">test</span> <span class="string">"params[0].&#123;? #this.name == null &#125;"</span> -x 2</span><br><span class="line">execution count : 19</span><br><span class="line">start time : Fri Sep 22 09:59:55 CST 2017</span><br><span class="line">timeout date : Sat Sep 23 09:59:55 CST 2017</span><br><span class="line">session : 3648e874-5e69-473f-9eed-7f89660b079b (current)</span><br></pre></td></tr></table></figure>
可以看到目前有一个后台任务在执行。</li>
</ol>
<ul>
<li>job id是10, <code>*</code> 表示此job是当前session创建</li>
<li>状态是Stopped</li>
<li>execution count是执行次数，从启动开始已经执行了19次</li>
<li>timeout date是超时的时间，到这个时间，任务将会自动超时退出</li>
</ul>
<ol>
<li>任务暂停和取消<br>当任务正在前台执行，比如直接调用命令<code>trace Test t</code>或者调用后台执行命令<code>trace Test t &amp;</code>后又通过<code>fg</code>命令将任务转到前台。这时<code>console</code>中无法继续执行命令，但是可以接收并处理以下事件：</li>
</ol>
<ul>
<li><code>‘ctrl + z’</code>：将任务暂停。通过<code>jbos</code>查看任务状态将会变为Stopped，通过<code>bg</code> 或者<code>fg</code> 可让任务重新开始执行</li>
<li><code>‘ctrl + c’</code>：停止任务</li>
<li><code>‘ctrl + d’</code>：按照<code>linux</code>语义应当是退出终端，目前<code>arthas</code>中是空实现，不处理</li>
</ul>
<ol>
<li>fg、bg命令，将命令转到前台、后台继续执行</li>
</ol>
<ul>
<li>任务在后台执行或者暂停状态（<code>ctrl + z</code>暂停任务）时，执行<code>fg</code> 将可以把对应的任务转到前台继续执行。在前台执行时，无法在console中执行其他命令</li>
<li>当任务处于暂停状态时（<code>ctrl + z</code>暂停任务），执行<code>bg</code> 将可以把对应的任务在后台继续执行</li>
<li>非当前session创建的job，只能由当前session <code>fg</code>到前台执行</li>
</ul>
<ol>
<li>任务输出重定向<br>可通过<code>&gt;</code>或者<code>&gt;&gt;</code>将任务输出结果输出到指定的文件中，可以和&amp;一起使用，实现<code>arthas</code>命令的异步调用。比如：<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ trace Test t &gt;&gt; test.out &amp;</span><br></pre></td></tr></table></figure>
这时<code>trace</code>命令会在后台执行，并且把结果输出到<code>~/logs/arthas-cache/test.out</code>。可继续执行其他命令。并可查看文件中的命令执行结果。<br>当连接到远程的<code>arthas server</code>时，可能无法查看远程机器的文件，<code>arthas</code>同时支持了自动重定向到本地缓存路径。使用方法如下：<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ trace Test t &gt;&gt; &amp;</span><br><span class="line">job id : 2</span><br><span class="line">cache location : /Users/gehui/logs/arthas-cache/28198/2</span><br></pre></td></tr></table></figure>
可以看到并没有指定重定向文件位置，<code>arthas</code>自动重定向到缓存中了，执行命令后会输出job id和cache location。cache location就是重定向文件的路径，在系统logs目录下，路径包括pid和job id，避免和其他任务冲突。命令输出结果到<code>/Users/gehui/logs/arthas-cache/28198/2</code>中，job id为2。</li>
<li>停止命令<br>异步执行的命令，如果希望停止，可执行kill <job-id></li>
<li>其他<br>最多同时支持8个命令使用重定向将结果写日志<br>请勿同时开启过多的后台异步命令，以免对目标JVM性能造成影响</li>
</ol>
<hr>
<h3 id="结果存日志"><a href="#结果存日志" class="headerlink" title="结果存日志"></a>结果存日志</h3><p>将命令的结果完整保存在日志文件中，便于后续进行分析<br>默认情况下，该功能是关闭的，如果需要开启，请执行以下命令：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ options save-result <span class="literal">true</span></span><br><span class="line">NAME BEFORE-VALUE AFTER-VALUE</span><br><span class="line">----------------------------------------</span><br><span class="line">save-result <span class="literal">false</span> <span class="literal">true</span></span><br><span class="line">Affect(row-cnt:1) cost <span class="keyword">in</span> 3 ms.</span><br></pre></td></tr></table></figure><br>看到上面的输出，即表示成功开启该功能；<br>结果会异步保存在：<code>{user.home}/logs/arthas-cache/result.log</code>，请定期进行清理，以免占据磁盘空间<br><strong>使用新版本Arthas的异步后台任务将结果存日志文件</strong><br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ trace Test t &gt;&gt; &amp;</span><br><span class="line">job id : 2</span><br><span class="line">cache location : /Users/admin/logs/arthas-cache/28198/2</span><br></pre></td></tr></table></figure><br>此时命令会在后台异步执行，并将结果异步保存在文件（<code>~/logs/arthas-cache/${PID}/${JobId}</code>）中；</p>
<ul>
<li>此时任务的执行不受session断开的影响；任务默认超时时间是1天，可以通过全局 <code>options</code> 命令修改默认超时时间；</li>
<li>此命令的结果将异步输出到文件中；此时不管 <code>save-result 是否为true，都不会再往</code>~/logs/arthas-cache/result.log` 中异步写结果</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>artha</tag>
      </tags>
  </entry>
  <entry>
    <title>Rest学习</title>
    <url>/2019/10/20/Rest%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><h3 id="消息（1字头）"><a href="#消息（1字头）" class="headerlink" title="消息（1字头）"></a>消息（1字头）</h3><ul>
<li>100<br>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。    </li>
<li>101<br>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。    </li>
<li>102<br>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。    </li>
</ul>
<h3 id="成功（2字头）"><a href="#成功（2字头）" class="headerlink" title="成功（2字头）"></a>成功（2字头）</h3><ul>
<li>200<br>请求已成功，请求所希望的响应头或数据体将随此响应返回。    </li>
<li>201<br>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。    </li>
<li>202<br>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。<br>返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。    </li>
<li>203<br>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。    </li>
<li>204<br>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。<br>如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。<br>由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。    </li>
<li>205<br>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。    </li>
<li>206<br>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。    </li>
<li>207<br>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。    </li>
</ul>
<h3 id="重定向（3字头）"><a href="#重定向（3字头）" class="headerlink" title="重定向（3字头）"></a>重定向（3字头）</h3><ul>
<li>300<br>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。    </li>
<li>301<br>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。<br>新的永久性的URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。<br>如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。    </li>
<li>302<br>请求的资源临时从不同的 URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。    </li>
<li>303<br>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。    </li>
<li>304<br>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。<br>该响应必须包含以下的头信息：<br>Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。<br>ETag 和/或 Content-Location，假如同样的请求本应返回200响应。<br>Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。    </li>
<li>305<br>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。    </li>
<li>306<br>在最新版的规范中，306状态码已经不再被使用。    </li>
<li>307<br>请求的资源临时从不同的URI 响应请求。    </li>
</ul>
<h3 id="请求错误（4字头）"><a href="#请求错误（4字头）" class="headerlink" title="请求错误（4字头）"></a>请求错误（4字头）</h3><ul>
<li>400<br>语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。    </li>
<li>401<br>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。    </li>
<li>402<br>该状态码是为了将来可能的需求而预留的。    </li>
<li>403<br>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。    </li>
<li>404<br>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。    </li>
<li>405<br>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。<br>鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。    </li>
<li>406<br>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。<br>除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。    </li>
<li>407<br>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。    </li>
<li>408<br>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。    </li>
<li><p>409<br>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。    </p>
</li>
<li><p>410<br>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。<br>410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。    </p>
</li>
<li>411<br>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。    </li>
<li>412<br>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。    </li>
<li>413<br>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。    </li>
<li>414<br>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：<br>本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。<br>重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。    </li>
<li>415<br>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。    </li>
<li>416<br>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。    </li>
<li>417<br>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。    </li>
<li>422<br>请求格式正确，但是由于含有语义错误，无法响应。    </li>
<li>423<br>当前资源被锁定。    </li>
<li>424<br>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。     </li>
<li>425<br>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。    </li>
<li>426<br>客户端应当切换到TLS/1.0。（RFC 2817）</li>
<li>449<br>由微软扩展，代表请求应当在执行完适当的操作后进行重试。    </li>
</ul>
<h3 id="服务器错误（5-6字头）"><a href="#服务器错误（5-6字头）" class="headerlink" title="服务器错误（5,6字头）"></a>服务器错误（5,6字头）</h3><ul>
<li>500<br>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。    </li>
<li>501<br>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。    </li>
<li>502<br>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。    </li>
<li>503<br>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。    </li>
<li>504<br>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。    </li>
<li>505<br>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。    </li>
<li>506<br>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。    </li>
<li>507<br>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。     </li>
<li>509<br>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。    </li>
<li>510<br>获取资源所需要的策略并没有没满足。    </li>
<li>600<br>源站没有返回响应头部，只返回实体内容    </li>
</ul>
<hr>
<h2 id="开发REST-API"><a href="#开发REST-API" class="headerlink" title="开发REST API"></a>开发REST API</h2><p>使用REST虽然非常简单，但是，设计一套合理的REST框架却需要仔细考虑很多问题。    </p>
<h3 id="问题一：如何组织URL"><a href="#问题一：如何组织URL" class="headerlink" title="问题一：如何组织URL"></a>问题一：如何组织URL</h3><p>在实际工程中，一个Web应用既有REST，还有MVC，可能还需要集成其他第三方系统。如何组织URL？<br>一个简单的方法是通过固定的前缀区分。例如，<code>/static/</code>开头的URL是静态资源文件，类似的，<code>/api/</code>开头的URL就是REST API，其他URL是普通的MVC请求。<br>使用不同的子域名也可以区分，但对于中小项目来说配置麻烦。随着项目的扩大，将来仍然可以把单域名拆成多域名。    </p>
<h3 id="问题二：如何统一输出REST"><a href="#问题二：如何统一输出REST" class="headerlink" title="问题二：如何统一输出REST"></a>问题二：如何统一输出REST</h3><p>如果每个异步函数都编写下面这样的代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置Content-Type:</span></span><br><span class="line">ctx.response.type = <span class="string">'application/json'</span>;</span><br><span class="line"><span class="comment">// 设置Response Body:</span></span><br><span class="line">ctx.response.body = &#123;</span><br><span class="line">    products: products</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>很显然，这样的重复代码很容易导致错误，例如，写错了字符串<code>&#39;application/json&#39;</code>，或者漏写了<code>ctx.response.type = &#39;application/json&#39;</code>，都会导致浏览器得不到JSON数据。    </p>
<h3 id="问题三：如何处理错误"><a href="#问题三：如何处理错误" class="headerlink" title="问题三：如何处理错误"></a>问题三：如何处理错误</h3><p>这个问题实际上有两部分。<br>第一，当REST API请求出错时，我们如何返回错误信息？<br>第二，当客户端收到REST响应后，如何判断是成功还是错误？<br>这两部分还必须统一考虑。<br>REST架构本身对错误处理并没有统一的规定。实际应用时，各种各样的错误处理机制都有。有的设计得比较合理，有的设计得不合理，导致客户端尤其是手机客户端处理API简直就是噩梦。<br>在涉及到REST API的错误时，我们必须先意识到，客户端会遇到两种类型的REST API错误。<br>一类是类似403，404，500等错误，这些错误实际上是HTTP请求可能发生的错误。REST请求只是一种请求类型和响应类型均为JSON的HTTP请求，因此，这些错误在REST请求中也会发生。<br>针对这种类型的错误，客户端除了提示用户“出现了网络错误，稍后重试”以外，并无法获得具体的错误信息。<br>另一类错误是业务逻辑的错误，例如，输入了不合法的Email地址，试图删除一个不存在的Product，等等。这种类型的错误完全可以通过JSON返回给客户端，这样，客户端可以根据错误信息提示用户“Email不合法”等，以便用户修复后重新请求API。<br>问题的关键在于客户端必须能区分出这两种类型的错误。<br>第一类的错误实际上客户端可以识别，并且我们也无法操控HTTP服务器的错误码。<br>第二类的错误信息是一个JSON字符串，例如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"code"</span>: <span class="string">"10000"</span>,</span><br><span class="line">    <span class="string">"message"</span>: <span class="string">"Bad email address"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是HTTP的返回码应该用啥？<br>有的Web应用使用<code>200</code>，这样客户端在识别出第一类错误后，如果遇到<code>200</code>响应，则根据响应的JSON判断是否有错误。这种方式对于动态语言（例如，JavaScript，Python等）非常容易：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="built_in">JSON</span>.parse(response.data);</span><br><span class="line"><span class="keyword">if</span> (result.code) &#123;</span><br><span class="line">    <span class="comment">// 有错误:</span></span><br><span class="line">    alert(result.message);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，对于静态语言（例如，Java）就比较麻烦，很多时候，不得不做两次序列化：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">APIError err = objectMapper.readValue(jsonString, APIError<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (err.code == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有错误，还需要重新转换:</span></span><br><span class="line">    User user = objectMapper.readValue(jsonString, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 有错误:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有的Web应用对正确的REST响应使用<code>200</code>，对错误的REST响应使用<code>400</code>，这样，客户端即是静态语言，也可以根据HTTP响应码判断是否出错，出错时直接把结果反序列化为APIError对象。<br>两种方式各有优劣。我们选择第二种，<code>200</code>表示成功响应，<code>400</code>表示失败响应。    </p>
<p>但是，要注意，<em>绝不能</em>混合其他HTTP错误码。例如，使用401响应“登录失败”，使用403响应“权限不够”。这会使客户端无法有效识别HTTP错误码和业务错误，其原因在于HTTP协议定义的错误码十分偏向底层，而REST API属于“高层”协议，不应该复用底层的错误码。    </p>
<h3 id="如何定义错误码"><a href="#如何定义错误码" class="headerlink" title="如何定义错误码"></a>如何定义错误码</h3><p>REST架构本身同样没有标准的错误码定义一说，因此，有的Web应用使用数字<code>1000、1001……</code>作为错误码，例如Twitter和新浪微博，有的Web应用使用字符串作为错误码，例如YouTube。到底哪一种比较好呢？    </p>
<p>我们强烈建议使用字符串作为错误码。原因在于，使用数字作为错误码时，API提供者需要维护一份错误码代码说明表，并且，该文档必须时刻与API发布同步，否则，客户端开发者遇到一个文档上没有写明的错误码，就完全不知道发生了什么错误。    </p>
<p>使用字符串作为错误码，最大的好处在于不用查表，根据字面意思也能猜个八九不离十。例如，YouTube API如果返回一个错误<code>authError</code>，基本上能猜到是因为认证失败。    </p>
<p>我们定义的REST API错误格式如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"code"</span>: <span class="string">"错误代码"</span>,</span><br><span class="line">    <span class="string">"message"</span>: <span class="string">"错误描述信息"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，错误代码命名规范为<em>大类:子类</em>，例如，口令不匹配的登录错误代码为<code>auth:bad_password</code>，用户名不存在的登录错误代码为<code>auth:user_not_found</code>。这样，客户端既可以简单匹配某个类别的错误，也可以精确匹配某个特定的错误。    </p>
<h3 id="问题五：如何返回错误"><a href="#问题五：如何返回错误" class="headerlink" title="问题五：如何返回错误"></a>问题五：如何返回错误</h3><p>如果一个REST异步函数想要返回错误，一个直观的想法是调用<code>ctx.rest()</code>：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">user = processLogin(username, password);</span><br><span class="line"><span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">    ctx.rest(user);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.response.status = <span class="number">400</span>;</span><br><span class="line">    ctx.rest(&#123;</span><br><span class="line">        code: <span class="string">'auth:user_not_found'</span>,</span><br><span class="line">        message: <span class="string">'user not found'</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式不好，因为控制流程会混乱，而且，错误只能在Controller函数中输出。<br>更好的方式是异步函数直接用throw语句抛出错误，让middleware去处理错误：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">user = processLogin(username, password);</span><br><span class="line"><span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">    ctx.rest(user);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> APIError(<span class="string">'auth:user_not_found'</span>, <span class="string">'user not found'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式可以在异步函数的任何地方抛出错误，包括调用的子函数内部。<br>我们只需要稍稍改写一个middleware就可以处理错误：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    APIError: <span class="function"><span class="keyword">function</span> (<span class="params">code, message</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code || <span class="string">'internal:unknown_error'</span>;</span><br><span class="line">        <span class="keyword">this</span>.message = message || <span class="string">''</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    restify: <span class="function">(<span class="params">pathPrefix</span>) =&gt;</span> &#123;</span><br><span class="line">        pathPrefix = pathPrefix || <span class="string">'/api/'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctx.request.path.startsWith(pathPrefix)) &#123;</span><br><span class="line">                <span class="comment">// 绑定rest()方法:</span></span><br><span class="line">                ctx.rest = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">                    ctx.response.type = <span class="string">'application/json'</span>;</span><br><span class="line">                    ctx.response.body = data;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">await</span> next();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="comment">// 返回错误:</span></span><br><span class="line">                    ctx.response.status = <span class="number">400</span>;</span><br><span class="line">                    ctx.response.type = <span class="string">'application/json'</span>;</span><br><span class="line">                    ctx.response.body = &#123;</span><br><span class="line">                        code: e.code || <span class="string">'internal:unknown_error'</span>,</span><br><span class="line">                        message: e.message || <span class="string">''</span></span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">await</span> next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个错误处理的好处在于，不但简化了Controller的错误处理（只需要throw，其他不管），并且，在遇到非APIError的错误时，自动转换错误码为<code>internal:unknown_error</code>。<br>受益于async/await语法，我们在middleware中可以直接用try…catch捕获异常。如果是callback模式，就无法用try…catch捕获，代码结构将混乱得多。<br>最后，顺便把APIError这个对象export出去。    </p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro-浅析</title>
    <url>/2019/10/18/shiro-%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<p>shiro 的核心接口就是 <code>SecurityManager</code> , 所有的实现，全是围绕这个接口的<br>这个接口继承了 <code>Authenticator</code> 认证接口 , <code>Authorizer</code> 权限接口 , <code>SessionManager</code> session 管理接口<br>我们先分别看看这些接口的定义  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Authenticator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationInfo <span class="title">authenticate</span><span class="params">(AuthenticationToken authenticationToken)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>认证接口，是有一个方法，token 换成  info ，虽然方法名是 <code>authenticate</code> 但是，认证流程不是在这里实现的（我们后面具体分析）<br>先说 token 和 info 的 区别， token 通常是用户(请求)带过来的凭证（用户名密码，accessToken 等）,默认是 <code>UsernamePasswordToken</code> 实现<br>这里可以自己扩展，而 info 是什么呢？ 凭证是请求带的，不一定是真的有效的凭证，我们需要根据这个凭证去数据库（缓存）去查询系统信息<br>简单点，凭证是用户名密码， info 就是根据用户名密码，返回这个用户的认证信息 用户名，加密（hash）过的密码，还有其他信息（角色，权限）  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Authorizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPermitted</span><span class="params">(PrincipalCollection principals, String permission)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPermitted</span><span class="params">(PrincipalCollection subjectPrincipal, Permission permission)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] isPermitted(PrincipalCollection subjectPrincipal, String... permissions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] isPermitted(PrincipalCollection subjectPrincipal, List&lt;Permission&gt; permissions);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPermittedAll</span><span class="params">(PrincipalCollection subjectPrincipal, String... permissions)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPermittedAll</span><span class="params">(PrincipalCollection subjectPrincipal, Collection&lt;Permission&gt; permissions)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(PrincipalCollection subjectPrincipal, String permission)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(PrincipalCollection subjectPrincipal, Permission permission)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkPermissions</span><span class="params">(PrincipalCollection subjectPrincipal, String... permissions)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkPermissions</span><span class="params">(PrincipalCollection subjectPrincipal, Collection&lt;Permission&gt; permissions)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasRole</span><span class="params">(PrincipalCollection subjectPrincipal, String roleIdentifier)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] hasRoles(PrincipalCollection subjectPrincipal, List&lt;String&gt; roleIdentifiers);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasAllRoles</span><span class="params">(PrincipalCollection subjectPrincipal, Collection&lt;String&gt; roleIdentifiers)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkRole</span><span class="params">(PrincipalCollection subjectPrincipal, String roleIdentifier)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkRoles</span><span class="params">(PrincipalCollection subjectPrincipal, Collection&lt;String&gt; roleIdentifiers)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkRoles</span><span class="params">(PrincipalCollection subjectPrincipal, String... roleIdentifiers)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>权限这个接口方法很多，因为权限可以根据角色和权限两个维度控制，而权限，除了可以使用字符串（应该叫权限表达式）,在内部，还以对象 <code>Permission</code> 标识<br>只要记住，这个接口就是用来验证权限的  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SessionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Session <span class="title">start</span><span class="params">(SessionContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Session <span class="title">getSession</span><span class="params">(SessionKey key)</span> <span class="keyword">throws</span> SessionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>session 管理，但是要注意的是，这里的 session 跟 servlet 里面的session 不是一个东西，虽然这里的 session 也可以支持 servlet 的<br>但是，这个 session 也可以用在非web环境里面<br>其中 <code>SessionContext</code> 是继承 Map 的 主要有 host 和 sessionId 两个属性（接口的 get set）<br><code>SessionKey</code> 这个里面就只有一个 <code>getSessionId</code> 方法了  </p>
<p>父类接口看完了，接下来看看 <code>SecurityManager</code> 里面的方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SecurityManager</span> <span class="keyword">extends</span> <span class="title">Authenticator</span>, <span class="title">Authorizer</span>, <span class="title">SessionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Subject <span class="title">login</span><span class="params">(Subject subject, AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logout</span><span class="params">(Subject subject)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Subject <span class="title">createSubject</span><span class="params">(SubjectContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法很少，登录，登出，创建 <code>Subject</code> （接口），这个对象代表用户，他本身可以验证权限<br><code>SubjectContext</code> 里面继承 Map 添加了一些属性的 get set 方法，比如 <code>SecurityManager</code>, <code>sessionId</code>, <code>Subject</code> … 可以自己看<br>下面看看 <code>SecurityManager</code> 的实现，继承关系非常简单，一条直线，看类名就清楚每层是干什么的了  </p>
<p><code>CachingSecurityManager</code><br>这层直接继承 <code>SecurityManager</code> 里面有一个 <code>CacheManager</code> 当调用 <code>setCacheManager</code> 会调用 <code>afterCacheManagerSet</code> 这个是空方法，子类实现<br>很清楚，这一层只是加上了缓存管理，至于缓存怎么用，要看子类  </p>
<p><code>RealmSecurityManager</code><br><code>Realm</code> 这个是很关键的接口，可以代表数据源，无论认证还是授权，具体数据都是从 <code>Realm</code> 里面取的<br>这里维护了一个 <code>Collection&lt;Realm&gt;</code> 集合，当完成 <code>setRealms</code> 调用后会触发 <code>afterRealmsSet</code> 方法<br>现在的默认实现是如果 <code>Realm</code> 实现了 <code>CacheManagerAware</code> 接口，就把上层的 <code>CacheManager</code> 设置进去  </p>
<p><code>AuthenticatingSecurityManager</code><br>这一层看名字就大概知道了，处理认证的，内部一个 <code>Authenticator</code> 实现，用来处理认证方法<br>默认的实现是 <code>ModularRealmAuthenticator</code>  是基于一个 <code>Realm</code> 的认证器，在 <code>afterRealmsSet</code> 方法，设置的 <code>Realm</code> 也会设置到这里面<br>然后将认证方法 <code>authenticate</code> 委托给内部的 <code>Authenticator</code> 实现了<br>后面具体看看 <code>ModularRealmAuthenticator</code> 的实现，大部分时候，我们不会修改这个实现  </p>
<p><code>AuthorizingSecurityManager</code><br>跟上面认证一样，内部一个 <code>Authorizer</code> 实例，将授权相关的方法全部委托给内部实例处理，默认是 <code>ModularRealmAuthorizer</code><br>也是基于 <code>Realm</code> 的实现，后面具体看看 <code>ModularRealmAuthorizer</code> 内部实现  </p>
<p><code>SessionsSecurityManager</code><br>同上，内部 <code>SessionManager</code> 的默认实现为 <code>DefaultSessionManager</code>，相关方法委托<br>构造或者 set 了 <code>SessionManager</code> 后会触发 <code>afterSessionManagerSet</code> 方法，<br>目前的实现是，如果 <code>SessionManager</code> 实现接口 <code>CacheManagerAware</code> 就把上层的 <code>CacheManager</code> 设置进去  </p>
<p><code>DefaultSecurityManager</code><br>上面三层分别处理了 <code>Authenticator, Authorizer, SessionManager</code> 接口<br>这一层重点有3个属性<br><code>RememberMeManager</code><br><code>SubjectDAO</code>  默认实现 <code>DefaultSubjectDAO</code><br><code>SubjectFactory</code> 默认实现 <code>DefaultSubjectFactory</code><br>这个里面要实现 <code>SecurityManager</code> 接口自己的3个方法 <code>login</code>, <code>logout</code>, <code>createSubject</code>  </p>
<ol>
<li><p>login </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Subject <span class="title">login</span><span class="params">(Subject subject, AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">	AuthenticationInfo info;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		info = authenticate(token);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (AuthenticationException ae) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			onFailedLogin(token, ae, subject);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">				log.info(<span class="string">"onFailedLogin method threw an "</span> +</span><br><span class="line">						<span class="string">"exception.  Logging and propagating original AuthenticationException."</span>, e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> ae; <span class="comment">//propagate</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Subject loggedIn = createSubject(token, info, subject);</span><br><span class="line"></span><br><span class="line">	onSuccessfulLogin(token, info, loggedIn);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> loggedIn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑很简单，这里就不细讲了<br>其中 <code>onFailedLogin</code> 和 <code>onSuccessfulLogin</code> 分别触发 <code>rememberMeFailedLogin</code>, <code>rememberMeFailedLogin</code> ，里面又是调用 <code>RememberMeManager</code> (如果存在) 的方法  </p>
</li>
<li><p>logout</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (subject == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Subject method argument cannot be null."</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	beforeLogout(subject);</span><br><span class="line"></span><br><span class="line">	PrincipalCollection principals = subject.getPrincipals();</span><br><span class="line">	<span class="keyword">if</span> (principals != <span class="keyword">null</span> &amp;&amp; !principals.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">			log.debug(<span class="string">"Logging out subject with primary principal &#123;&#125;"</span>, principals.getPrimaryPrincipal());</span><br><span class="line">		&#125;</span><br><span class="line">		Authenticator authc = getAuthenticator();</span><br><span class="line">		<span class="keyword">if</span> (authc <span class="keyword">instanceof</span> LogoutAware) &#123;</span><br><span class="line">			((LogoutAware) authc).onLogout(principals);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		delete(subject);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		<span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">			String msg = <span class="string">"Unable to cleanly unbind Subject.  Ignoring (logging out)."</span>;</span><br><span class="line">			log.debug(msg, e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			stopSession(subject);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">				String msg = <span class="string">"Unable to cleanly stop Session for Subject ["</span> + subject.getPrincipal() + <span class="string">"] "</span> +</span><br><span class="line">						<span class="string">"Ignoring (logging out)."</span>;</span><br><span class="line">				log.debug(msg, e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑也不复杂，先触发 <code>beforeLogout</code> 方法，当前实现是 <code>rememberMeLogout</code> 调用 <code>RememberMeManager</code><br>然后如果认证器需要感知登出操作 <code>LogoutAware</code> 也去触发<br>删除 subject 和 停止 session<br>这里面可以看到 <code>SubjectDAO</code> 主要做 subject 的增删改查  </p>
</li>
<li><p>createSubject</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Subject <span class="title">createSubject</span><span class="params">(SubjectContext subjectContext)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//create a copy so we don't modify the argument's backing map:</span></span><br><span class="line">	SubjectContext context = copy(subjectContext);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ensure that the context has a SecurityManager instance, and if not, add one:</span></span><br><span class="line">	context = ensureSecurityManager(context);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 重点在这里，这里会拿到 session （session 存储在服务端，根据 sessionId（sessionKey） 来获取）</span></span><br><span class="line">	context = resolveSession(context);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Similarly, the SubjectFactory should not require any concept of RememberMe - translate that here first</span></span><br><span class="line">	<span class="comment">//if possible before handing off to the SubjectFactory:</span></span><br><span class="line">	context = resolvePrincipals(context);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里创建的时候，会把 session 里面的一些信息带出来</span></span><br><span class="line">	Subject subject = doCreateSubject(context);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//save this subject for future reference if necessary:</span></span><br><span class="line">	<span class="comment">//(this is needed here in case rememberMe principals were resolved and they need to be stored in the</span></span><br><span class="line">	<span class="comment">//session, so we don't constantly rehydrate the rememberMe PrincipalCollection on every operation).</span></span><br><span class="line">	<span class="comment">//Added in 1.2:</span></span><br><span class="line">	save(subject);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> subject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>登录成功后，会创建 <code>SubjectContext</code> 然后调用这个方法<br>后面可以详细看看 <code>SubjectDAO</code> <code>SubjectFactory</code>, <code>RememberMeManager</code>(没有默认值)<br>到这里，就已经可以用了，最后一层是对 web 应用的适配  </p>
</li>
</ol>
<p><code>DefaultWebSecurityManager</code><br>这里面将一些相关类，全部换成 web 的实现了（大部分都是从之前的类继承下来的）<br>后面详看 </p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>之前说过了，认证是委托给内部实现了，我们直接看具体实现 <code>ModularRealmAuthenticator</code><br>继承 <code>AbstractAuthenticator</code> 这里面维护 <code>AuthenticationListener</code> 列表，在登录成功，失败，和登出的时候用来回调（观察者模式）,<br>同时实现了 <code>authenticate</code> 固定了登录实现流程，留出一个 <code>doAuthenticate</code> 抽象方法子类实现（模版）  </p>
<p><code>ModularRealmAuthenticator</code> 是基于 <code>Realm</code> 的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doAuthenticate</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">	assertRealmsConfigured();</span><br><span class="line">	Collection&lt;Realm&gt; realms = getRealms();</span><br><span class="line">	<span class="keyword">if</span> (realms.size() == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> doSingleRealmAuthentication(realms.iterator().next(), authenticationToken);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> doMultiRealmAuthentication(realms, authenticationToken);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中 <code>doSingleRealmAuthentication</code> 好里面，只有一个认证数据源的时候<br>如果 <code>realm</code> 没返回 info 直接异常<br><code>doMultiRealmAuthentication</code> 就涉及到认证策略了，其中有至少一次，第一次成功，全部成功<br>策略接口是 <code>AuthenticationStrategy</code> 里面有四个方法，</p>
<ol>
<li>所有 realm 认证之前</li>
<li>每个 realm 认证之前</li>
<li>每个 realm 认证之后</li>
<li>所有 realm 认证之后<br>通过这4个方法，在合适的地方抛异常，就可以实现各种策略了，通常不需要我们自己重写，或者自己实现策略<br>默认是至少一个认证成功  </li>
</ol>
<p>我们看看 <code>Realm</code> 接口<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Realm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(AuthenticationToken token)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">AuthenticationInfo <span class="title">getAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中就有从 token 获取 info 的接口，所以认证就很简单了  </p>
<h3 id="权限验证"><a href="#权限验证" class="headerlink" title="权限验证"></a>权限验证</h3><p><code>ModularRealmAuthorizer</code> 内部实现<br>里面主要涉及有两个相关类 <code>PermissionResolver</code> <code>RolePermissionResolver</code><br>至于权限验证，还是 <code>Realm</code> 做的，找到 <code>Realm</code> 里面也实现 <code>Authorizer</code> 的去验证<br>针对多值交易，只要任意一个 <code>Reaml</code> 里面认证通过<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPermitted</span><span class="params">(PrincipalCollection principals, Permission permission)</span> </span>&#123;</span><br><span class="line">	assertRealmsConfigured();</span><br><span class="line">	<span class="keyword">for</span> (Realm realm : getRealms()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(realm <span class="keyword">instanceof</span> Authorizer)) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (((Authorizer) realm).isPermitted(principals, permission)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span>[] isPermitted(PrincipalCollection principals, String... permissions) &#123;</span><br><span class="line">	assertRealmsConfigured();</span><br><span class="line">	<span class="keyword">if</span> (permissions != <span class="keyword">null</span> &amp;&amp; permissions.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">boolean</span>[] isPermitted = <span class="keyword">new</span> <span class="keyword">boolean</span>[permissions.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; permissions.length; i++) &#123;</span><br><span class="line">			isPermitted[i] = isPermitted(principals, permissions[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> isPermitted;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>瞅一眼代码就清楚了，那么现在无聊是 认证，还是授权，关键又在 <code>Realm</code> 那里去了  </p>
<h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h3><p>我们需要看看 <code>Realm</code> 的继承体系了<br>跟 manage 的继承体系一样，<br>首先是 <code>CachingRealm</code> 获取 <code>CacheManager</code><br>接着  <code>AuthenticatingRealm</code> </p>
<p>这里有认证流程<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AuthenticationInfo <span class="title">getAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">	AuthenticationInfo info = getCachedAuthenticationInfo(token);</span><br><span class="line">	<span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//otherwise not cached, perform the lookup:</span></span><br><span class="line">		info = doGetAuthenticationInfo(token);</span><br><span class="line">		log.debug(<span class="string">"Looked up AuthenticationInfo [&#123;&#125;] from doGetAuthenticationInfo"</span>, info);</span><br><span class="line">		<span class="keyword">if</span> (token != <span class="keyword">null</span> &amp;&amp; info != <span class="keyword">null</span>) &#123;</span><br><span class="line">			cacheAuthenticationInfoIfPossible(token, info);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.debug(<span class="string">"Using cached authentication info [&#123;&#125;] to perform credentials matching."</span>, info);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">		assertCredentialsMatch(token, info);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.debug(<span class="string">"No AuthenticationInfo found for submitted AuthenticationToken [&#123;&#125;].  Returning null."</span>, token);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上层就是调用这里，先从缓存里面获取，没有就调用 <code>doGetAuthenticationInfo</code> 方法（抽象）<br>有返回值，就对比 Credentials<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">assertCredentialsMatch</span><span class="params">(AuthenticationToken token, AuthenticationInfo info)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">	CredentialsMatcher cm = getCredentialsMatcher();</span><br><span class="line">	<span class="keyword">if</span> (cm != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!cm.doCredentialsMatch(token, info)) &#123;</span><br><span class="line">			<span class="comment">//not successful - throw an exception to indicate this:</span></span><br><span class="line">			String msg = <span class="string">"Submitted credentials for token ["</span> + token + <span class="string">"] did not match the expected credentials."</span>;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IncorrectCredentialsException(msg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationException(<span class="string">"A CredentialsMatcher must be configured in order to verify "</span> +</span><br><span class="line">				<span class="string">"credentials during authentication.  If you do not wish for credentials to be examined, you "</span> +</span><br><span class="line">				"can configure an " + AllowAllCredentialsMatcher.class.getName() + " instance.");</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体怎么对比的，后面可以看看 <code>CredentialsMatcher</code> 实现，里面有一套基于密码 hash 的对比方式<br>顺便说一句，这里的 cache 的 key 是 Principal 对象，自定义的对象一定要重新 hashcode 方法  </p>
<p>最后一层就是<br><code>AuthorizingRealm</code><br>这里就是验证权限的<br>权限表达式的解析由 <code>PermissionResolver</code> 处理，里面默认实现是 <code>WildcardPermissionResolver</code><br>规则是 resource:operation  可以多个 : 分割 ,包含多个操作 * 包含所有<br>验证权限，首先得获取到权限数据源里面的权限 <code>doGetAuthorizationInfo</code> 留了一个抽象方法，通过凭证(用户名)来获取权限信息<br>这一层主要处理缓存和匹配<br>到这里就已经结束了，这下面的实现就是具体实现了，譬如 <code>JdbcRealm</code> 等。<br>通常我们都是自定义 <code>Realm</code> 只要继承这个类 <code>AuthorizingRealm</code> 重写获取认证信息和权限信息的方法就可以了  </p>
<h3 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h3><p>这是一个很重要的接口，需要单独拿出来讲 <code>SecurityUtils.getSubject</code> 获取的当前用户，总是非 null 的<br>但是非null，不代表已经认证过了，或者有权限， 如果当前用户没有登录，是会新建一个的<br>通过 subject 对象 可以做登录验证权限操作，和登出操作<br>其实他是包装了 <code>SecurityManager</code> 对象，只是用来表示用户而已  </p>
<p>其实到这里 shiro 的核心包已经看完了<br>但是 shiro 可以跟 web 集成，有 shiro-web 包<br>这个里面其实就一堆过滤器有点有，但是过滤器里面人认证权限校验，还是使用 <code>SecurityUtils.getSubject</code> 获取当前用户<br>然后使用 <code>Subject</code> 的 api 进行权限校验，至于其他的 web 相关的类，大部分都是继承了上面的那些，多了 <code>Request</code> 和 <code>Response</code> 一般都不会用这里的对象的（不排除会用，也可以仔细看看） </p>
<p>web 里面重点的有 <code>AbstractShiroFilter</code> 拦截器 ，<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, <span class="keyword">final</span> FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Throwable t = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> ServletRequest request = prepareServletRequest(servletRequest, servletResponse, chain);</span><br><span class="line">		<span class="keyword">final</span> ServletResponse response = prepareServletResponse(request, servletResponse, chain);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">final</span> Subject subject = createSubject(request, response);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//noinspection unchecked</span></span><br><span class="line">		subject.execute(<span class="keyword">new</span> Callable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				updateSessionLastAccessTime(request, response);</span><br><span class="line">				executeChain(request, response, chain);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (ExecutionException ex) &#123;</span><br><span class="line">		t = ex.getCause();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">		t = throwable;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (t <span class="keyword">instanceof</span> ServletException) &#123;</span><br><span class="line">			<span class="keyword">throw</span> (ServletException) t;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (t <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">			<span class="keyword">throw</span> (IOException) t;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//otherwise it's not one of the two exceptions expected by the filter method signature - wrap it in one:</span></span><br><span class="line">		String msg = <span class="string">"Filtered request failed."</span>;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ServletException(msg, t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它会在进入拦截器之前创建 subject 并且绑定当前线程，这样 <code>SecurityUtils.getSubject</code> 就可以正常使用了<br>这里是根据 session 实现的，如果自定义(jjwt) , 那就需要自己定义拦截器，放在最前面进行处理</p>
<p>认证授权，除了可以用在 url 拦截上，还可以用在 方法上，使用 aop （shiro 注解的封装感觉很不错）<br>web 相关的，可以自己细看，下面重点说说与 spring 集成  </p>
<h3 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h3><p>shiro-spring 里面的内容很少<br>重要的只有几个东西  </p>
<ol>
<li><p>LifecycleBeanPostProcessor 这个是用来处理 shiro 内置的生命周期的，将这个注册为 spring 的 bean 那么 shiro 里面的生命周期，就跟 spring bean 的生命周期绑定了<br>主要是 shiro 的两个接口的实现类，都需要注册到 bean ，来处理生命周期 主要是 <code>SecurityManager</code> 和 <code>Realm</code>  还有 <code>Environment</code> 的实现的实现<br>值得注意的一点是，如果你不在乎生命周期，这些，你都可以不注册为 bean </p>
</li>
<li><p>AuthorizationAttributeSourceAdvisor  这个是用来处理 shiro 的注解的，借助 spring-aop 实现的，至于原理，在 aop 里面已经分析过了<br>注解是用来保证方法级别的权限，通常不是必须的，因为功能是通过 http 接口开放出去的，如果有 rpc 相关的，可以使用这个注解<br>因此，只有当你确实需要使用注解，才将这个类注册为 bean， 否则，这个不是必须的 </p>
</li>
<li><p><code>ShiroFilterFactoryBean</code> 这个是用来注册 shiro 的 Filter 的，用来在 http 调用接口的层面做权限控制，web 项目，通常这个是必须要配置的<br>如果你只想用 注解的方式，这个也是可以不注册为 bean 的，里面的 shiro 的 filter 都有 name 的，具体可以看内部的 <code>DefaultFilter</code> 类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">anon(AnonymousFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class"><span class="title">authc</span>(<span class="title">FormAuthenticationFilter</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class"><span class="title">authcBasic</span>(<span class="title">BasicHttpAuthenticationFilter</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class"><span class="title">logout</span>(<span class="title">LogoutFilter</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class"><span class="title">noSessionCreation</span>(<span class="title">NoSessionCreationFilter</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class"><span class="title">perms</span>(<span class="title">PermissionsAuthorizationFilter</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class"><span class="title">port</span>(<span class="title">PortFilter</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class"><span class="title">rest</span>(<span class="title">HttpMethodPermissionFilter</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class"><span class="title">roles</span>(<span class="title">RolesAuthorizationFilter</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class"><span class="title">ssl</span>(<span class="title">SslFilter</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class"><span class="title">user</span>(<span class="title">UserFilter</span>.<span class="title">class</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>顺便说一句，这里是  factoryBean，他的 getObject 方法返回的实例，才是真实使用的,实际上是 <code>AbstractShiroFilter</code> 类型的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringShiroFilter</span> <span class="keyword">extends</span> <span class="title">AbstractShiroFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">SpringShiroFilter</span><span class="params">(WebSecurityManager webSecurityManager, FilterChainResolver resolver)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">if</span> (webSecurityManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"WebSecurityManager property cannot be null."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		setSecurityManager(webSecurityManager);</span><br><span class="line">		<span class="keyword">if</span> (resolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">			setFilterChainResolver(resolver);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud-openFeign 研究</title>
    <url>/2019/10/14/spring-cloud-openFeign-%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<p>这是一篇简单的，<code>openFeign</code> 的源码分析<br>会涉及到 <code>ribbon</code> <code>Hystrix</code><br>不过其中 openFeign 的内容比较简单，其实核心难度在 <code>Hystrix</code>,这个以后有时间看<br>先上一张图。画的很挫。也算是分析思路吧。。  </p>
<img src="/2019/10/14/spring-cloud-openFeign-%E7%A0%94%E7%A9%B6/feign%E5%88%86%E6%9E%90.svg" class="" title="This is an example image">  
<p>主要是从代理构建和方法调用两条线进行分析，下面基本都是代码了  </p>
<p>spring-boot 版本 2.1.5.RELEASE<br>spring-cloud 版本 Greenwich.SR1<br>官方示例很简单<br>配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心就是 @EnableFeignClients 注解，这也是配置入口，我们等会从这里开始看<br>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"stores"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StoreClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(method = RequestMethod.GET, value = <span class="string">"/stores"</span>)</span><br><span class="line">    <span class="function">List&lt;Store&gt; <span class="title">getStores</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(method = RequestMethod.POST, value = <span class="string">"/stores/&#123;storeId&#125;"</span>, consumes = <span class="string">"application/json"</span>)</span><br><span class="line">    <span class="function">Store <span class="title">update</span><span class="params">(@PathVariable(<span class="string">"storeId"</span>)</span> Long storeId, Store store)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心是 @FeignClient 注解<br>方法里面就是 spring-mvc 里面的注解了</p>
<p>首先来看配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(FeignClientsRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableFeignClients</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Alias for the &#123;<span class="doctag">@link</span> #basePackages()&#125; attribute. Allows for more concise annotation</span></span><br><span class="line"><span class="comment">    * declarations e.g.: &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>("org.my.pkg")&#125; instead of</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>(basePackages="org.my.pkg")&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the array of 'basePackages'.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Base packages to scan for annotated components.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #value()&#125; is an alias for (and mutually exclusive with) this attribute.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Use &#123;<span class="doctag">@link</span> #basePackageClasses()&#125; for a type-safe alternative to String-based</span></span><br><span class="line"><span class="comment">    * package names.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the array of 'basePackages'.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Type-safe alternative to &#123;<span class="doctag">@link</span> #basePackages()&#125; for specifying the packages to</span></span><br><span class="line"><span class="comment">    * scan for annotated components. The package of each class specified will be scanned.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Consider creating a special no-op marker class or interface in each package that</span></span><br><span class="line"><span class="comment">    * serves no purpose other than being referenced by this attribute.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the array of 'basePackageClasses'.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A custom &lt;code&gt;<span class="doctag">@Configuration</span>&lt;/code&gt; for all feign clients. Can contain override</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;<span class="doctag">@Bean</span>&lt;/code&gt; definition for the pieces that make up the client, for instance</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> feign.codec.Decoder&#125;, &#123;<span class="doctag">@link</span> feign.codec.Encoder&#125;, &#123;<span class="doctag">@link</span> feign.Contract&#125;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> FeignClientsConfiguration for the defaults</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> list of default configurations</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   Class&lt;?&gt;[] defaultConfiguration() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * List of classes annotated with <span class="doctag">@FeignClient</span>. If not empty, disables classpath</span></span><br><span class="line"><span class="comment">    * scanning.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> list of FeignClient classes</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   Class&lt;?&gt;[] clients() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面最核心的一行就是 @Import(FeignClientsRegistrar.class)<br>注解里面的属性，都是特殊的配置，具体的含义，我们后面继续看<br>接下面看看 FeignClientsRegistrar 的处理，这是跟 spring 集成的关键，所有基于 spring-boot 的，只要有类似这样的注解，都是这样看的，如果没有注解，那就看 META-INF/spring.factory 文件里面的自动配置<br>核心方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   registerDefaultConfiguration(metadata, registry);</span><br><span class="line">   registerFeignClients(metadata, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要做两件事，注册对应的 配置类 为 bean 注册 client 为 bean<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDefaultConfiguration</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   Map&lt;String, Object&gt; defaultAttrs = metadata</span><br><span class="line">         .getAnnotationAttributes(EnableFeignClients<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (defaultAttrs != <span class="keyword">null</span> &amp;&amp; defaultAttrs.containsKey(<span class="string">"defaultConfiguration"</span>)) &#123;</span><br><span class="line">      String name;</span><br><span class="line">      <span class="keyword">if</span> (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">         name = <span class="string">"default."</span> + metadata.getEnclosingClassName();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         name = <span class="string">"default."</span> + metadata.getClassName();</span><br><span class="line">      &#125;</span><br><span class="line">      registerClientConfiguration(registry, name,</span><br><span class="line">            defaultAttrs.get(<span class="string">"defaultConfiguration"</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就是注册全局默认配置，可以看到，从 EnableFeignClients 获取了 defaultConfiguration 属性，默认是空的<br>如果有，就可以注册全局默认配置，至于这个配置有什么用，可以配置什么，后面看看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerClientConfiguration</span><span class="params">(BeanDefinitionRegistry registry, Object name,</span></span></span><br><span class="line"><span class="function"><span class="params">      Object configuration)</span> </span>&#123;</span><br><span class="line">   BeanDefinitionBuilder builder = BeanDefinitionBuilder</span><br><span class="line">         .genericBeanDefinition(FeignClientSpecification<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   builder.addConstructorArgValue(name);</span><br><span class="line">   builder.addConstructorArgValue(configuration);</span><br><span class="line">   registry.registerBeanDefinition(</span><br><span class="line">         name + <span class="string">"."</span> + FeignClientSpecification<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>(),</span></span><br><span class="line"><span class="class">         <span class="title">builder</span>.<span class="title">getBeanDefinition</span>())</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里很明确，就是注册 配置 bean ，目前默认配置，和每个 client 的单独配置都是通过这个方法注册的<br>可以看到具体的 bean 是 FeignClientSpecification 将 name 和自定义配置 当做构造参数传进去了<br>后面详细看看 FeignClientSpecification<br>继续看注册 client</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFeignClients</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 这是一个基础扫描类，过滤条件是 独立类（非内部类），非注解</span></span><br><span class="line">   ClassPathScanningCandidateComponentProvider scanner = getScanner();</span><br><span class="line">   scanner.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">   Set&lt;String&gt; basePackages;</span><br><span class="line"></span><br><span class="line">   Map&lt;String, Object&gt; attrs = metadata</span><br><span class="line">         .getAnnotationAttributes(EnableFeignClients<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">   <span class="comment">// 这里看到，处理 client 的注解 @FeignClient</span></span><br><span class="line">   AnnotationTypeFilter annotationTypeFilter = <span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">         FeignClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="keyword">final</span> Class&lt;?&gt;[] clients = attrs == <span class="keyword">null</span> ? <span class="keyword">null</span></span><br><span class="line">         : (Class&lt;?&gt;[]) attrs.get(<span class="string">"clients"</span>);</span><br><span class="line">   <span class="comment">// 这里是对 @EnableFeignClients 注解的 clients 属性支持，可以直接指定有 @FeignClient 注释的接口</span></span><br><span class="line">   <span class="keyword">if</span> (clients == <span class="keyword">null</span> || clients.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 默认是空的，也就是走正常的类扫描</span></span><br><span class="line">      scanner.addIncludeFilter(annotationTypeFilter);</span><br><span class="line">      <span class="comment">// 获取要扫描的包，从注解 @EnableFeignClients 读取 value  basePackages  basePackageClasses 所在的包</span></span><br><span class="line">      <span class="comment">// 如果上面没获取到（默认都是空的），就扫描 @EnableFeignClients 注解标记的类所在的包</span></span><br><span class="line">      basePackages = getBasePackages(metadata);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果自己直接指定了 client ，那么只取指定的</span></span><br><span class="line">      <span class="keyword">final</span> Set&lt;String&gt; clientClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      basePackages = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; clazz : clients) &#123;</span><br><span class="line">         basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">         clientClasses.add(clazz.getCanonicalName());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 也需要走过滤</span></span><br><span class="line">      AbstractClassTestingTypeFilter filter = <span class="keyword">new</span> AbstractClassTestingTypeFilter() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(ClassMetadata metadata)</span> </span>&#123;</span><br><span class="line">            String cleaned = metadata.getClassName().replaceAll(<span class="string">"\\$"</span>, <span class="string">"."</span>);</span><br><span class="line">            <span class="keyword">return</span> clientClasses.contains(cleaned);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      scanner.addIncludeFilter(</span><br><span class="line">            <span class="keyword">new</span> AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 扫描，是 spirng 的工具类，细节不看</span></span><br><span class="line">   <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">      Set&lt;BeanDefinition&gt; candidateComponents = scanner</span><br><span class="line">            .findCandidateComponents(basePackage);</span><br><span class="line">      <span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">         <span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">            <span class="comment">// verify annotated class is an interface</span></span><br><span class="line">            AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">            AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();</span><br><span class="line">            <span class="comment">// client 只能是接口</span></span><br><span class="line">            Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line">                  <span class="string">"@FeignClient can only be specified on an interface"</span>);</span><br><span class="line">            <span class="comment">// 获取 @FeignClient 注解的熟悉</span></span><br><span class="line">            Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">                  .getAnnotationAttributes(</span><br><span class="line">                        FeignClient<span class="class">.<span class="keyword">class</span>.<span class="title">getCanonicalName</span>())</span>;</span><br><span class="line">            <span class="comment">// 获取 name，就是 @FeignClient 里面的熟悉  contextId  value  name  serviceId  按照顺序获取</span></span><br><span class="line">            String name = getClientName(attributes);</span><br><span class="line">            <span class="comment">// 注册 client 对应的 config ，可以 @FeignClient 配置自定义的 configuration ，默认是空</span></span><br><span class="line">            registerClientConfiguration(registry, name,</span><br><span class="line">                  attributes.get(<span class="string">"configuration"</span>));</span><br><span class="line">            <span class="comment">// 注册 client bean</span></span><br><span class="line">            registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面都加了注释了，看看注册 client 的 bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerFeignClient</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">      AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">   String className = annotationMetadata.getClassName();</span><br><span class="line">   <span class="comment">// 注意这里的 factoryBean  FeignClientFactoryBean</span></span><br><span class="line">   BeanDefinitionBuilder definition = BeanDefinitionBuilder</span><br><span class="line">         .genericBeanDefinition(FeignClientFactoryBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   validate(attributes);</span><br><span class="line">   <span class="comment">// url 默认是空，这里应该是直连时候指定url</span></span><br><span class="line">   definition.addPropertyValue(<span class="string">"url"</span>, getUrl(attributes));</span><br><span class="line">   <span class="comment">// path 是 basePath</span></span><br><span class="line">   definition.addPropertyValue(<span class="string">"path"</span>, getPath(attributes));</span><br><span class="line">   <span class="comment">// 这里 name 的获取顺序是 serviceId  name value   支持 placeholder 也就是 $&#123;&#125;</span></span><br><span class="line">   String name = getName(attributes);</span><br><span class="line">   definition.addPropertyValue(<span class="string">"name"</span>, name);</span><br><span class="line">   <span class="comment">// 取 contextId ，如果为空，那就用 getName 获取，也就是上面的 name 默认是一样的</span></span><br><span class="line">   String contextId = getContextId(attributes);</span><br><span class="line">   definition.addPropertyValue(<span class="string">"contextId"</span>, contextId);</span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">   definition.addPropertyValue(<span class="string">"type"</span>, className);</span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">   definition.addPropertyValue(<span class="string">"decode404"</span>, attributes.get(<span class="string">"decode404"</span>));</span><br><span class="line">   <span class="comment">// 容错类</span></span><br><span class="line">   definition.addPropertyValue(<span class="string">"fallback"</span>, attributes.get(<span class="string">"fallback"</span>));</span><br><span class="line">   <span class="comment">// 容错工程类</span></span><br><span class="line">   definition.addPropertyValue(<span class="string">"fallbackFactory"</span>, attributes.get(<span class="string">"fallbackFactory"</span>));</span><br><span class="line">   definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">   <span class="comment">// 可以看到，别名，默认就是 自己设置的 name + "FeignClient"</span></span><br><span class="line">   String alias = contextId + <span class="string">"FeignClient"</span>;</span><br><span class="line">   AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> primary = (Boolean) attributes.get(<span class="string">"primary"</span>); <span class="comment">// has a default, won't be</span></span><br><span class="line">                                             <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">   beanDefinition.setPrimary(primary);</span><br><span class="line">   <span class="comment">// 相当于自己设置别名</span></span><br><span class="line">   String qualifier = getQualifier(attributes);</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">      alias = qualifier;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, className,</span><br><span class="line">         <span class="keyword">new</span> String[] &#123; alias &#125;);</span><br><span class="line">   BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看注册的 配置类 FeignClientSpecification</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeignClientSpecification</span> <span class="keyword">implements</span> <span class="title">NamedContextFactory</span>.<span class="title">Specification</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Class&lt;?&gt;[] configuration;</span><br><span class="line"></span><br><span class="line">   FeignClientSpecification() &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   FeignClientSpecification(String name, Class&lt;?&gt;[] configuration) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Class&lt;?&gt;[] getConfiguration() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.configuration;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfiguration</span><span class="params">(Class&lt;?&gt;[] configuration)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      FeignClientSpecification that = (FeignClientSpecification) o;</span><br><span class="line">      <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.name, that.name)</span><br><span class="line">            &amp;&amp; Arrays.equals(<span class="keyword">this</span>.configuration, that.configuration);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Objects.hash(<span class="keyword">this</span>.name, <span class="keyword">this</span>.configuration);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(<span class="string">"FeignClientSpecification&#123;"</span>).append(<span class="string">"name='"</span>)</span><br><span class="line">            .append(<span class="keyword">this</span>.name).append(<span class="string">"', "</span>).append(<span class="string">"configuration="</span>)</span><br><span class="line">            .append(Arrays.toString(<span class="keyword">this</span>.configuration)).append(<span class="string">"&#125;"</span>).toString();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没啥看的，<br>再看看 client 的 FeignClientFactoryBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> getTarget();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &lt;T&gt; the target type of the Feign client</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> Feign&#125; client created with the specified data and the context</span></span><br><span class="line"><span class="comment">* information</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// FeignContext 是在 autoconfiguration 的时候注册的</span></span><br><span class="line">   FeignContext context = <span class="keyword">this</span>.applicationContext.getBean(FeignContext<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="comment">// 配置分为三层，默认 - 全局 - 单个client 每个配置类实际上是一个 @Configuration 标记的 spring 配置类</span></span><br><span class="line">   <span class="comment">// context 内部为每个 client 都构建了一个 ApplicationContext parent 指向默认的 context</span></span><br><span class="line">   <span class="comment">// 里面配置类的解析顺序为 单个 - 全局 - 默认 构建内部的 bean</span></span><br><span class="line">   <span class="comment">// 这个方法里面，构建 Feign.Builder 设置 logger encoder decoder contract</span></span><br><span class="line">   <span class="comment">// 然后根据 FeignClientProperties 配置，设置 loggerLevel retryer errorDecoder request.options requestInterceptor decode404 配置</span></span><br><span class="line">   <span class="comment">// 如果自定义配置或者全局配置里面有 logger encoder decoder contract 这里也重新设置</span></span><br><span class="line">   Feign.Builder builder = feign(context);</span><br><span class="line">   <span class="comment">// 默认 url 是没有的</span></span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.name.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line">         <span class="keyword">this</span>.url = <span class="string">"http://"</span> + <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.url = <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.url += cleanPath();</span><br><span class="line">      <span class="comment">// so 大部分应该走这里</span></span><br><span class="line">      <span class="keyword">return</span> (T) loadBalance(builder, context,</span><br><span class="line">            <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type, <span class="keyword">this</span>.name, <span class="keyword">this</span>.url));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url) &amp;&amp; !<span class="keyword">this</span>.url.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.url = <span class="string">"http://"</span> + <span class="keyword">this</span>.url;</span><br><span class="line">   &#125;</span><br><span class="line">   String url = <span class="keyword">this</span>.url + cleanPath();</span><br><span class="line">   Client client = getOptional(context, Client<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// url 存在，代表直连，lodbalance 就不需要了</span></span><br><span class="line">      <span class="keyword">if</span> (client <span class="keyword">instanceof</span> LoadBalancerFeignClient) &#123;</span><br><span class="line">         <span class="comment">// not load balancing because we have a url,</span></span><br><span class="line">         <span class="comment">// but ribbon is on the classpath, so unwrap</span></span><br><span class="line">         client = ((LoadBalancerFeignClient) client).getDelegate();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取默认的 client</span></span><br><span class="line">      builder.client(client);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 构建</span></span><br><span class="line">   Targeter targeter = get(context, Targeter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="keyword">return</span> (T) targeter.target(<span class="keyword">this</span>, builder, context,</span><br><span class="line">         <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧，大概看了下里面的实现，这里其实是生成一个代理的过程，但是又与标准的动态代理不一样<br>构建过程在 builder 里面，之前的 logger encoder deocder contract 等是按照 client 实例配置  default 全局配置  默认配置 的 顺序启用的<br>client 的实例配置，就是在客户端接口注解 @FeignClient 配置的，default 全局配置，则是 @EnableFeignClients 注解里面配置的<br>至于默认配置，是基于 spring-boot 的自动配置 ，这里面也分情况，根据是否存在 ribbon ，有不同的注入配置<br>等会，突然发现上面三层配置，创建 context 的机制是 spring-cloud 里面的东西<br>先来看下基于 ribbon的自动配置，这里默认情况的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里 ILoadBalancer 是 ribbon 包里面的  Feign 就是 feign 了</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; ILoadBalancer<span class="class">.<span class="keyword">class</span>, <span class="title">Feign</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">Configuration</span></span></span><br><span class="line"><span class="class">// 这里，要在 <span class="title">feign</span> 默认配置之前先处理</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureBefore</span>(<span class="title">FeignAutoConfiguration</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">// 开启自定义参数配置</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(</span>&#123; FeignHttpClientProperties<span class="class">.<span class="keyword">class</span> &#125;)</span></span><br><span class="line"><span class="class">// <span class="title">Order</span> <span class="title">is</span> <span class="title">important</span> <span class="title">here</span>, <span class="title">last</span> <span class="title">should</span> <span class="title">be</span> <span class="title">the</span> <span class="title">default</span>, <span class="title">first</span> <span class="title">should</span> <span class="title">be</span> <span class="title">optional</span></span></span><br><span class="line"><span class="class">// <span class="title">see</span></span></span><br><span class="line">// https://github.com/spring-cloud/spring-cloud-netflix/issues/2086#issuecomment-316281653</span><br><span class="line"><span class="comment">// 上面有注释，顺序很重要，就是 FeignLoadBalanced 的自动配置</span></span><br><span class="line"><span class="meta">@Import</span>(&#123; HttpClientFeignLoadBalancedConfiguration<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">      <span class="title">OkHttpFeignLoadBalancedConfiguration</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">      <span class="title">DefaultFeignLoadBalancedConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">FeignRibbonClientAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@Primary</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingClass</span>(<span class="string">"org.springframework.retry.support.RetryTemplate"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> CachingSpringLoadBalancerFactory <span class="title">cachingLBClientFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         SpringClientFactory factory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> CachingSpringLoadBalancerFactory(factory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@Primary</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="meta">@ConditionalOnClass</span>(name = <span class="string">"org.springframework.retry.support.RetryTemplate"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> CachingSpringLoadBalancerFactory <span class="title">retryabeCachingLBClientFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         SpringClientFactory factory, LoadBalancedRetryFactory retryFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> CachingSpringLoadBalancerFactory(factory, retryFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="keyword">public</span> Request.<span class="function">Options <span class="title">feignRequestOptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> LoadBalancerFeignClient.DEFAULT_OPTIONS;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实所有的配置类，最后都会装配到 Feign.Builder 里面<br>在 builder 里面构造代理，直接进去看吧。<br>最终，构建代理的是接口 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Targeter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(FeignClientFactoryBean factory, Feign.Builder feign,</span></span></span><br><span class="line"><span class="function"><span class="params">         FeignContext context, Target.HardCodedTarget&lt;T&gt; target)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 feign 的默认实现是<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultTargeter</span> <span class="keyword">implements</span> <span class="title">Targeter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(FeignClientFactoryBean factory, Feign.Builder feign,</span></span></span><br><span class="line"><span class="function"><span class="params">         FeignContext context, Target.HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> feign.target(target);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，直接调用了 builder 的 target 方法<br>还有另一个 实现，这个实现才是自动配置的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HystrixTargeter</span> <span class="keyword">implements</span> <span class="title">Targeter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(FeignClientFactoryBean factory, Feign.Builder feign,</span></span></span><br><span class="line"><span class="function"><span class="params">         FeignContext context, Target.HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!(feign <span class="keyword">instanceof</span> feign.hystrix.HystrixFeign.Builder)) &#123;</span><br><span class="line">         <span class="keyword">return</span> feign.target(target);</span><br><span class="line">      &#125;</span><br><span class="line">      feign.hystrix.HystrixFeign.Builder builder = (feign.hystrix.HystrixFeign.Builder) feign;</span><br><span class="line">      SetterFactory setterFactory = getOptional(factory.getName(), context,</span><br><span class="line">            SetterFactory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span> (setterFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">         builder.setterFactory(setterFactory);</span><br><span class="line">      &#125;</span><br><span class="line">      Class&lt;?&gt; fallback = factory.getFallback();</span><br><span class="line">      <span class="keyword">if</span> (fallback != <span class="keyword">void</span><span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> targetWithFallback(factory.getName(), context, target, builder,</span><br><span class="line">               fallback);</span><br><span class="line">      &#125;</span><br><span class="line">      Class&lt;?&gt; fallbackFactory = factory.getFallbackFactory();</span><br><span class="line">      <span class="keyword">if</span> (fallbackFactory != <span class="keyword">void</span><span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> targetWithFallbackFactory(factory.getName(), context, target, builder,</span><br><span class="line">               fallbackFactory);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> feign.target(target);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">targetWithFallbackFactory</span><span class="params">(String feignClientName, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">         Target.HardCodedTarget&lt;T&gt; target, HystrixFeign.Builder builder,</span></span></span><br><span class="line"><span class="function"><span class="params">         Class&lt;?&gt; fallbackFactoryClass)</span> </span>&#123;</span><br><span class="line">      FallbackFactory&lt;? extends T&gt; fallbackFactory = (FallbackFactory&lt;? extends T&gt;) getFromContext(</span><br><span class="line">            <span class="string">"fallbackFactory"</span>, feignClientName, context, fallbackFactoryClass,</span><br><span class="line">            FallbackFactory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">return</span> builder.target(target, fallbackFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">targetWithFallback</span><span class="params">(String feignClientName, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">         Target.HardCodedTarget&lt;T&gt; target, HystrixFeign.Builder builder,</span></span></span><br><span class="line"><span class="function"><span class="params">         Class&lt;?&gt; fallback)</span> </span>&#123;</span><br><span class="line">      T fallbackInstance = getFromContext(<span class="string">"fallback"</span>, feignClientName, context,</span><br><span class="line">            fallback, target.type());</span><br><span class="line">      <span class="keyword">return</span> builder.target(target, fallbackInstance);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">getFromContext</span><span class="params">(String fallbackMechanism, String feignClientName,</span></span></span><br><span class="line"><span class="function"><span class="params">         FeignContext context, Class&lt;?&gt; beanType, Class&lt;T&gt; targetType)</span> </span>&#123;</span><br><span class="line">      Object fallbackInstance = context.getInstance(feignClientName, beanType);</span><br><span class="line">      <span class="keyword">if</span> (fallbackInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(</span><br><span class="line">               <span class="string">"No "</span> + fallbackMechanism</span><br><span class="line">                     + <span class="string">" instance of type %s found for feign client %s"</span>,</span><br><span class="line">               beanType, feignClientName));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!targetType.isAssignableFrom(beanType)) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(<span class="string">"Incompatible "</span></span><br><span class="line">               + fallbackMechanism</span><br><span class="line">               + <span class="string">" instance. Fallback/fallbackFactory of type %s is not assignable to %s for feign client %s"</span>,</span><br><span class="line">               beanType, targetType, feignClientName));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (T) fallbackInstance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">getOptional</span><span class="params">(String feignClientName, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">         Class&lt;T&gt; beanType)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> context.getInstance(feignClientName, beanType);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，主要处理了 SetterFactory fallback fallbackFactory<br>将这几个配置设置在builder 里面后，调用 builder 的 target<br>默认先看默认的 builder 实现，  Hystrix 有熔断配置的实现是对默认 builder 做了一个扩展</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> build().newInstance(target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Feign <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里，构建这些对象，可以认为将配置分组到不同类</span></span><br><span class="line">  SynchronousMethodHandler.Factory synchronousMethodHandlerFactory =</span><br><span class="line">      <span class="keyword">new</span> SynchronousMethodHandler.Factory(client, retryer, requestInterceptors, logger,</span><br><span class="line">          logLevel, decode404, closeAfterDecode, propagationPolicy);</span><br><span class="line">  ParseHandlersByName handlersByName =</span><br><span class="line">      <span class="keyword">new</span> ParseHandlersByName(contract, options, encoder, decoder, queryMapEncoder,</span><br><span class="line">          errorDecoder, synchronousMethodHandlerFactory);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ReflectiveFeign(handlersByName, invocationHandlerFactory, queryMapEncoder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>build 方法就是把配置分组了，构建了一个 ReflectiveFeign<br>核心是里面的 newInstance 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 这里，解析 type 接口的方法</span></span><br><span class="line">  Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br><span class="line">  Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="keyword">new</span> LinkedHashMap&lt;Method, MethodHandler&gt;();</span><br><span class="line">  List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="keyword">new</span> LinkedList&lt;DefaultMethodHandler&gt;();</span><br><span class="line">  <span class="comment">// 下面是处理 默认方法和过滤掉 object 的方法</span></span><br><span class="line">  <span class="keyword">for</span> (Method method : target.type().getMethods()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isDefault(method)) &#123;</span><br><span class="line">      DefaultMethodHandler handler = <span class="keyword">new</span> DefaultMethodHandler(method);</span><br><span class="line">      defaultMethodHandlers.add(handler);</span><br><span class="line">      methodToHandler.put(method, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// jdk 动态代理的 InvocationHandler 实现，默认是  new ReflectiveFeign.FeignInvocationHandler(target, dispatch);</span></span><br><span class="line">  InvocationHandler handler = factory.create(target, methodToHandler);</span><br><span class="line">  T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(),</span><br><span class="line">      <span class="keyword">new</span> Class&lt;?&gt;[] &#123;target.type()&#125;, handler);</span><br><span class="line">  <span class="comment">// 默认方法绑定到代理对象</span></span><br><span class="line">  <span class="keyword">for</span> (DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">    defaultMethodHandler.bindTo(proxy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// so 返回的是一个 JDK 的动态代理对象</span></span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>so 继续看看 InvocationHandler handler = factory.create(target, methodToHandler); 创建的东西</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Target target;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MethodHandler&gt; dispatch;</span><br><span class="line"></span><br><span class="line">  FeignInvocationHandler(Target target, Map&lt;Method, MethodHandler&gt; dispatch) &#123;</span><br><span class="line">    <span class="keyword">this</span>.target = checkNotNull(target, <span class="string">"target"</span>);</span><br><span class="line">    <span class="keyword">this</span>.dispatch = checkNotNull(dispatch, <span class="string">"dispatch for %s"</span>, target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"equals"</span>.equals(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Object otherHandler =</span><br><span class="line">            args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="keyword">null</span> ? Proxy.getInvocationHandler(args[<span class="number">0</span>]) : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> equals(otherHandler);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"hashCode"</span>.equals(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">return</span> hashCode();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"toString"</span>.equals(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">return</span> toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dispatch.get(method).invoke(args);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>非常，简单，其实核心还是 apply 方法解析出来的 methodHandler </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, MethodHandler&gt; <span class="title">apply</span><span class="params">(Target key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里使用 Contract 解析相关接口</span></span><br><span class="line">    List&lt;MethodMetadata&gt; metadata = contract.parseAndValidatateMetadata(key.type());</span><br><span class="line">    Map&lt;String, MethodHandler&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;String, MethodHandler&gt;();</span><br><span class="line">    <span class="keyword">for</span> (MethodMetadata md : metadata) &#123;</span><br><span class="line">      <span class="comment">// 这个是根据参数构建 request 请求的解析类</span></span><br><span class="line">      BuildTemplateByResolvingArgs buildTemplate;</span><br><span class="line">      <span class="keyword">if</span> (!md.formParams().isEmpty() &amp;&amp; md.template().bodyTemplate() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        buildTemplate = <span class="keyword">new</span> BuildFormEncodedTemplateFromArgs(md, encoder, queryMapEncoder);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (md.bodyIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        buildTemplate = <span class="keyword">new</span> BuildEncodedTemplateFromArgs(md, encoder, queryMapEncoder);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buildTemplate = <span class="keyword">new</span> BuildTemplateByResolvingArgs(md, queryMapEncoder);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这里的 configKey 是 Feign.configKey 方法生成的 类 simpleName + methodName + 参数</span></span><br><span class="line">      <span class="comment">// factory 构建的是 SynchronousMethodHandler 实例 ，可以想象到，具体的调用逻辑就是在这里完成的</span></span><br><span class="line">      result.put(md.configKey(),</span><br><span class="line">          factory.create(key, md, buildTemplate, options, decoder, errorDecoder));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看具体调用的地方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 第一步 就是用 请求参数构建 RequestTemplate 具体有三种，后面详细看看看 BuildFormEncodedTemplateFromArgs  BuildEncodedTemplateFromArgs  BuildTemplateByResolvingArgs</span></span><br><span class="line">  RequestTemplate template = buildTemplateFromArgs.create(argv);</span><br><span class="line">  <span class="comment">// 重试 clone 就是将计数重置为 1</span></span><br><span class="line">  Retryer retryer = <span class="keyword">this</span>.retryer.clone();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 正常调用，如果 ok 就返回了</span></span><br><span class="line">      <span class="comment">// 这里是调用的核心逻辑</span></span><br><span class="line">      <span class="keyword">return</span> executeAndDecode(template);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RetryableException e) &#123;</span><br><span class="line">      <span class="comment">// 如果抛出的是 可重试异常</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 重试策略判断一下，如果不允许，就把异常抛出来，如果允许，内部可以记录一下，或者 等待一会再尝试</span></span><br><span class="line">        retryer.continueOrPropagate(e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RetryableException th) &#123;</span><br><span class="line">        <span class="comment">// 异常是否需要解开包装</span></span><br><span class="line">        Throwable cause = th.getCause();</span><br><span class="line">        <span class="keyword">if</span> (propagationPolicy == UNWRAP &amp;&amp; cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> cause;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> th;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">        logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，就可以详细看看具体的调用逻辑了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">executeAndDecode</span><span class="params">(RequestTemplate template)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 这里将请求封装为 request 内部首先经过 RequestInterceptor 处理  然后构建 request</span></span><br><span class="line">  Request request = targetRequest(template);</span><br><span class="line">  <span class="comment">// 请求日志</span></span><br><span class="line">  <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">    logger.logRequest(metadata.configKey(), logLevel, request);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Response response;</span><br><span class="line">  <span class="comment">// 记录请求时间</span></span><br><span class="line">  <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 Client 执行请求，带上 options 参数，options 也是可配置的，通常是连接超时时间之类的</span></span><br><span class="line">    <span class="comment">// 这里就是核心了，请求控制丢给 client 去了</span></span><br><span class="line">    response = client.execute(request, options);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// 异常日志</span></span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">      logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime(start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抛异常，这里是将异常包装为 可重试异常</span></span><br><span class="line">    <span class="keyword">throw</span> errorExecuting(request, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 正常结果</span></span><br><span class="line">  <span class="keyword">long</span> elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> shouldClose = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 响应日志</span></span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">      response =</span><br><span class="line">          logger.logAndRebufferResponse(metadata.configKey(), logLevel, response, elapsedTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return 类型就是 Response</span></span><br><span class="line">    <span class="keyword">if</span> (Response<span class="class">.<span class="keyword">class</span> </span>== metadata.returnType()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (response.body().length() == <span class="keyword">null</span> ||</span><br><span class="line">          response.body().length() &gt; MAX_RESPONSE_BUFFER_SIZE) &#123;</span><br><span class="line">        shouldClose = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Ensure the response body is disconnected</span></span><br><span class="line">      <span class="keyword">byte</span>[] bodyData = Util.toByteArray(response.body().asInputStream());</span><br><span class="line">      <span class="keyword">return</span> response.toBuilder().body(bodyData).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常响应</span></span><br><span class="line">    <span class="keyword">if</span> (response.status() &gt;= <span class="number">200</span> &amp;&amp; response.status() &lt; <span class="number">300</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">void</span><span class="class">.<span class="keyword">class</span> </span>== metadata.returnType()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object result = decode(response);</span><br><span class="line">        shouldClose = closeAfterDecode;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (decode404 &amp;&amp; response.status() == <span class="number">404</span> &amp;&amp; <span class="keyword">void</span><span class="class">.<span class="keyword">class</span> !</span>= metadata.returnType()) &#123;</span><br><span class="line">      <span class="comment">// 404 并且有需要返回结果</span></span><br><span class="line">      Object result = decode(response);</span><br><span class="line">      shouldClose = closeAfterDecode;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 其他的就根据 errorDecoder 解析抛异常</span></span><br><span class="line">      <span class="keyword">throw</span> errorDecoder.decode(metadata.configKey(), response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// io 异常</span></span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">      logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 封装为 FeignException</span></span><br><span class="line">    <span class="keyword">throw</span> errorReading(request, response, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (shouldClose) &#123;</span><br><span class="line">      ensureClosed(response.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么接下来看看 client</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">* Executes a request against its &#123;<span class="doctag">@link</span> Request#url() url&#125; and returns a response.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> request safe to replay.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> options options to apply to this request.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> connected response, &#123;<span class="doctag">@link</span> Response.Body&#125; is absent or unread.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IOException on a network error connecting to &#123;<span class="doctag">@link</span> Request#url()&#125;.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Response <span class="title">execute</span><span class="params">(Request request, Options options)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有一个接口要实现，有一个默认的内部类实现，就是使用 HttpURLConnection 一看就没有软负载， feign 的负载功能是通过 fibbon 实现了，有一个实现 LoadBalancerFeignClient</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">(Request request, Request.Options options)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      URI asUri = URI.create(request.url());</span><br><span class="line">      String clientName = asUri.getHost();</span><br><span class="line">      URI uriWithoutHost = cleanUrl(request.url(), clientName);</span><br><span class="line">      <span class="comment">// 转为 ribbon 的 request</span></span><br><span class="line">      FeignLoadBalancer.RibbonRequest ribbonRequest = <span class="keyword">new</span> FeignLoadBalancer.RibbonRequest(</span><br><span class="line">            <span class="keyword">this</span>.delegate, request, uriWithoutHost);</span><br><span class="line">      <span class="comment">// 配置类</span></span><br><span class="line">      IClientConfig requestConfig = getClientConfig(options, clientName);</span><br><span class="line">      <span class="comment">// 获取 FeignLoadBalancer 然后执行</span></span><br><span class="line">      <span class="keyword">return</span> lbClient(clientName)</span><br><span class="line">            .executeWithLoadBalancer(ribbonRequest, requestConfig).toResponse();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">      IOException io = findIOException(e);</span><br><span class="line">      <span class="keyword">if</span> (io != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> io;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> FeignLoadBalancer <span class="title">lbClient</span><span class="params">(String clientName)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.lbClientFactory.create(clientName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> FeignLoadBalancer <span class="title">create</span><span class="params">(String clientName)</span> </span>&#123;</span><br><span class="line">   FeignLoadBalancer client = <span class="keyword">this</span>.cache.get(clientName);</span><br><span class="line">   <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> client;</span><br><span class="line">   &#125;</span><br><span class="line">   IClientConfig config = <span class="keyword">this</span>.factory.getClientConfig(clientName);</span><br><span class="line">   ILoadBalancer lb = <span class="keyword">this</span>.factory.getLoadBalancer(clientName);</span><br><span class="line">   ServerIntrospector serverIntrospector = <span class="keyword">this</span>.factory.getInstance(clientName,</span><br><span class="line">         ServerIntrospector<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   client = <span class="keyword">this</span>.loadBalancedRetryFactory != <span class="keyword">null</span></span><br><span class="line">         ? <span class="keyword">new</span> RetryableFeignLoadBalancer(lb, config, serverIntrospector,</span><br><span class="line">               <span class="keyword">this</span>.loadBalancedRetryFactory)</span><br><span class="line">         : <span class="keyword">new</span> FeignLoadBalancer(lb, config, serverIntrospector);</span><br><span class="line">   <span class="comment">// 默认是走 FeignLoadBalancer  可以看到传了一个 ILoadBalancer  ServerIntrospector 和 IClientConfig基本配置</span></span><br><span class="line">   <span class="keyword">this</span>.cache.put(clientName, client);</span><br><span class="line">   <span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后又到了 FeignLoadBalancer 的 executeWithLoadBalancer 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">executeWithLoadBalancer</span><span class="params">(<span class="keyword">final</span> S request, <span class="keyword">final</span> IClientConfig requestConfig)</span> <span class="keyword">throws</span> ClientException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 负载指令，其实就是负载策略</span></span><br><span class="line">    LoadBalancerCommand&lt;T&gt; command = buildLoadBalancerCommand(request, requestConfig);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ribbon 内部使用 rxjava </span></span><br><span class="line">        <span class="comment">// submit 内部控制 负载均衡和重试次数， 包括同 server 重试 和 不同 server 重试</span></span><br><span class="line">        <span class="comment">// 这里的 ServerOperation 就是一次实际的请求，参数是已经选择好的 server 然后调用 execute，本质就是 feign 的 client 请求</span></span><br><span class="line">        <span class="keyword">return</span> command.submit(</span><br><span class="line">            <span class="keyword">new</span> ServerOperation&lt;T&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">call</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">                    URI finalUri = reconstructURIWithServer(server, request.getUri());</span><br><span class="line">                    S requestForServer = (S) request.replaceUri(finalUri);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> Observable.just(AbstractLoadBalancerAwareClient.<span class="keyword">this</span>.execute(requestForServer, requestConfig));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .toBlocking()</span><br><span class="line">            .single();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Throwable t = e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ClientException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (ClientException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClientException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> LoadBalancerCommand&lt;T&gt; <span class="title">buildLoadBalancerCommand</span><span class="params">(<span class="keyword">final</span> S request, <span class="keyword">final</span> IClientConfig config)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 重试策略</span></span><br><span class="line">   RequestSpecificRetryHandler handler = getRequestSpecificRetryHandler(request, config);</span><br><span class="line">   LoadBalancerCommand.Builder&lt;T&gt; builder = LoadBalancerCommand.&lt;T&gt;builder()</span><br><span class="line">         .withLoadBalancerContext(<span class="keyword">this</span>)</span><br><span class="line">         .withRetryHandler(handler)</span><br><span class="line">         .withLoadBalancerURI(request.getUri());</span><br><span class="line">   <span class="comment">// 其他自定义配置</span></span><br><span class="line">   customizeLoadBalancerCommandBuilder(request, config, builder);</span><br><span class="line">   <span class="keyword">return</span> builder.build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestSpecificRetryHandler <span class="title">getRequestSpecificRetryHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      RibbonRequest request, IClientConfig requestConfig)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.ribbon.isOkToRetryOnAllOperations()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RequestSpecificRetryHandler(<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">this</span>.getRetryHandler(),</span><br><span class="line">            requestConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!request.toRequest().httpMethod().name().equals(<span class="string">"GET"</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RequestSpecificRetryHandler(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">this</span>.getRetryHandler(),</span><br><span class="line">            requestConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RequestSpecificRetryHandler(<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">this</span>.getRetryHandler(),</span><br><span class="line">            requestConfig);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后最复杂的方法来了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">submit</span><span class="params">(<span class="keyword">final</span> ServerOperation&lt;T&gt; operation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ExecutionInfoContext context = <span class="keyword">new</span> ExecutionInfoContext();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (listenerInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            listenerInvoker.onExecutionStart();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AbortExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxRetrysSame = retryHandler.getMaxRetriesOnSameServer();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxRetrysNext = retryHandler.getMaxRetriesOnNextServer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the load balancer</span></span><br><span class="line">    Observable&lt;T&gt; o =</span><br><span class="line">            <span class="comment">// server 不为null ，那就代表是直连了，否则使用 selectServer 获取可用列表</span></span><br><span class="line">            (server == <span class="keyword">null</span> ? selectServer() : Observable.just(server))</span><br><span class="line">            <span class="comment">// rxjava 的api 做相当于做一次转换，T 是响应类型</span></span><br><span class="line">            .concatMap(<span class="keyword">new</span> Func1&lt;Server, Observable&lt;T&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="comment">// Called for each server being selected</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">call</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">                    context.setServer(server);</span><br><span class="line">                    <span class="keyword">final</span> ServerStats stats = loadBalancerContext.getServerStats(server);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// Called for each attempt and retry</span></span><br><span class="line">                    Observable&lt;T&gt; o = Observable</span><br><span class="line">                            .just(server)</span><br><span class="line">                            .concatMap(<span class="keyword">new</span> Func1&lt;Server, Observable&lt;T&gt;&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">call</span><span class="params">(<span class="keyword">final</span> Server server)</span> </span>&#123;</span><br><span class="line">                                    context.incAttemptCount();</span><br><span class="line">                                    loadBalancerContext.noteOpenConnection(stats);</span><br><span class="line">                                    </span><br><span class="line">                                    <span class="keyword">if</span> (listenerInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                            listenerInvoker.onStartWithServer(context.toExecutionInfo());</span><br><span class="line">                                        &#125; <span class="keyword">catch</span> (AbortExecutionException e) &#123;</span><br><span class="line">                                            <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    </span><br><span class="line">                                    <span class="keyword">final</span> Stopwatch tracer = loadBalancerContext.getExecuteTracer().start();</span><br><span class="line">                                    <span class="comment">// 注意这里，就是调用传 实际的请求，上面一堆都是记录和重试</span></span><br><span class="line">                                    <span class="keyword">return</span> operation.call(server).doOnEach(<span class="keyword">new</span> Observer&lt;T&gt;() &#123;</span><br><span class="line">                                        <span class="keyword">private</span> T entity;</span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                            recordStats(tracer, stats, entity, <span class="keyword">null</span>);</span><br><span class="line">                                            <span class="comment">// <span class="doctag">TODO:</span> What to do if onNext or onError are never called?</span></span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                                            recordStats(tracer, stats, <span class="keyword">null</span>, e);</span><br><span class="line">                                            logger.debug(<span class="string">"Got error &#123;&#125; when executed on server &#123;&#125;"</span>, e, server);</span><br><span class="line">                                            <span class="keyword">if</span> (listenerInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                                listenerInvoker.onExceptionWithServer(e, context.toExecutionInfo());</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T entity)</span> </span>&#123;</span><br><span class="line">                                            <span class="keyword">this</span>.entity = entity;</span><br><span class="line">                                            <span class="keyword">if</span> (listenerInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                                listenerInvoker.onExecutionSuccess(entity, context.toExecutionInfo());</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;                            </span><br><span class="line">                                        </span><br><span class="line">                                        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recordStats</span><span class="params">(Stopwatch tracer, ServerStats stats, Object entity, Throwable exception)</span> </span>&#123;</span><br><span class="line">                                            tracer.stop();</span><br><span class="line">                                            loadBalancerContext.noteRequestCompletion(stats, entity, exception, tracer.getDuration(TimeUnit.MILLISECONDS), retryHandler);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// retry 也是 rxjava api ，retryPolicy 方法判断是否可以重试</span></span><br><span class="line">                    <span class="keyword">if</span> (maxRetrysSame &gt; <span class="number">0</span>)</span><br><span class="line">                        o = o.retry(retryPolicy(maxRetrysSame, <span class="keyword">true</span>));</span><br><span class="line">                    <span class="keyword">return</span> o;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">// 上面重试是针对同一个 server 的，这里是针对不同的 server 的   </span></span><br><span class="line">    <span class="keyword">if</span> (maxRetrysNext &gt; <span class="number">0</span> &amp;&amp; server == <span class="keyword">null</span>)</span><br><span class="line">        o = o.retry(retryPolicy(maxRetrysNext, <span class="keyword">false</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> o.onErrorResumeNext(<span class="keyword">new</span> Func1&lt;Throwable, Observable&lt;T&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">call</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (context.getAttemptCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (maxRetrysNext &gt; <span class="number">0</span> &amp;&amp; context.getServerAttemptCount() == (maxRetrysNext + <span class="number">1</span>)) &#123;</span><br><span class="line">                    e = <span class="keyword">new</span> ClientException(ClientException.ErrorType.NUMBEROF_RETRIES_NEXTSERVER_EXCEEDED,</span><br><span class="line">                            <span class="string">"Number of retries on next server exceeded max "</span> + maxRetrysNext</span><br><span class="line">                            + <span class="string">" retries, while making a call for: "</span> + context.getServer(), e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (maxRetrysSame &gt; <span class="number">0</span> &amp;&amp; context.getAttemptCount() == (maxRetrysSame + <span class="number">1</span>)) &#123;</span><br><span class="line">                    e = <span class="keyword">new</span> ClientException(ClientException.ErrorType.NUMBEROF_RETRIES_EXEEDED,</span><br><span class="line">                            <span class="string">"Number of retries exceeded max "</span> + maxRetrysSame</span><br><span class="line">                            + <span class="string">" retries, while making a call for: "</span> + context.getServer(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (listenerInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                listenerInvoker.onExecutionFailed(e, context.toFinalExecutionInfo());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>feign</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot 分析</title>
    <url>/2019/10/10/spring-boot-%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<img src="/2019/10/10/spring-boot-%E5%88%86%E6%9E%90/springboot.svg" class="" title="This is an example image">
<h2 id="org-springframework-context-ApplicationContextInitializer"><a href="#org-springframework-context-ApplicationContextInitializer" class="headerlink" title="org.springframework.context.ApplicationContextInitializer"></a><code>org.springframework.context.ApplicationContextInitializer</code></h2><ol>
<li><code>org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer</code><br> 这里面添加了一个 <code>BeanFactoryPostProcessor</code> 实现类 <code>ConfigurationWarningsPostProcessor</code><br> 主要是打印启动过程中的警告信息的</li>
<li><code>org.springframework.boot.context.ContextIdApplicationContextInitializer</code><br> 这里处理 <code>ContextId</code>    </li>
<li><code>org.springframework.boot.context.config.DelegatingApplicationContextInitializer</code><br> 这里处理 <code>ApplicationContextInitializer</code> 的实现类<br> 这个接口就是一个 <code>initialize</code> 方法，参数是 <code>ConfigurableApplicationContext</code> 的子类<br> 当然，不是所有的 <code>ApplicationContextInitializer</code> 都会被调用，可以通过参数 <code>context.initializer.classes</code> 指定要调用的实现类，多个用逗号分隔</li>
<li><code>org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer</code><br> 这个类也实现了 <code>ApplicationListener</code> 接口，用来监听 <code>WebServerInitializedEvent</code> 时间<br> 作用是处理设置 <code>server.port</code></li>
</ol>
<h2 id="org-springframework-context-ApplicationListener"><a href="#org-springframework-context-ApplicationListener" class="headerlink" title="org.springframework.context.ApplicationListener"></a><code>org.springframework.context.ApplicationListener</code></h2><ol>
<li><code>org.springframework.boot.ClearCachesApplicationListener</code><br> 监听的事件是 <code>ContextRefreshedEvent</code> ，也就是 <code>refersh</code> 方法完成后<br> 清理反射使用的缓存</li>
<li><code>org.springframework.boot.builder.ParentContextCloserApplicationListener</code><br>监听的事件是 <code>ParentContextAvailableEvent</code><br>这个是在 <code>ParentContextApplicationContextInitializer</code> 里面触发的，<code>ApplicationContextInitializer</code> 上面说过了<br>这里处理的是有 parent 的情况，使用 <code>SpringApplicationBuilder</code> 的时候，可以指定 parent    </li>
<li><code>org.springframework.boot.context.FileEncodingApplicationListener</code><br>监听的事件是 <code>ApplicationEnvironmentPreparedEvent</code><br>就是实例化 <code>ConfigurableEnvironment</code> 后<br>作用是，检查 <code>spring.mandatory-file-encoding</code> 参数强制指定的字符集与 <code>file.encoding</code> 系统参数的字符集是否一样，如果不愿意，就异常</li>
<li><code>org.springframework.boot.context.config.AnsiOutputApplicationListener</code><br> 监听的事件是 <code>ApplicationEnvironmentPreparedEvent</code><br> 就是实例化 <code>ConfigurableEnvironment</code> 后<br> 处理参数 <code>spring.output.ansi.enabled</code> 和 <code>spring.output.ansi.console-available</code> 就是控制彩色输出</li>
<li><code>org.springframework.boot.context.config.ConfigFileApplicationListener</code><br> 监听的事件是 <code>ApplicationEnvironmentPreparedEvent</code> 和 <code>ApplicationPreparedEvent</code><br> 就是实例化 <code>ConfigurableEnvironment</code> 后和注册完主类为 BeanDefinition 后<br> 处理事件 <code>ApplicationEnvironmentPreparedEvent</code><pre><code> 加载 `EnvironmentPostProcessor` 的实现类
 默认配置有
 `org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor`
 `org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor`
 `org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor`
 在加上自身，调用 `postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application)` 方法
 这里 *关键* ，后面再细看
</code></pre> 处理事件 <code>ApplicationPreparedEvent</code><pre><code> 这里添加了一个 `BeanFactoryPostProcessor` 的实例 `PropertySourceOrderingPostProcessor`
 作用是将 `defaultProperties` 的 `PropertySource` 添加到最后
</code></pre></li>
<li><code>org.springframework.boot.context.config.DelegatingApplicationListener</code><br> 监听的事件是 <code>ApplicationEnvironmentPreparedEvent</code><br> 在 <code>ApplicationEnvironmentPreparedEvent</code> 事件的时候，获取配置 <code>context.listener.classes</code> 指定的 <code>ApplicationListener</code> 类，如果有的话，就转发其他所有事件</li>
<li><code>org.springframework.boot.context.logging.ClasspathLoggingApplicationListener</code><br> 监听的事件是 <code>ApplicationEnvironmentPreparedEvent</code> 或者 <code>ApplicationFailedEvent</code><br> 就是打印一个 <code>classpath</code> 日志</li>
<li><code>org.springframework.boot.context.logging.LoggingApplicationListener</code><br> 监听的事件 <code>ApplicationStartingEvent.class, ApplicationEnvironmentPreparedEvent.class, ApplicationPreparedEvent.class, ContextClosedEvent.class, ApplicationFailedEvent.class</code><br> 处理日志配置和等级的</li>
<li><code>org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener</code><br><code>Liquibase</code> 是数据库版本控制，具体里面做啥，没看。</li>
</ol>
<h2 id="org-springframework-boot-env-EnvironmentPostProcessor"><a href="#org-springframework-boot-env-EnvironmentPostProcessor" class="headerlink" title="org.springframework.boot.env.EnvironmentPostProcessor"></a><code>org.springframework.boot.env.EnvironmentPostProcessor</code></h2><p>上面第 5 条会触发这里，继续看    </p>
<ol>
<li><code>org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor</code><br>云原生相关的，后面看 <code>spring-cloud</code> 的时候再细看</li>
<li><code>org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor</code><br>作用就是找参数 <code>spring.application.json</code> 或者 <code>SPRING_APPLICATION_JSON</code> 指定的 <code>json</code> 文件，加载配置，优先级高于系统参数</li>
<li><code>org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor</code><br>处理 <code>systemEnvironment</code></li>
<li><p><code>org.springframework.boot.context.config.ConfigFileApplicationListener</code><br> 这里就是加载 <code>application.properties</code> 的地方<br> 如果直接指定了 <code>spring.config.location</code> 那么只去加载这里<br> 如果指定了 <code>spring.config.additional-location</code> 额外加载的文件，先加载这里<br> 加上默认的 <code>classpath:/,classpath:/config/,file:./,file:./config/</code></p>
<p> 一般上面指定的是目录，然后在目录下，找文件名，默认是 <code>application</code> , 可以通过 <code>spring.config.name</code> 参数来修改文件名<br> 剩下的就是加载过程了<br> 加载过程中，先加载 <code>spring.factory</code> 的 <code>org.springframework.boot.env.PropertySourceLoader</code> , 默认有两个实现类<br> <code>org.springframework.boot.env.PropertiesPropertySourceLoader</code>   <code>properties</code> 和 <code>xml</code><br> <code>org.springframework.boot.env.YamlPropertySourceLoader</code>      <code>yml</code> 和 <code>yaml</code><br> 好吧，看名字就知道分别处理 <code>properteis</code> 和 <code>yaml</code> 文件了</p>
</li>
</ol>
<p>以上就是 <code>spring-boot</code> 的核心配置<br>我们主要知道了，<code>spring-boot</code> 的启动过程，以及通过哪些扩展接口进行增强<br>接下来看看 <code>spring-boot-autoconfigure</code></p>
<h2 id="org-springframework-context-ApplicationContextInitializer-1"><a href="#org-springframework-context-ApplicationContextInitializer-1" class="headerlink" title="org.springframework.context.ApplicationContextInitializer"></a><code>org.springframework.context.ApplicationContextInitializer</code></h2><ol>
<li><code>org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer</code><br> 注册了一个 <code>BeanFactoryPostProcessor</code> 实现类 <code>CachingMetadataReaderFactoryPostProcessor</code><br> 作用，注册了一个 <code>SharedMetadataReaderFactoryBean</code> 的 <code>BeanDefinition</code></li>
<li><code>org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</code><br> 作用就是打印一些自动注册的日志</li>
</ol>
<h2 id="org-springframework-context-ApplicationListener-1"><a href="#org-springframework-context-ApplicationListener-1" class="headerlink" title="org.springframework.context.ApplicationListener"></a><code>org.springframework.context.ApplicationListener</code></h2><ol>
<li><code>org.springframework.boot.autoconfigure.BackgroundPreinitializer</code><br> 监听的事件是 <code>SpringApplicationEvent</code> 这是一个抽象类 ，上面说的 <code>spring-boot</code> 相关的事件类，大部分都是这个类的子类<br> 作用就是启动一个线程去做一些初始化，类相关的</li>
</ol>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring 源码再分析</title>
    <url>/2019/10/08/spring-%E6%BA%90%E7%A0%81%E5%86%8D%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<img src="/2019/10/08/spring-%E6%BA%90%E7%A0%81%E5%86%8D%E5%88%86%E6%9E%90/spring%E5%88%9D%E5%A7%8B%E5%8C%96-%E5%8D%95%E4%BE%8B%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B.svg" class="" title="This is an example image">
<p>ConfigurationClassPostProcessor        BeanDefinitionRegistryPostProcessor<br>AutowiredAnnotationBeanPostProcessor            InstantiationAwareBeanPostProcessorAdapter<br>CommonAnnotationBeanPostProcessor             InstantiationAwareBeanPostProcessor</p>
<p>EventListenerMethodProcessor        SmartInitializingSingleton<br>DefaultEventListenerFactory                EventListenerFactory<br>ApplicationContextAwareProcessor        BeanPostProcessor</p>
<p>ApplicationListenerDetector        BeanPostProcessor</p>
<p>BeanPostProcessorChecker</p>
<ol>
<li>prepareRefresh<br> 记录启动时间</li>
<li>prepareBeanFactory<br> 忽略和设置框架依赖注入</li>
<li>postProcessBeanFactory<br> 扩展方法，</li>
<li><p>invokeBeanFactoryPostProcessors<br> 调用 BeanFactoryPostProcessor  BeanDefinitionRegistryPostProcessor 扩展</p>
<ol>
<li>直接挂在 context 上的 BeanDefinitionRegistryPostProcessor   -&gt; postProcessBeanDefinitionRegistry</li>
<li>beanFactory 里面的  BeanDefinitionRegistryPostProcessor ,PriorityOrdered -&gt;  postProcessBeanDefinitionRegistry</li>
<li>beanFactory 里面的  BeanDefinitionRegistryPostProcessor ,Ordered -&gt;  postProcessBeanDefinitionRegistry</li>
<li>beanFactory 里面的  BeanDefinitionRegistryPostProcessor -&gt;  postProcessBeanDefinitionRegistry</li>
<li>上面执行过的 继续执行 BeanFactoryPostProcessor —&gt; postProcessBeanFactory</li>
<li>直接挂在 context 上的 BeanFactoryPostProcessor —&gt; postProcessBeanFactory</li>
<li>beanFactory 里面的 BeanFactoryPostProcessor , PriorityOrdered  -&gt;  postProcessBeanFactory</li>
<li>beanFactory 里面的 BeanFactoryPostProcessor , Ordered -&gt;  postProcessBeanFactory</li>
<li>beanFactory 里面的 BeanFactoryPostProcessor  -&gt;  postProcessBeanFactory<br>这里核心的是 ConfigurationClassPostProcessor</li>
</ol>
</li>
<li><p>registerBeanPostProcessors<br> 添加 BeanPostProcessor<br> beanFactory 自身带的<br> 添加 BeanPostProcessorChecker<br> 容器里面的<br> BeanPostProcessor - PriorityOrdered<br> BeanPostProcessor - Ordered<br> BeanPostProcessor -<br> 上面三个，按照顺序添加到自身带的后面<br> BeanPostProcessor - MergedBeanDefinitionPostProcessor - PriorityOrdered<br> BeanPostProcessor - MergedBeanDefinitionPostProcessor - Ordered<br> BeanPostProcessor - MergedBeanDefinitionPostProcessor<br> 再添加一次 MergedBeanDefinitionPostProcessor 类型的，按照上面的顺序<br> 最后添加 ApplicationListenerDetector</p>
</li>
<li>initMessageSource<br> 这个是国际化的地方<br> DelegatingMessageSource</li>
<li>initApplicationEventMulticaster<br> 事件<br> SimpleApplicationEventMulticaster</li>
<li>onRefresh<br>空的，扩展接口</li>
<li>registerListeners<br>添加 ApplicationListener<br>先 beanFactory 上挂的，然后 beanFactory 里面的<br>然后将这之前的事件发布了</li>
<li>finishBeanFactoryInitialization<br>特殊处理 LoadTimeWeaverAware 先进行初始化 （getBean）<br>冻结 beanDefinition ,不再改变<br>实例化非延时加载的单例</li>
<li>finishRefresh<br>结束</li>
</ol>
<p>实例化非延时加载的单例</p>
<p>spring 实例化 bean 其实就是调用 getBean<br>内部实现是 doGetBean<br>先看 普通的 bean  后面再看 factoryBean</p>
<ol>
<li>就是去手动注册的 bean 里面检查是否存在，如果存在，直接返回了  一般只有部分 spring 内部的 bean 是手动注册的</li>
<li>在创建 bean 之前，用 InstantiationAwareBeanPostProcessor -&gt; postProcessBeforeInstantiation 处理<br> 这里参数是 class 和 beanName ，如果返回非 null ，那么就使用这里返回的 bean 然后<pre><code> BeanPostProcessor -&gt; postProcessAfterInitialization 处理生成的 bean
</code></pre></li>
<li>如果没被上面的扩展接口处理，那么进入标准的创建流程</li>
<li>如果提供了 bean 的工厂类，那么使用工厂类创建 （可以是 Supplier 或者 factoryMethod）</li>
<li>核心创建方法两个 autowireConstructor （有构造依赖的构建） 和 instantiateBean （标准创建）</li>
<li>创建完成后 调用扩展 MergedBeanDefinitionPostProcessor -&gt; postProcessMergedBeanDefinition  这里是修改 BeanDefinetion 的地方</li>
<li>populateBean  处理扩展接口 InstantiationAwareBeanPostProcessor -&gt; postProcessAfterInstantiation   返回值决定是否继续处理 propertyValue<br> 后面继续处理扩展接口  InstantiationAwareBeanPostProcessor -&gt; postProcessProperties  postProcessPropertyValues</li>
</ol>
<p>BeanPostProcessor -&gt; postProcessBeforeInitialization  </p>
<p>afterPropertiesSet  initMethod<br>BeanPostProcessor -&gt; postProcessAfterInitialization<br>注册 destoryMethod</p>
<p>几个核心的 BeanPostProcessor<br>ApplicationContextAwareProcessor<br>ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor<br>PostProcessorRegistrationDelegate$BeanPostProcessorChecker<br>CommonAnnotationBeanPostProcessor<br>AutowiredAnnotationBeanPostProcessor<br>ApplicationListenerDetector</p>
<ol>
<li>ApplicationContextAwareProcessor  实现  BeanPostProcessor<br>作用：<br>在 init 方法之前，调用 bean 的 Aware 接口<br>EnvironmentAware<br>EmbeddedValueResolverAware<br>ResourceLoaderAware<br>ApplicationEventPublisherAware<br>MessageSourceAware<br>ApplicationContextAware</li>
<li>ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor 实现 InstantiationAwareBeanPostProcessor<br>作用:<br>在依赖注入前，设置 BeanFactory 接口  EnhancedConfiguration<br>在 init 方法前 调用<br>ImportAware</li>
<li>PostProcessorRegistrationDelegate$BeanPostProcessorChecker<br>这个扩展是用来检测 bean 是否经过了所有 BeanPostProcess 的处理 ，如果没有，会有 info 日志<br>因为在实例化 bean 之前，首先处理的是 BeanPostProcessor 实例，按照顺序，是内建 -&gt; PriorityOrdered -&gt; Ordered -&gt; 非排序的<br>如果直接存在依赖注入的问题，那么，会有一个问题，在 BeanPostProcessor 里面依赖了其他普通的 bean，那么会先触发普通 bean 的实例化，但是没法享受 BeanPostProcessor 的处理了<br>要知道 无论是 ioc 还是 aop 都是使用 BeanPostProcessor 扩展的</li>
<li>CommonAnnotationBeanPostProcessor 实现 InstantiationAwareBeanPostProcessor MergedBeanDefinitionPostProcessor DestructionAwareBeanPostProcessor<br>这里处理的是 init 和 destroy 和 JSR-250 注解依赖注入的地方<br>这里的注解属于标准注解 javax.annotation.PostConstruct javax.annotation.PreDestroy  javax.annotation.Resource 等</li>
<li>AutowiredAnnotationBeanPostProcessor 实现 InstantiationAwareBeanPostProcessor  MergedBeanDefinitionPostProcessor<br>这里是处理内置注解 @Autowired   @Value  javax.inject.Inject  的注入</li>
<li>ApplicationListenerDetector<br>这里是处理 ApplicationListener 的地方，单例的 ApplicationListener 实例注册，非单例，打印警告信息</li>
</ol>
<p>ConfigurationClassPostProcessor 这个是核心类，还要仔细看看</p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-security分析</title>
    <url>/2019/09/29/spring-security%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<img src="/2019/09/29/spring-security%E5%88%86%E6%9E%90/security-core.png" class="" title="This is an example image">
<p>网上都说 shiro 比 security 好，分析完 shiro 后，发现确实实现的挺轻量级的，而且扩展也比较容易，他实现的代码也很漂亮<br>但是后台开发通常都会用 spring ，spring-security 自然就是官方支持的，有时候为了方便，直接使用 spring-security 了，但是配置都是网上抄的<br>而 spring-security 又像一个全家桶，一个配置，加了一堆东西，有时候出了问题，都不知道怎么排查<br>于是，抱着弄懂原理，心理不慌的想法，开始前线的分析源码  </p>
<p>首先明确一个概念，安全框架的基本功能就是认证授权，至于额外的密码hash，防御攻击之类的，都是额外的操作，security 一键就给你加了一堆东西，虽然用的爽，实际上，连使用者都可能不知道到底添加了哪些功能  </p>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>认证的核心接口是 <code>AuthenticationManager</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthenticationManager</span> </span>&#123;</span><br><span class="line">	<span class="function">Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只有一个认证方法，凭证 <code>Authentication</code> 可以代表认证成功前的请求信息，也可以表示认证成功后的调用凭证信息<br><code>AuthenticationManager</code> 内部已经有实现了 <code>ProviderManager</code>，我们通常不会去重新实现它<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    Class&lt;? extends Authentication&gt; toTest = authentication.getClass();</span><br><span class="line">    AuthenticationException lastException = <span class="keyword">null</span>;</span><br><span class="line">    Authentication result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> debug = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!provider.supports(toTest)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Authentication attempt using "</span></span><br><span class="line">                    + provider.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = provider.authenticate(authentication);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                copyDetails(authentication, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AccountStatusException e) &#123;</span><br><span class="line">            prepareException(e, authentication);</span><br><span class="line">            <span class="comment">// SEC-546: Avoid polling additional providers if auth failure is due to</span></span><br><span class="line">            <span class="comment">// invalid account status</span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InternalAuthenticationServiceException e) &#123;</span><br><span class="line">            prepareException(e, authentication);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            lastException = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Allow the parent to try.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = parent.authenticate(authentication);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ProviderNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// ignore as we will throw below if no other exception occurred prior to</span></span><br><span class="line">            <span class="comment">// calling parent and the parent</span></span><br><span class="line">            <span class="comment">// may throw ProviderNotFound even though a provider in the child already</span></span><br><span class="line">            <span class="comment">// handled the request</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            lastException = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eraseCredentialsAfterAuthentication</span><br><span class="line">                &amp;&amp; (result <span class="keyword">instanceof</span> CredentialsContainer)) &#123;</span><br><span class="line">            <span class="comment">// Authentication is complete. Remove credentials and other secret data</span></span><br><span class="line">            <span class="comment">// from authentication</span></span><br><span class="line">            ((CredentialsContainer) result).eraseCredentials();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent was null, or didn't authenticate (or throw an exception).</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastException == <span class="keyword">null</span>) &#123;</span><br><span class="line">        lastException = <span class="keyword">new</span> ProviderNotFoundException(messages.getMessage(</span><br><span class="line">                <span class="string">"ProviderManager.providerNotFound"</span>,</span><br><span class="line">                <span class="keyword">new</span> Object[] &#123; toTest.getName() &#125;,</span><br><span class="line">                <span class="string">"No AuthenticationProvider found for &#123;0&#125;"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prepareException(lastException, authentication);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> lastException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>逻辑很清晰，内部使用的是 <code>AuthenticationProvider</code> 接口来认证的，而我们如果要自定义的话，通常是实现这个接口，不过内部已经有很多实现了，如果可以满足需求，直接使用内部实现就可以了<br>认证成功和失败都会发布对应的事件，内部的事件都是继承 <code>AbstractAuthenticationFailureEvent</code> 的，只要捕获这个抽象的事件，就可以处理认证相关的事件了，具体的事件列表如下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AuthenticationSuccessEvent</span><br><span class="line">AuthenticationFailureBadCredentialsEvent</span><br><span class="line">AuthenticationFailureExpiredEvent</span><br><span class="line">AuthenticationFailureProviderNotFoundEvent</span><br><span class="line">AuthenticationFailureDisabledEvent</span><br><span class="line">AuthenticationFailureLockedEvent</span><br><span class="line">AuthenticationFailureServiceExceptionEvent</span><br><span class="line">AuthenticationFailureCredentialsExpiredEvent</span><br><span class="line">AuthenticationFailureProxyUntrustedEvent</span><br></pre></td></tr></table></figure></p>
<p>再看看 <code>AuthenticationProvider</code> 是怎么定义的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两个方法，其中 <code>supports</code> 的方法参数，通常是 <code>Authentication</code> 的子类，根据方法名就知道，每个 <code>AuthenticationProvider</code> 处理特定 <code>Authentication</code> 的类型，很可能是成对出现的<br>security 内部已经实现了一部分了，譬如 </p>
<ol>
<li><code>RememberMeAuthenticationProvider</code> 处理 <code>RememberMeAuthenticationToken</code>  </li>
<li><code>AnonymousAuthenticationProvider</code> 处理 <code>AnonymousAuthenticationToken</code></li>
<li><code>RunAsImplAuthenticationProvider</code> 处理 <code>RunAsUserToken</code></li>
<li><code>PreAuthenticatedAuthenticationProvider</code> 处理 <code>PreAuthenticatedAuthenticationToken</code></li>
<li><code>DaoAuthenticationProvider</code> 处理 <code>UsernamePasswordAuthenticationToken</code>  </li>
<li>。。。</li>
</ol>
<p>这里就已经出现了后台管理系统里面常用的认证方法：用户名密码认证<br><code>DaoAuthenticationProvider</code> 类是继承 <code>AbstractUserDetailsAuthenticationProvider</code> 的<br>我们关注一下 <code>AbstractUserDetailsAuthenticationProvider</code> 的 <code>authenticate</code> 方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    Assert.isInstanceOf(UsernamePasswordAuthenticationToken<span class="class">.<span class="keyword">class</span>, <span class="title">authentication</span>,</span></span><br><span class="line"><span class="class">            <span class="title">messages</span>.<span class="title">getMessage</span>(</span></span><br><span class="line">                    "AbstractUserDetailsAuthenticationProvider.onlySupports",</span><br><span class="line">                    <span class="string">"Only UsernamePasswordAuthenticationToken is supported"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine username</span></span><br><span class="line">    String username = (authentication.getPrincipal() == <span class="keyword">null</span>) ? <span class="string">"NONE_PROVIDED"</span></span><br><span class="line">            : authentication.getName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里只是一个简单的 cache</span></span><br><span class="line">    <span class="keyword">boolean</span> cacheWasUsed = <span class="keyword">true</span>;</span><br><span class="line">    UserDetails user = <span class="keyword">this</span>.userCache.getUserFromCache(username);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cacheWasUsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 抽象方法，子类实现</span></span><br><span class="line">            user = retrieveUser(username,</span><br><span class="line">                    (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (UsernameNotFoundException notFound) &#123;</span><br><span class="line">            logger.debug(<span class="string">"User '"</span> + username + <span class="string">"' not found"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hideUserNotFoundExceptions) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line">                        <span class="string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line">                        <span class="string">"Bad credentials"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> notFound;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Assert.notNull(user,</span><br><span class="line">                <span class="string">"retrieveUser returned null - a violation of the interface contract"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 本类实现的前置检查 检查账号的状态，是否禁用，过期之类的</span></span><br><span class="line">        preAuthenticationChecks.check(user);</span><br><span class="line">        <span class="comment">// 抽象方法，自定义前置检查</span></span><br><span class="line">        additionalAuthenticationChecks(user,</span><br><span class="line">                (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AuthenticationException exception) &#123;</span><br><span class="line">        <span class="comment">// 通过缓存认证失败了，尝试从正常途径获取信息再认证一次</span></span><br><span class="line">        <span class="keyword">if</span> (cacheWasUsed) &#123;</span><br><span class="line">            <span class="comment">// There was a problem, so try again after checking</span></span><br><span class="line">            <span class="comment">// we're using latest data (i.e. not from the cache)</span></span><br><span class="line">            cacheWasUsed = <span class="keyword">false</span>;</span><br><span class="line">            user = retrieveUser(username,</span><br><span class="line">                    (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">            preAuthenticationChecks.check(user);</span><br><span class="line">            additionalAuthenticationChecks(user,</span><br><span class="line">                    (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本类实现的后置检查，密码是否过期了</span></span><br><span class="line">    postAuthenticationChecks.check(user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cacheWasUsed) &#123;</span><br><span class="line">        <span class="keyword">this</span>.userCache.putUserInCache(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object principalToReturn = user;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (forcePrincipalAsString) &#123;</span><br><span class="line">        principalToReturn = user.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来子类重点应该实现 <code>retrieveUser</code> 和做一下其他的校验<br>看看 <code>DaoAuthenticationProvider</code> 里面的实现<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> UserDetails <span class="title">retrieveUser</span><span class="params">(String username,</span></span></span><br><span class="line"><span class="function"><span class="params">        UsernamePasswordAuthenticationToken authentication)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    prepareTimingAttackProtection();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里就是熟悉的 UserDetailsService 了</span></span><br><span class="line">        UserDetails loadedUser = <span class="keyword">this</span>.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (loadedUser == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalAuthenticationServiceException(</span><br><span class="line">                    <span class="string">"UserDetailsService returned null, which is an interface contract violation"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loadedUser;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (UsernameNotFoundException ex) &#123;</span><br><span class="line">        mitigateAgainstTimingAttack(authentication);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InternalAuthenticationServiceException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalAuthenticationServiceException(ex.getMessage(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails,</span></span></span><br><span class="line"><span class="function"><span class="params">        UsernamePasswordAuthenticationToken authentication)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (authentication.getCredentials() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Authentication failed: no credentials provided"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line">                <span class="string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line">                <span class="string">"Bad credentials"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String presentedPassword = authentication.getCredentials().toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里也应该比较熟悉了 PasswordEncoder</span></span><br><span class="line">    <span class="keyword">if</span> (!passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Authentication failed: password does not match stored value"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line">                <span class="string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line">                <span class="string">"Bad credentials"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，如果要用用户名密码认证，只要指定 <code>UserDetailsService</code> 的实现 和 <code>PasswordEncoder</code> 的实现了<br>顺便说一句，<code>PasswordEncoder</code> 有一个代理实现 <code>DelegatingPasswordEncoder</code> ，包装了所有具体实现  </p>
<p>认证流程核心就是这些概念，但是要注意，实际使用肯定不止这些，要使用注解，就得将这些实现跟 aop 结合，要使用拦截器，就得跟 filter 结合，这些后面再细讲  </p>
<h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>授权也就是访问控制，在 security 里面是在 access 包里面<br>授权的核心类是 <code>AbstractSecurityInterceptor</code> (别问我怎么找到的)，这个类的名字虽然是 interceptor ， 但是跟 spring-web 里面的拦截器没关系，只是逻辑上的拦截（跟 shiro 类型），具体的实现类，可以做 aop 拦截 或者 filter 拦截<br>这个类里面涉及到授权相关的很多类 </p>
<ol>
<li><code>AccessDecisionManager</code>  授权管理</li>
<li><code>AfterInvocationManager</code> 鉴权完成后，如果这个不为null，继续鉴权</li>
<li><code>AuthenticationManager</code> 认证管理</li>
<li><code>RunAsManager</code>  权限认证成功后，转换角色用的，默认没有转换功能</li>
<li><code>SecurityMetadataSource</code> 根据调用参数，判断是否需要鉴权</li>
</ol>
<p>这个类实际上是一个辅助类，提供了 调用前 <code>beforeInvocation</code> 调用后 <code>finallyInvocation</code> 调用结束 <code>afterInvocation</code><br>我们一个一个看，首先调用前  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> InterceptorStatusToken <span class="title">beforeInvocation</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(object, <span class="string">"Object was null"</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> debug = logger.isDebugEnabled();</span><br><span class="line">    <span class="comment">// getSecureObjectClass 是一个抽象方法，由子类指定方法参数类型</span></span><br><span class="line">    <span class="keyword">if</span> (!getSecureObjectClass().isAssignableFrom(object.getClass())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">"Security invocation attempted for object "</span></span><br><span class="line">                        + object.getClass().getName()</span><br><span class="line">                        + <span class="string">" but AbstractSecurityInterceptor only configured to support secure objects of type: "</span></span><br><span class="line">                        + getSecureObjectClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里有点关键，就是使用 SecurityMetadataSource 处理调用参数，判断是否需要鉴权</span></span><br><span class="line">    Collection&lt;ConfigAttribute&gt; attributes = <span class="keyword">this</span>.obtainSecurityMetadataSource()</span><br><span class="line">            .getAttributes(object);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (attributes == <span class="keyword">null</span> || attributes.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 默认是 false</span></span><br><span class="line">        <span class="keyword">if</span> (rejectPublicInvocations) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"Secure object invocation "</span></span><br><span class="line">                            + object</span><br><span class="line">                            + <span class="string">" was denied as public invocations are not allowed via this interceptor. "</span></span><br><span class="line">                            + <span class="string">"This indicates a configuration error because the "</span></span><br><span class="line">                            + <span class="string">"rejectPublicInvocations property is set to 'true'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Public object - authentication not attempted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        publishEvent(<span class="keyword">new</span> PublicInvocationEvent(object));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不需要鉴权，返回 null 了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// no further work post-invocation</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Secure object: "</span> + object + <span class="string">"; Attributes: "</span> + attributes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        credentialsNotFound(messages.getMessage(</span><br><span class="line">                <span class="string">"AbstractSecurityInterceptor.authenticationNotFound"</span>,</span><br><span class="line">                <span class="string">"An Authentication object was not found in the SecurityContext"</span>),</span><br><span class="line">                object, attributes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还没认证，那就先做认证，不同，通常，认证应该在之前就做了，设置了 SecurityContextHolder </span></span><br><span class="line">    Authentication authenticated = authenticateIfRequired();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attempt authorization</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里判断权限</span></span><br><span class="line">        <span class="keyword">this</span>.accessDecisionManager.decide(authenticated, object, attributes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AccessDeniedException accessDeniedException) &#123;</span><br><span class="line">        publishEvent(<span class="keyword">new</span> AuthorizationFailureEvent(object, attributes, authenticated,</span><br><span class="line">                accessDeniedException));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> accessDeniedException;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Authorization successful"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (publishAuthorizationSuccess) &#123;</span><br><span class="line">        publishEvent(<span class="keyword">new</span> AuthorizedEvent(object, attributes, authenticated));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换用户，默认这个是返回 null 的</span></span><br><span class="line">    <span class="comment">// Attempt to run as a different user</span></span><br><span class="line">    Authentication runAs = <span class="keyword">this</span>.runAsManager.buildRunAs(authenticated, object,</span><br><span class="line">            attributes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runAs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            logger.debug(<span class="string">"RunAsManager did not change Authentication object"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所以正常逻辑走这里</span></span><br><span class="line">        <span class="comment">// no further work post-invocation</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InterceptorStatusToken(SecurityContextHolder.getContext(), <span class="keyword">false</span>,</span><br><span class="line">                attributes, object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Switching to RunAs Authentication: "</span> + runAs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则，就转换角色（认证凭证换了）</span></span><br><span class="line">        SecurityContext origCtx = SecurityContextHolder.getContext();</span><br><span class="line">        SecurityContextHolder.setContext(SecurityContextHolder.createEmptyContext());</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(runAs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// need to revert to token.Authenticated post-invocation</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InterceptorStatusToken(origCtx, <span class="keyword">true</span>, attributes, object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用后<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finallyInvocation</span><span class="params">(InterceptorStatusToken token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (token != <span class="keyword">null</span> &amp;&amp; token.isContextHolderRefreshRequired()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Reverting to original Authentication: "</span></span><br><span class="line">                    + token.getSecurityContext().getAuthentication());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SecurityContextHolder.setContext(token.getSecurityContext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">afterInvocation</span><span class="params">(InterceptorStatusToken token, Object returnedObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// public object</span></span><br><span class="line">        <span class="keyword">return</span> returnedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    finallyInvocation(token); <span class="comment">// continue to clean in this method for passivity</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (afterInvocationManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Attempt after invocation handling</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            returnedObject = afterInvocationManager.decide(token.getSecurityContext()</span><br><span class="line">                    .getAuthentication(), token.getSecureObject(), token</span><br><span class="line">                    .getAttributes(), returnedObject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AccessDeniedException accessDeniedException) &#123;</span><br><span class="line">            AuthorizationFailureEvent event = <span class="keyword">new</span> AuthorizationFailureEvent(</span><br><span class="line">                    token.getSecureObject(), token.getAttributes(), token</span><br><span class="line">                            .getSecurityContext().getAuthentication(),</span><br><span class="line">                    accessDeniedException);</span><br><span class="line">            publishEvent(event);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> accessDeniedException;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> returnedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个方法的逻辑很简单，重点在 <code>AfterInvocationManager</code> 的实现，作用跟 <code>AccessDecisionManager</code> 类似，也是用来处理权限的  </p>
<p>抽象类下面也就是两个方向，处理注解的 aop 实现 <code>MethodSecurityInterceptor</code> 和 处理 web 的 过滤器实现 <code>FilterSecurityInterceptor</code><br>这两个实现的不同就是调用参数不同，和判断是否需要权限验证的类不同 <code>MethodSecurityMetadataSource</code>, <code>FilterInvocationSecurityMetadataSource</code><br>这个后面再看，先看重点 <code>AccessDecisionManager</code> 的实现，权限判断，主要是这个类做的  </p>
<p>这个里面有一个 <code>AccessDecisionVoter</code> 列表，代表一组权限鉴定器，鉴定结果有3种，授权通过，拒绝，保留意见。<br>具体判断是否授权通过由子类处理，而 <code>AccessDecisionManager</code> 的具体实现，就是鉴定策略，具体实现有<br><code>AffirmativeBased</code>  只有有一个授权通过，那就授权，如果没有通过的，只要有拒绝的，直接拒绝，否则保留意见就看怎么设置的参数了<br><code>ConsensusBased</code>  通过和拒绝的投票数，看哪种结果票数多，如果同票，参数处理<br><code>UnanimousBased</code>  只要有拒绝，那就直接拒绝  </p>
<p>再来看看具体的 aop 拦截器 <code>MethodSecurityInterceptor</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getSecureObjectClass() &#123;</span><br><span class="line">    <span class="keyword">return</span> MethodInvocation<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    InterceptorStatusToken token = <span class="keyword">super</span>.beforeInvocation(mi);</span><br><span class="line"></span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.finallyInvocation(token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.afterInvocation(token, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodSecurityMetadataSource <span class="title">getSecurityMetadataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.securityMetadataSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SecurityMetadataSource <span class="title">obtainSecurityMetadataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.securityMetadataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里</p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-tx 分析</title>
    <url>/2019/09/27/spring-tx-%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><p>稍微想一下，大概就可以猜到，事务是通过 aop 实现的，在前后增强，类似 @Around<br>但是，在 aop 里面就说过了，我们自定义的 aop 才使用 @Around ，框架内部使用的是直接的 Advisor<br>tx 的配置类是 <code>ProxyTransactionManagementConfiguration</code> 里面注册了3个 bean<br><code>BeanFactoryTransactionAttributeSourceAdvisor</code>,  这个后面要详细说，aop 找的就是这个类，这个类使用了下面两个<br><code>TransactionAttributeSource</code>, 这个是用来判断是否有事务的<br><code>TransactionInterceptor</code> 具体做事的地方，Advice 的另一个分支 intercept 的实现，也使用了 <code>TransactionAttributeSource</code>  </p>
<p>我们先看看 <code>TransactionAttributeSource</code> 是干啥的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionAttributeSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">TransactionAttribute <span class="title">getTransactionAttribute</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>看一眼就知道，从方法和类型里面读取事务信息的，估计如果没有读取到，那就不走事务，没有事务 aop<br>使用的具体实现是  <code>AnnotationTransactionAttributeSource</code> 可以进去看看，分为3中类型，ejb，jta，springtx，现在只关注最有一个<br>spring 的使用 <code>@Transactional</code> 注解 </p>
<p>然后看看 <code>TransactionInterceptor</code> 这里是具体做事的地方，细节很复杂，详细看看，对以后配置事务，数据源有帮助<br>实际类型是 <code>TransactionInterceptor</code>  实现了 <code>MethodInterceptor</code> 接口，这个接口是 <code>Advice</code> 的扩展接口<br>里面，invoke 方法直接调用父类的 <code>invokeWithinTransaction</code> 方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">	<span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span></span><br><span class="line">	TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">	Object retVal = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line">		<span class="comment">// This will normally result in a target object being invoked.</span></span><br><span class="line">		retVal = invocation.proceedWithInvocation();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="comment">// target invocation exception</span></span><br><span class="line">		completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		cleanupTransactionInfo(txInfo);</span><br><span class="line">	&#125;</span><br><span class="line">	commitTransactionAfterReturning(txInfo);</span><br><span class="line">	<span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>虽然有 else 的逻辑，但是，大部分走的是这里，逻辑很清晰，这里就不多讲了，直接看细节。<br>首先是创建事务，这里可能创建新事务，具体需要看配置（spring 的事务传播级别）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">createTransactionIfNecessary</span><span class="params">(@Nullable PlatformTransactionManager tm,</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nullable TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If no name specified, apply method identification as transaction name.</span></span><br><span class="line">	<span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; txAttr.getName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">		txAttr = <span class="keyword">new</span> DelegatingTransactionAttribute(txAttr) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TransactionStatus status = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tm != <span class="keyword">null</span>) &#123;</span><br><span class="line">			status = tm.getTransaction(txAttr);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Skipping transactional joinpoint ["</span> + joinpointIdentification +</span><br><span class="line">						<span class="string">"] because no transaction manager has been configured"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实，这里只是调用了 <code>PlatformTransactionManager</code> 的 getTransaction 方法，在这里面处理了传播级别，我们过会看里面的细节，<br>还是看事务的拦截器那里，获取事务，方法调用，异常处理，事务完成<br>我们接下来看看异常处理<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">completeTransactionAfterThrowing</span><span class="params">(@Nullable TransactionInfo txInfo, Throwable ex)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (txInfo != <span class="keyword">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Completing transaction for ["</span> + txInfo.getJoinpointIdentification() +</span><br><span class="line">					<span class="string">"] after exception: "</span> + ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (txInfo.transactionAttribute != <span class="keyword">null</span> &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">				logger.error(<span class="string">"Application exception overridden by rollback exception"</span>, ex);</span><br><span class="line">				ex2.initApplicationException(ex);</span><br><span class="line">				<span class="keyword">throw</span> ex2;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (RuntimeException | Error ex2) &#123;</span><br><span class="line">				logger.error(<span class="string">"Application exception overridden by rollback exception"</span>, ex);</span><br><span class="line">				<span class="keyword">throw</span> ex2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// We don't roll back on this exception.</span></span><br><span class="line">			<span class="comment">// Will still roll back if TransactionStatus.isRollbackOnly() is true.</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">				logger.error(<span class="string">"Application exception overridden by commit exception"</span>, ex);</span><br><span class="line">				ex2.initApplicationException(ex);</span><br><span class="line">				<span class="keyword">throw</span> ex2;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (RuntimeException | Error ex2) &#123;</span><br><span class="line">				logger.error(<span class="string">"Application exception overridden by commit exception"</span>, ex);</span><br><span class="line">				<span class="keyword">throw</span> ex2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一大坨代码，实际上做了两件事，如果抛出的异常是需要回滚的，那就回滚，否则提交，还是使用 <code>PlatformTransactionManager</code> 的方法<br>提交事务一样<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">commitTransactionAfterReturning</span><span class="params">(@Nullable TransactionInfo txInfo)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (txInfo != <span class="keyword">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Completing transaction for ["</span> + txInfo.getJoinpointIdentification() + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么，我们就可以把注意力转移到 <code>PlatformTransactionManager</code> 的实现了，我们先看看这个接口，也就3个方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>外部也只调用了这3个方法<br>下面的继承关系也很简单，只有一个抽象类 <code>AbstractPlatformTransactionManager</code> ，然后下面的都是具体实现了<br>先看  <code>getTransaction</code> 方法,先简单说一下逻辑，代码贴的太多了，<br>首先调用 <code>doGetTransaction</code> 方法获取事务对象，事务对象的具体类型是子类确定的<br>判断事务是否已经存在（方法外部已经有事务了） <code>isExistingTransaction</code> 这个子类实现，<br>如果存在了，那就调用 <code>handleExistingTransaction</code> 方法返回<br>这里就需要判断事务传播级别了，这里先说说传播级别</p>
<ol>
<li>PROPAGATION_REQUIRED  支持当前事务，如果没有，就新建事务，这个是默认的</li>
<li>PROPAGATION_SUPPORTS  支持当前事务，如果没有，那本方法不走业务</li>
<li>PROPAGATION_MANDATORY  支持当前事务，如果没有，就抛异常</li>
<li>PROPAGATION_REQUIRES_NEW  本方法使用新事务，如果当前存在事务了，就暂停当前的事务</li>
<li>PROPAGATION_NOT_SUPPORTED  不支持当前事务，总是以非事务运行</li>
<li>PROPAGATION_NEVER  不支持当前事务，如果存在，抛异常</li>
<li>PROPAGATION_NESTED 如果存在当前事务，本方法就以内部事务运行</li>
</ol>
<p>清楚传播级别后，代码可以自己细看了<br>这里说说新建事务相关的方法 </p>
<ol>
<li>newTransactionStatus 新建事务，这方方法的返回值，就是 getTransaction 的返回值</li>
<li>doBegin 这里才是开始事务，如果没有执行这个方法，实际上是使用当前事务，调用了这个，就是新建事务</li>
<li>prepareSynchronization 这个方法应该是在 doBegin 后面执行的，设置一些线程上下文</li>
<li>prepareTransactionStatus 这个方法包含 newTransactionStatus 和 prepareSynchronization</li>
</ol>
<p>如果是使用当前事务，那么新建的事务对象里面 <code>newTransaction</code> 属性是 false<br>再说 commit 方法，只有当当前的事务对象 <code>newTransaction</code> 是 true 的时候，才调用 <code>doCommit</code> 方法做真正的提交<br>rollback 方法，同样，只有当当前的事务对象 <code>newTransaction</code> 是 true 的时候，才调用 <code>doRollback</code> 方法做回滚<br>除了上面的关键逻辑，还有一些其他的，譬如事务释放只回滚（test的时候用的）,触发一些事件  </p>
<p>那么子类需要实现的方法就有如下方法了  </p>
<ol>
<li>doGetTransaction 获取事务对象，返回的对象是自己定义的类型</li>
<li>isExistingTransaction  当前事务是否存在，参数就是事务对象，自己定义的对象要能够分辨出来事务是否存在</li>
<li>doBegin 开始事务，通常，调用了这个方法，事务才被激活，才能说事务存在</li>
<li>doSuspend 暂停当前事务，返回值会传递给恢复方法 doResume</li>
<li>doResume 恢复事务</li>
<li>doCommit 实际的事务提交</li>
<li>doRollback 实际的事务回滚</li>
<li>doCleanupAfterCompletion 事务结束后的清尾操作</li>
</ol>
<p>上面是必须的，其他的方法，可以覆盖父类，或者自定义方法  </p>
<p>需要看看 <code>DataSourceTransactionManager</code> 管理 jdbc 事务<br>所谓事务，就是当前线程中，执行的方法，要使用同一个数据库连接对象 <code>Connection</code><br>很自然的想要，要使用线程对象来存储，spring 也是这样做的，在 doBegin 的时候，才需要获取数据库连接，存到线程对象中<br>忽略其他细节<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());</span><br></pre></td></tr></table></figure><br>详细的可以看看 <code>TransactionSynchronizationManager</code> 这个类，里面有一堆线程对象<br>顺便说一句，我们可以看到 <code>bindResource</code> 方法第一个对象是key 第二个对象是value，key 是数据库连接池对象<br>我们可以使用 aop 在运行过程中确定使用哪个数据库连接池(数据库),再设置一个默认的数据库连接池，就可以使用多数据库了，不过不支持分布式事务，但是可以做读写分离<br>具体的可以使用 <code>AbstractRoutingDataSource</code><br>事务和连接池的就分析到这里了</p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-mvc-HandlerAdapter详解</title>
    <url>/2019/09/26/spring-mvc-HandlerAdapter%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>HandlerAdapter<br>这个主要是适配器，来调用 handler 的，在之前和之后做一些增强处理，每个 adapter 类型，支持对应的 handler 类型<br>三个方法</p>
<ol>
<li>boolean supports(Object handler);</li>
<li>ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;</li>
<li>long getLastModified(HttpServletRequest request, Object handler);</li>
</ol>
<p>主要有 4 中 adapter</p>
<ol>
<li>HttpRequestHandlerAdapter 这个处理 handler 的类型为 HttpRequestHandler </li>
<li>SimpleServletHandlerAdapter 这个处理 handler 的类型为 Servlet 调用 service 方法</li>
<li>SimpleControllerHandlerAdapter 这个处理 handler 的类型为 Controller </li>
<li>RequestMappingHandlerAdapter 这个是大部分逻辑走的地方，上面3个一般是 spring 自己用的，这个处理的 handler 类型是 HandlerMethod </li>
</ol>
<p>重点关注 RequestMappingHandlerAdapter 其他3个很简单</p>
<p>有一个继承 AbstractHandlerMethodAdapter<br>这里实现 supports 方法 支持 HandlerMethod  并且要满足 supportsInternal 返回true 这是一个抽象方法<br>实现 handle 方法，将 handler 转型为 HandlerMethod ，调用 handleInternal 也是一个抽象方法<br>实现 getLastModified 方法，将 handler 转型为 HandlerMethod ，调用 getLastModifiedInternal 也是一个抽象方法<br>。。。</p>
<p>直接看 RequestMappingHandlerAdapter<br>这个里面的东西就很多了，重点要关注的是初始化方法，这个类实现了 InitializingBean 所以会触发初始化方法 afterPropertiesSet 在这个方法里面，就可以看到它有哪些扩展组件了<br>初始化主要做4件事</p>
<ol>
<li><p>initControllerAdviceCache<br>看名字就知道了 找 @ControllerAdvice 注解的 bean ，<br>然后找里面带 @RequestMapping &amp;&amp; @ModelAttribute 注解的方法，丢到 modelAttributeAdviceCache 里面<br>找带 @InitBinder 注解的方法丢到 initBinderAdviceCache 里面<br>然后处理 RequestBodyAdvice 和 ResponseBodyAdvice</p>
</li>
<li><p>argumentResolvers<br>这里就是请求参数处理的地方，参数处理接口是 HandlerMethodArgumentResolver<br>获取所有默认的参数处理，和自定义的参数处理，默认的优先<br>然后用 HandlerMethodArgumentResolverComposite 对象组合</p>
</li>
<li><p>initBinderArgumentResolvers<br>其实跟上面一样的，只是默认添加的东西不一样，自定义的还是在这里<br>一样是 HandlerMethodArgumentResolver 用 HandlerMethodArgumentResolverComposite 对象组合</p>
</li>
<li><p>returnValueHandlers<br>这个是处理返回结果的 HandlerMethodReturnValueHandler<br>使用 HandlerMethodReturnValueHandlerComposite 对象组合</p>
</li>
</ol>
<p>这里面重要的是要实现3个抽象方法 </p>
<ol>
<li>supportsInternal 这个固定返回 true</li>
<li>getLastModifiedInternal 返回 -1 ，到这里的请求，通常是业务处理，不用 http 缓存</li>
<li>handleInternal<br>就是业务处理了，其实是做业务处理前后的一些事情，具体业务处理是 HanderMethod 完成的</li>
</ol>
<p>这里的逻辑</p>
<ol>
<li>检查 request http 方法这里是否支持，如果需要 session ，则判断 session 是否存在</li>
<li>调用 invokeHandlerMethod 虽然有判断，本质还是调用这个方法<br> 里面的细节不详细看了，看初始化的东西，就知道里面是要干啥了。<br> invokeHandlerMethod 还是要说几句关键步骤<ol>
<li>根据 handler 的参数列表，使用 HandlerMethodArgumentResolver 看看能不能处理该参数，设置对应值，如果有处理不了的就异常了</li>
<li>使用参数，调用 handler 方法，获取返回结果</li>
<li>处理响应码，响应码和原因可以使用注解自定义 @ResponseStatus(code = HttpStatus.ACCEPTED, reason = “test”) 如果没自定义，那就spring 自己处理了，大部分都是 200</li>
<li>然后只用 HandlerMethodReturnValueHandler ，看能不能处理返回类型的东西，譬如我们常用 @RestController 或者 @ResponseBody 返回对象或者字符串的，都会在这里就处理了，写入 response，然后后面就跑流程了</li>
</ol>
</li>
<li>getModelAndView 这里的方法，如果响应结果有人处理了，这里就返回 null 了，如果没处理，可能就是返回的 modelandview 或者 view ，构造返回</li>
</ol>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-mvc-HandlerMapping详解</title>
    <url>/2019/09/25/spring-mvc-HandlerMapping%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>HandlerMapping</p>
<p>这个类的主要作用就是匹配 request 有哪个 handler 处理<br>返回的是 HandlerExecutionChain 里面包含 具体的 handler 拦截器 和 跨域处理</p>
<p>重要的 handlerMapping 主要有几个，都是继承</p>
<p>AbstractHandlerMapping </p>
<p>这个类里面处理 拦截器 跨域，url 匹配的类<br>最终，这里实现了 getHandler 方法，并且是 final 的，不允许付款，也就是说，这里定义了寻找 handler 的具体流程</p>
<ol>
<li>getHandlerInternal 这个方法留给子类实现</li>
<li>上一步如果没找到就 getDefaultHandler  这个默认处理器是外部设置的</li>
<li>上面两步没找到，那就是没有了</li>
<li>如果找到了，判断是否为 string，如果是，则认为是 beanName，直接在容器里根据 beanName 获取，这里没捉异常，没获取到就异常出去了</li>
<li>使用这个找到的 handler 构建 HandlerExecutionChain ，添加拦截器</li>
<li>如果是cors跨域请求，分两种，一是 option 方法 handler 换成 PreFlightHandler 内部是 DefaultCorsProcessor 处理的，二是正常请求，带 origin 了，在 chain 里面添加一个 cors 拦截器 CorsInterceptor，内部也是 DefaultCorsProcessor 处理的 </li>
</ol>
<p>接下来，子类各自实现 getHandlerInternal 方法就可以了<br>下面一层有两个子类 </p>
<ol>
<li>AbstractUrlHandlerMapping 这个是基于处理 url 的</li>
<li>AbstractHandlerMethodMapping  </li>
</ol>
<p>AbstractUrlHandlerMapping 里面又添加了一个 rootHandler ，外部设置，用来处理 / 的请求，这里的 getHandlerInternal 处理流程是</p>
<ol>
<li>根据 request 获取 url：lookupPath</li>
<li>使用这个 lookupPath 获取 handler ，调用的是 lookupHandler 方法</li>
<li>如果没找到，判断 URL 是否为 /,如果是，就使用 rootHandler </li>
<li>如果还是 null  就使用 defaultHandler</li>
<li>如果存在了 ，判断是否为 string，如果是，则认为是 beanName，直接在容器里根据 beanName 获取，这里没捉异常，没获取到就异常出去了</li>
<li>validateHandler 验证一下，这个留给子类实现</li>
<li>构建 HandlerExecutionChain，这里构建的 chain 里面添加了 PathExposingHandlerInterceptor 拦截器，可能添加 UriTemplateVariablesHandlerInterceptor 拦截器 这两个拦截器的作用就是在 request 里面设置一些属性，还有 第二步，如果找到 handler 后，构建步骤跟这里的一样</li>
</ol>
<p>这个类有一个 map 存放 url -&gt; handler  有一个方法 registerHandler 给子类往里面注册 handler  </p>
<p>这个抽象类下面，就有2个直接实现了<br>WelcomePageHandlerMapping<br>这个类重写了 getHandlerInternal 方法，根据 request 的 accept ，来判断，如果包含 text/html 那就调用父类，也就是上面的查找流程，否则返回null，也就是，这里只处理 html 请求，不过看名字也就清楚了</p>
<p>SimpleUrlHandlerMapping<br>这个类就是注册处理 handler 或者 handler 的 beanName<br>在本类初始化的过程中，会根据注册的信息完成初始化，简单的说，就是这个对象有一个 Map<String,Object> 左边是 url 右边是 handler 或者 beanName，在初始化过程中，如果是 beanName 那么就会从容器里面获取 handler<br>另外，如果注册的 url 是 / 那么本 handler 就是 rootHandler ，如果 url 是 /* 那么 handler 就是 defaultHandler 注意一点的是 </p>
<p>除了上面有个直接实现，还有一个抽象子类 AbstractDetectingUrlHandlerMapping</p>
<p>AbstractDetectingUrlHandlerMapping<br>这个抽象类，也是在初始化的时候寻找 handler，过程是获取容器里的所有 beanName，使用 determineUrlsForHandler 传入参数是 beanName 来获取 url 数组，如果获取到了，就注册 handler<br>determineUrlsForHandler 这个方法是一个抽象方法，子类实现</p>
<p>接下来的实现类是<br>BeanNameUrlHandlerMapping</p>
<p>那么这个类主要功能就是判断 beanName 是不是 / 开头的，如果是，那么就代表，本类是 handler 类，处理的url 就是 beanName， 如果 beanName 没有 / 开头，继续看别名</p>
<p>这里是分割线，接下来换另一个继承分支,这个分支才是正常流程常走的地方<br>AbstractHandlerMethodMapping<br>这里面重要的属性是 MappingRegistry 就是 handler 注册的地方，在初始化的时候做一些事情<br>首先，获取所有 beanName， 然后排除一部分代理 也就是 beanName 以 scopedTarget. 开头的，排除后，就获取 beanName 对应的 class ，判断是否为 hander ，如果是，就找里面的 method 然后注册 handler<br>这里的 handler 类型都是 HandleMehtod ，是根据方法划分的，上面的 AbstractUrlHandlerMapping 是一个 bean 就是 handler<br>判断是否为 handler 类型方法 isHandler 由子类实现，<br>获取 handlemethod 的方法 detectHandlerMethods 逻辑为</p>
<ol>
<li>获取具体类型,如果是代理，就找到具体类</li>
<li>过滤方法的具体逻辑是 getMappingForMethod ，这个也是子类实现，方法包含了类型的所有接口</li>
<li>找到后就注册 handler ，三个参数 mapping, handler, method  其中 mapping 是泛型的，handler 就是处理的 beanName 或者 handler 对象，method 就是找到的方法</li>
<li>使用 handlerMethodsInitialized 方法处理已经注册的 handler ，空方法，留给子类覆盖</li>
</ol>
<p>上面是初始化的过程，后面要具体看看 MappingRegistry 的注册和逻辑<br>这个类有一个注册方法 register ，里面会 initCorsConfiguration 初始化自定义 cors 跨域配置，这是一个抽象方法</p>
<p>这个类的 getHandlerInternal 逻辑</p>
<ol>
<li>处理 url 获取 lookupPath</li>
<li>根据 url 找 HandlerMethod  方法是 lookupHandlerMethod<br>怎么找的，就是根据 url 找 mapping 如果没找到 mapping  如果有 mapping（列表） 那就遍历 根据 mapping 和 request 找匹配的 mapping 方法是 getMatchingMapping  子类实现<br>如果没有匹配的，那就使用所有的 mapping 都试着匹配一次<br>如果没匹配到 handleNoMatch 默认返回 null<br>匹配到的话，getMappingComparator 根据 request 获取排序器，将匹配到的 mapping 进行排序，然后找到里面最匹配的一个，最匹配的一个就是第一个，实际上排序就完成了选择了，如果多个匹配，则异常<br>执行 handleMatch 匹配成功方法，这里只是设置一个 request 属性<br>返回 HandlerMethod</li>
</ol>
<p>接下来继续看下面的子类<br>RequestMappingInfoHandlerMapping<br>这里，泛型已经具体了 RequestMappingInfo  很多匹配逻辑都在里面，后面可以看看<br>这个抽象类实现了一些方法  </p>
<ol>
<li>getMatchingMapping  找到匹配的方法 ，具体是 RequestMappingInfo.getMatchingCondition（request）</li>
<li>getMappingComparator 获取排序器，实际上是 RequestMappingInfo 有 compareTo 方法了，直接比较就行了</li>
<li>handleMatch 在匹配成功后做的一些操作，继续设置一些 request 属性，譬如 mediatype uri 参数</li>
<li>handleNoMatch 在没匹配后做的一些操作，具体就是，看到底是什么不匹配，抛出对应异常，譬如 HttpRequestMethodNotSupportedException ,HttpMediaTypeNotSupportedException 等</li>
</ol>
<p>接下来就到最终实现类了<br>RequestMappingHandlerMapping<br>首先，他要实现的是 isHandler ，判断 bean 是否为处理类，逻辑是类上有注解 @Controller 或者 @RequestMapping ，注解上的注解也行<br>接下来是 getMappingForMethod 这个方法是判断 method 是否为处理方法的。逻辑是看有没有 @RequestMapping 注解，注解上的注解也行，譬如 @GetMapping<br>然后 initCorsConfiguration 方法，重写了，处理类上和方法上的 @CrossOrigin 注解，自定义 cors 跨域配置<br>最后有一个 match 方法，是 MatchableHandlerMapping 接口定义的，使用 request 和 pattern 进行匹配</p>
<p>上面留了两个坑，AbstractHandlerMethodMapping 类里面的 MappingRegistry 和 RequestMappingInfoHandlerMapping 类里面的 RequestMappingInfo<br>这两个涉及到注册 handler 和 判断是否匹配，待填</p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-webmvc 分析</title>
    <url>/2019/09/24/spring-webmvc-%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="ApplicationContextInitializer"><a href="#ApplicationContextInitializer" class="headerlink" title="ApplicationContextInitializer"></a>ApplicationContextInitializer</h2><ol>
<li>class org.springframework.boot.context.config.DelegatingApplicationContextInitializer</li>
<li>class org.springframework.boot.context.ContextIdApplicationContextInitializer</li>
<li>class org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer</li>
<li>class org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer</li>
<li>class org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer</li>
<li>class org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</li>
</ol>
<h2 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h2><ol>
<li>class org.springframework.boot.context.config.ConfigFileApplicationListener</li>
<li>class org.springframework.boot.context.config.AnsiOutputApplicationListener</li>
<li>class org.springframework.boot.context.logging.LoggingApplicationListener</li>
<li>class org.springframework.boot.context.logging.ClasspathLoggingApplicationListener</li>
<li>class org.springframework.boot.autoconfigure.BackgroundPreinitializer</li>
<li>class org.springframework.boot.context.config.DelegatingApplicationListener</li>
<li>class org.springframework.boot.builder.ParentContextCloserApplicationListener</li>
<li>class org.springframework.boot.ClearCachesApplicationListener</li>
<li>class org.springframework.boot.context.FileEncodingApplicationListener</li>
<li>class org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener</li>
</ol>
<p>org.springframework.boot.SpringApplicationRunListener</p>
<p>org.springframework.boot.context.event.EventPublishingRunListener</p>
<p>使用的 ApplicationContext<br>org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext</p>
<p>继承下面的<br>ServletWebServerApplicationContext</p>
<p>先放一张图<br><img src="/2019/09/24/spring-webmvc-%E5%88%86%E6%9E%90/spring-mvc.png" class="" title="This is an example image"></p>
<h2 id="9大组件"><a href="#9大组件" class="headerlink" title="9大组件"></a>9大组件</h2><p>编号后面是接口，下面是默认实现</p>
<ol>
<li>MultipartResolver<br>class org.springframework.web.multipart.support.StandardServletMultipartResolver<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MultipartResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isMultipart</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">MultipartHttpServletRequest <span class="title">resolveMultipart</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> MultipartException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cleanupMultipart</span><span class="params">(MultipartHttpServletRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>顾名思义，这里就是处理文件上传的地方，做三件事，判断请求是不是文件上传，将 request 转换成 文件上传 request，以及清理工作<br><code>StandardServletMultipartResolver</code> 标准解析，其实只是从标准 request 解析part 出来，所谓转行 request，实际上是让内部知道是否为文件上传请求，接收一个参数，用来控制是否立即解析，<br>默认是立即解析，非立即就是在第一次调用 getMultipart 的时候触发解析</p>
<ol>
<li>LocaleResolver<br>class org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LocaleResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Locale <span class="title">resolveLocale</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setLocale</span><span class="params">(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable Locale locale)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语言解析，两个方法，解析使用的语言，设置语言。<code>AcceptHeaderLocaleResolver</code> 这个就是从请求头里面解析，但是没法设置   </p>
<ol>
<li>ThemeResolver<br>class org.springframework.web.servlet.theme.FixedThemeResolver<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThemeResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">resolveThemeName</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setThemeName</span><span class="params">(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable String themeName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>主题解析和设置</p>
<ol>
<li>HandlerMapping<br>class org.springframework.web.servlet.handler.SimpleUrlHandlerMapping<br>class org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping<br>class org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping<br>class org.springframework.boot.autoconfigure.web.servlet.WelcomePageHandlerMapping</li>
</ol>
<p>重头戏，这里很重要<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMapping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + ".pathWithinHandlerMapping";</span><br><span class="line"></span><br><span class="line">	String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + ".bestMatchingPattern";</span><br><span class="line"></span><br><span class="line">	String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + ".introspectTypeLevelMapping";</span><br><span class="line"></span><br><span class="line">	String URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + ".uriTemplateVariables";</span><br><span class="line"></span><br><span class="line">	String MATRIX_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + ".matrixVariables";</span><br><span class="line"></span><br><span class="line">	String PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.class.getName() + ".producibleMediaTypes";</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只有一个方法，返回 <code>HandlerExecutionChain</code>,这里面将有 handler 实例（controller 里面的方法）还有拦截器，里面是具体执行的业务逻辑<br>列出里面关键字段<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerInterceptor&gt; interceptorList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> interceptorIndex = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>上面关键的是 RequestMappingHandlerMapping 大部分业务处理在这里</p>
<ol>
<li>HandlerAdapter<br>class org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter<br>class org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter<br>class org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter</li>
</ol>
<p>为什么会有 adapter 呢，是为了增强，需要在业务逻辑前后做一些处理，譬如参数注入，返回数据处理等    </p>
<p><code>RequestMappingHandlerAdapter</code> 处理的 handler 为 <code>HandlerMethod</code><br><code>HttpRequestHandlerAdapter</code> 处理的 handler 为 <code>HttpRequestHandler</code><br><code>SimpleControllerHandlerAdapter</code> 处理的 handler 为 <code>Controller</code> 这里的 controler 是一个接口，不是常用的注解  </p>
<p>从 debug 路径来看，大部分的 handler 都是 <code>HandlerMethod</code>, 也就是说，使用的代理是 <code>RequestMappingHandlerAdapter</code><br>除了上面默认的几个外，还有一个实现 <code>SimpleServletHandlerAdapter</code> 这个是处理 <code>Servlet</code> 的  </p>
<p>接下来重点关照 <code>RequestMappingHandlerAdapter</code>    </p>
<p>首先，要看一下调用流程,下面是 <code>doDispatch</code> 方法里面的片段<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">String method = request.getMethod();</span><br><span class="line"><span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line"><span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">	<span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></pre></td></tr></table></figure><br>可以看到在获取到对应的 adapter 后，先触发前置拦截器，这里说明一下 <code>mappedHandler</code> 是 <code>HandlerExecutionChain</code> 类型，可以通过调用其 <code>getHandler</code> 方法获取处理类，<code>mappedHandler</code> 里面还有拦截器等其他信息.<br>然后就是 adapter 执行 handler 了，注意传入的参数，请求，响应，以及处理 handler，这个handler 是 adapter 支持的 handler    </p>
<p>看看里面的处理逻辑,很长，又是代码了    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">			HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	ModelAndView mav;</span><br><span class="line">	<span class="comment">// 检查 http method 是否支持，如果需要 session 则判断是否存在 session</span></span><br><span class="line">	checkRequest(request);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">		HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">			Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line">			<span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">				mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// No HttpSession available -&gt; no mutex necessary</span></span><br><span class="line">			mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// No synchronization on session demanded at all...</span></span><br><span class="line">		mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">			applyCacheSeconds(response, <span class="keyword">this</span>.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			prepareResponse(response);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然多，核心方法是 <code>invokeHandlerMethod</code>,其他的是控制代码，后面有兴趣可以仔细看看<br>这个方法又是一个很复杂的方法，需要细看，里面有很多请求处理相关的，譬如参数是如果映射的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">			HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// 包装一下 request，这个就是内部常用到的 WebRequest 的实现类了</span></span><br><span class="line">	ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 处理 @InitBinder 注解的，很少用到，跳过，全局的可以通过 @ControllerAdvice 注解的类定义，全局优先</span></span><br><span class="line">		WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line">		<span class="comment">// @RequestMapping &amp;&amp; @ModelAttribute 注解同时标记的，同上，全局优先,  PS: 这个注解也用的比较少，后面可以瞅瞅</span></span><br><span class="line">		ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line">		<span class="comment">// 这个类继承 HandlerMethod ，new 一个，就是把原来的属性全部赋值给新的对象了</span></span><br><span class="line">		ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">		<span class="comment">// 设置 参数解析，这里就应该熟悉了，比如常用的 @RequestParam 注解等，都是这里处理的，也可以自己定义添加 HandlerMethodArgumentResolver</span></span><br><span class="line">		<span class="comment">// 这里是 HandlerMethodArgumentResolverComposite 里面组合所有的实际解析类</span></span><br><span class="line">		<span class="comment">// 在 getDefaultArgumentResolvers 方法里面，有默认清单</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 设置响应解析，基本同上，接口是 HandlerMethodReturnValueHandler</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			invocableMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">		&#125;</span><br><span class="line">		invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">		invocableMethod.setParameterNameDiscoverer(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这里填充 一些属性 主要是围绕 @ModelAttribute 注解</span></span><br><span class="line">		ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</span><br><span class="line">		mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">		modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">		mavContainer.setIgnoreDefaultModelOnRedirect(<span class="keyword">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// servlet3.0 的异步请求</span></span><br><span class="line">		AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">		asyncWebRequest.setTimeout(<span class="keyword">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">		asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</span><br><span class="line">		asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">		asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</span><br><span class="line">		asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">			Object result = asyncManager.getConcurrentResult();</span><br><span class="line">			mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">			asyncManager.clearConcurrentResult();</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Found concurrent result value ["</span> + result + <span class="string">"]"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 上面都是异步相关，一般都是跳过，这里才是调用，之前的一些字段已经设置到 invocableMethod 里面了 mavContainer 里面包含 session 属性</span></span><br><span class="line">		invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">		<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取响应结果</span></span><br><span class="line">		<span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		webRequest.requestCompleted();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续重点方法分析 <code>invokeAndHandle</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">			Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 调用，获取返回结果，里面涉及到 参数注入，记住一点，处理方法的参数，一定是要 HandlerMethodArgumentResolver 可以处理的</span></span><br><span class="line">	Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置 http 响应状态码，大部分时候，这里是没设置的，除非使用注解 @ResponseStatus 标记</span></span><br><span class="line">	setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于没有返回值的情况，如果是 请求资源没变（http 缓存），或者自定义响应状态码了（譬如204），或者已经被标记处理过了，那么标记处理完成</span></span><br><span class="line">	<span class="comment">// 如果有状态说明原因，也处理完成</span></span><br><span class="line">	<span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">			mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">		mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 否则，接下来就处理响应结果，这是大部分时候走的地方，关于请求参数和响应结果的处理，可以详细看看初始化的时候，spring 默认设置了哪些，这里就不往下看了</span></span><br><span class="line">	mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line">	Assert.state(<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>, <span class="string">"No return value handlers"</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">				returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(getReturnValueHandlingErrorMessage(<span class="string">"Error handling return value"</span>, returnValue), ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取最终结果<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ModelAndView <span class="title">getModelAndView</span><span class="params">(ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">			ModelFactory modelFactory, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	modelFactory.updateModel(webRequest, mavContainer);</span><br><span class="line">	<span class="keyword">if</span> (mavContainer.isRequestHandled()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ModelMap model = mavContainer.getModel();</span><br><span class="line">	ModelAndView mav = <span class="keyword">new</span> ModelAndView(mavContainer.getViewName(), model, mavContainer.getStatus());</span><br><span class="line">	<span class="keyword">if</span> (!mavContainer.isViewReference()) &#123;</span><br><span class="line">		mav.setView((View) mavContainer.getView());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (model <span class="keyword">instanceof</span> RedirectAttributes) &#123;</span><br><span class="line">		Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();</span><br><span class="line">		HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line">			RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>HandlerExceptionResolver<br>class org.springframework.boot.web.servlet.error.DefaultErrorAttributes<br>class org.springframework.web.servlet.handler.HandlerExceptionResolverComposite</li>
</ol>
<p>异常处理,处理的是 adpeter 调用 handle 方法可能出现的异常<br>在 processDispatchResult 方法里面处理了<br>有一个 HandlerExceptionResolver 列表，处理异常</p>
<ol>
<li>RequestToViewNameTranslator<br>class org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</li>
</ol>
<p>处理响应结果和异常，没有返回 mv 的时候，尝试获取对应的view<br>这里只在 getDefaultViewName 方法里面使用，从 request 的url 找到对应的模版</p>
<ol>
<li>ViewResolver<br>class org.springframework.web.servlet.view.ContentNegotiatingViewResolver<br>class org.springframework.web.servlet.view.BeanNameViewResolver<br>class org.springframework.web.servlet.view.ViewResolverComposite<br>class org.springframework.web.servlet.view.InternalResourceViewResolver</li>
</ol>
<p>视图渲染<br>根据 view name 找到对应的视图<br>一个 ViewResolver 列表，遍历</p>
<ol>
<li>FlashMapManager<br>class org.springframework.web.servlet.support.SessionFlashMapManager</li>
</ol>
<p>用来保存上一次请求设置的数据，这样在本次请求就可以获取了</p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring分析-aop详解</title>
    <url>/2019/09/23/spring%E5%88%86%E6%9E%90-aop%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>总所周知，aop 的核心是动态代理 ，但是 动态代理 是如何跟 ioc 容器结合，是什么时候生成代理对象，怎么生成代理对象，什么情况下才会有 aop ， advice ， advisor， pointcut 这些概念在代码里面的体现?<br>我们需要知道 spring 的 aop 在容器中的运行机制，而不是一句简单的动态代理</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>核心类为 <code>AnnotationAwareAspectJAutoProxyCreator</code> ,为什么一上来就是这个类，可以看 springboot 里面 aop 的自动<br>配置类里面，就可以看到这个类了<br>那么这个类是怎么起作用的，我们知道，aop 的核心就是动态代理，代理，肯定需要代理一个对象，<br>我们也很清楚，被代理的是 spring 容器里面的 bean 实例，那么，需要使用代理对象替换容器里面的对象<br>需要使用 ioc 的扩展接口 <code>BeanPostProcessor</code> 及其子接口，我们往这个类的父类上看看，就可以<br>看到 <code>AbstractAutoProxyCreator</code> 这个类就是实现了 <code>SmartInstantiationAwareBeanPostProcessor</code> 接口</p>
<p>经过简单的测试和 debug 跟踪，发现，代理发生的方式是 <code>postProcessAfterInitialization</code> 这个方法是在<br>bean 实例化之后发生的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">		Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">			<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重点在 <code>wrapIfNecessary</code> 方法，这个地方就是用来判断是否需要使用代理,贴出关键代码片段<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create proxy if we have advice.</span></span><br><span class="line"><span class="comment">// 这里就是找代理增强的动作</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">	<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">	<span class="comment">// 创建代理</span></span><br><span class="line">	Object proxy = createProxy(</span><br><span class="line">			bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">	<span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">	<span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，上面就是两个关键动作，找到需要增强的动作，然后创建代理<br>我们先看看怎么找增强动作<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 找出增强</span></span><br><span class="line">	List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">	<span class="comment">// 是否可以用在本类型上</span></span><br><span class="line">	List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">	<span class="comment">// 这个留给子类玩</span></span><br><span class="line">	extendAdvisors(eligibleAdvisors);</span><br><span class="line">	<span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">	    <span class="comment">// 排序</span></span><br><span class="line">		eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是在类 AnnotationAwareAspectJAutoProxyCreator 里面的实现</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Add all the Spring advisors found according to superclass rules.</span></span><br><span class="line">	List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line">	<span class="comment">// Build Advisors for all AspectJ aspects in the bean factory.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorsBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">		advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到先调用 super 的，然后调用本类的，找 aspect 相关的<br>实际上，这里处理的是两个类型的，一般增强的动作，概念上就是 Adivce ，而它下面可以分为两个分支<br>一个是 aspect 的 before after around 这一批，另一个是 intercept 这一批<br>第一批通常是我们自定义用的，第二批通常是框架用的，如果是框架用，通常直接就注册 advisor 了<br>这里父类处理的就是 框架的，子类处理的，就是自定义的，我们详细看看<br>先看父类处<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (advisorNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">	<span class="comment">// uninitialized to let the auto-proxy creator apply to them!</span></span><br><span class="line">	advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">			<span class="keyword">this</span>.beanFactory, Advisor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">	<span class="keyword">this</span>.cachedAdvisorBeanNames = advisorNames;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">advisors.add(<span class="keyword">this</span>.beanFactory.getBean(name, Advisor<span class="class">.<span class="keyword">class</span>))</span>;</span><br></pre></td></tr></table></figure><br>这里是在容器里面直接找 <code>Advisor</code> 类型的 bean，我们可以结合自己使用 aop 的方式看<br>我们通常使用 aop 就是定义 aspect 使用 @Aspect 注解 ，定义 pointcut 和 advice<br>基本确定，自己使用的 aop 肯定不是在这里处理的，那么我们再看看子类的处理(只有关键步骤)<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">		<span class="keyword">this</span>.beanFactory, Object<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// We must be careful not to instantiate beans eagerly as in this case they</span></span><br><span class="line"><span class="comment">// would be cached by the Spring container but would not have been weaved.</span></span><br><span class="line">Class&lt;?&gt; beanType = <span class="keyword">this</span>.beanFactory.getType(beanName);</span><br><span class="line"><span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">	aspectNames.add(beanName);</span><br><span class="line">	AspectMetadata amd = <span class="keyword">new</span> AspectMetadata(beanType, beanName);</span><br><span class="line">	<span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">		MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">				<span class="keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">		List&lt;Advisor&gt; classAdvisors = <span class="keyword">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">		&#125;</span><br><span class="line">		advisors.addAll(classAdvisors);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Per target or per this.</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Bean with name '"</span> + beanName +</span><br><span class="line">					<span class="string">"' is a singleton, but aspect instantiation model is not singleton"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">				<span class="keyword">new</span> PrototypeAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">		<span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">		advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一般走上面的判断，判断就是看是单例还是原型，重点逻辑是<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">		<span class="keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">List&lt;Advisor&gt; classAdvisors = <span class="keyword">this</span>.advisorFactory.getAdvisors(factory);</span><br></pre></td></tr></table></figure></p>
<p>这里获取 Advisor ，但是之前说过了，我们自定使用的 aop 是没有实现 Advisor 的，我们使用的是注解 @Aspect @Pointcut @Before @Around 等<br>那么，里面肯定有一个转换过程，我们进去看看 getAdvisors 方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;</span><br><span class="line">	Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);</span><br><span class="line">	<span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">		advisors.add(advisor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// Find introduction fields.</span></span><br><span class="line"><span class="keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;</span><br><span class="line">	Advisor advisor = getDeclareParentsAdvisor(field);</span><br><span class="line">	<span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">		advisors.add(advisor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>里面有两个重点，一个是处理方法，一个是处理字段<br>自己可以进去看看，方法是没有 @Pointcut 注解的，都要处理<br>处理的逻辑就是方法带 Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class 注解的<br>构造 InstantiationModelAwarePointcutAdvisorImpl 返回，我们清楚，这里就有了 Advice 增强动作，pointcut 哪里增强<br>事件上 beforeAdvice 也有哪里增强的逻辑（before），所以真正标识在哪里增强的，应该是 Advisor 实例，这个是 spring 内部帮忙处理的</p>
<p>在看看怎么处理字段的<br>它处理的是带 @DeclareParents 注解的，返回 DeclareParentsAdvisor 实例，具体的，可以看看这个注解的用法，这里就不详看了  </p>
<p>到这里，找到 Advisor 哪里增强，就结束了，接下来就是创建代理的过程。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建代理</span></span><br><span class="line">Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br></pre></td></tr></table></figure></p>
<p>传入的参数，class 类型，beanName，这里的 specificInterceptors 就是返回的 Advisor ，保证一下原始对象<br>我们看看创建代理的详细过程<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, @Nullable String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">			@Nullable Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">		AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">	proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">			proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">	proxyFactory.addAdvisors(advisors);</span><br><span class="line">	proxyFactory.setTargetSource(targetSource);</span><br><span class="line">	customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">	proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">	<span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">		proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看上起很多，事件上逻辑很简单 </p>
<ol>
<li>判断使用 cglib 还是 java 的动态代理</li>
<li>buildAdvisors 其实就是返回之前的参数，里面会添加自定义的（commonInterceptors），但是通常是没有</li>
<li>创建代理<br>重点在创建代理，我们已经知道了，只有两种情况，直接看就行了<br>先看看 cglib 的，先要会 cglib 的基本 api 才行  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">Enhancer enhancer = createEnhancer();</span><br><span class="line"><span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">	enhancer.setClassLoader(classLoader);</span><br><span class="line">	<span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">			((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">		enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</span><br><span class="line"></span><br><span class="line">Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">	types[x] = callbacks[x].getClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(</span><br><span class="line">		<span class="keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line"><span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面重点有两个，一个是设置 callback 一个是 setCallbackFilter<br>callback 是一个数组 ProxyCallbackFilter 里面有一个方法，返回 int 类型，是 callback 数组的下标，对应的 callback 处理<br>重点关注 aop 的 callback 就可以了 DynamicAdvisedInterceptor 使用的是这个<br>里面重点就是一行，其他的可以自己看<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br></pre></td></tr></table></figure></p>
<p>里面的具体调用过程就是代理过程了<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//	We start with an index of -1 and increment early.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object interceptorOrInterceptionAdvice =</span><br><span class="line">		<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line"><span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">	<span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line">	<span class="comment">// been evaluated and found to match.</span></span><br><span class="line">	InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">			(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">	<span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">		<span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Dynamic matching failed.</span></span><br><span class="line">		<span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">		<span class="keyword">return</span> proceed();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// It's an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">	<span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">	<span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个调用模式可以学一学<br>到这里，cglib 的实现就看完了，其实大部分时候，就是用的 cglib 动态代理<br>jdk 的动态代理，就是实现 <code>InvocationHandler</code> 然后看看 invoke 方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		MethodInvocation invocation;</span><br><span class="line">	Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">	Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">			<span class="comment">// The target does not implement the equals(Object) method itself.</span></span><br><span class="line">			<span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">			<span class="comment">// The target does not implement the hashCode() method itself.</span></span><br><span class="line">			<span class="keyword">return</span> hashCode();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">			<span class="comment">// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span></span><br><span class="line">			<span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">				method.getDeclaringClass().isAssignableFrom(Advised<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">			<span class="comment">// Service invocations on ProxyConfig with the proxy config...</span></span><br><span class="line">			<span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object retVal;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">			<span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">			oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">			setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Get as late as possible to minimize the time we "own" the target,</span></span><br><span class="line">		<span class="comment">// in case it comes from a pool.</span></span><br><span class="line">		target = targetSource.getTarget();</span><br><span class="line">		Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Get the interception chain for this method.</span></span><br><span class="line">		List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check whether we have any advice. If we don't, we can fallback on direct</span></span><br><span class="line">		<span class="comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span></span><br><span class="line">		<span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">			<span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line">			<span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line">			<span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">			Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">			retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// We need to create a method invocation...</span></span><br><span class="line">			invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">			<span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">			retVal = invocation.proceed();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Massage return value if necessary.</span></span><br><span class="line">		Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">		<span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">				returnType != Object<span class="class">.<span class="keyword">class</span> &amp;&amp; <span class="title">returnType</span>.<span class="title">isInstance</span>(<span class="title">proxy</span>) &amp;&amp;</span></span><br><span class="line"><span class="class">				!<span class="title">RawTargetAccess</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line">			<span class="comment">// Special case: it returned "this" and the return type of the method</span></span><br><span class="line">			<span class="comment">// is type-compatible. Note that we can't help if the target sets</span></span><br><span class="line">			<span class="comment">// a reference to itself in another returned object.</span></span><br><span class="line">			retVal = proxy;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line">					<span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">			<span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">			targetSource.releaseTarget(target);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">			<span class="comment">// Restore old proxy.</span></span><br><span class="line">			AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 一大坨代码，自己看了<br> 到此，aop 流程就结束了 </p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>spring</tag>
        <tag>aop</tag>
      </tags>
  </entry>
  <entry>
    <title>spring分析-aop浅析</title>
    <url>/2019/09/21/spring%E5%88%86%E6%9E%90-aop%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li>Advice 通知<br>定义在连接点做什么，BeforeAdvice，AfterAdvice，ThrowsAdvice 等</li>
<li>Pointcut 切点<br>定义 Advice 作用哪个连接点</li>
<li>Advisor 通知器<br>组合 Advice 和 Pointcut</li>
</ol>
<p><strong>动态代理</strong></p>
<ol>
<li>JDK 的动态代理（基于接口的）</li>
<li>Cglib 的字节码增强（spring5 还有 Objenesis ）</li>
</ol>
<p>简单点说， Advice 就是要做什么 ， Pointcut 是在哪里做，通常我们不需要关注 Advisor ，这个是 spring 内部用来连接 Advice 和 Pointcut 的<br>Advice 有很两种，一种是 beforeAdvice，afterAdvice，aroundAdvie 这是一类，还有 Interceptor 也是一类<br>通常，我们用户使用注解方式的，使用的是第一类，spring 内部扩展，使用的是第二类，譬如 spring-tx 事务</p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>spring</tag>
        <tag>aop</tag>
      </tags>
  </entry>
  <entry>
    <title>spring分析-aop</title>
    <url>/2019/09/20/spring%E5%88%86%E6%9E%90-aop/</url>
    <content><![CDATA[<h2 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h2><p>AOP 的注解核心配置类是 <code>AnnotationAwareAspectJAutoProxyCreator</code><br>现在不考虑 xml 的配置方式   </p>
<p>一直向上，找继承链到 <code>AbstractAutoProxyCreator</code>, 这个类实现 <code>SmartInstantiationAwareBeanPostProcessor</code> 接口<br>而 <code>SmartInstantiationAwareBeanPostProcessor</code> 接口是 <code>BeanPostProcessor</code> 的子接口，作用是在 bean 实例化过程中做些扩展具体的在实例化里面可以看<br>重点方法是 <code>postProcessAfterInitialization</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">		Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">			<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        Object proxy = createProxy(</span><br><span class="line">                bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一步就是找到拦截器，也就是通知器，然后就是创建代理    </p>
<h3 id="获取拦截-Advisor"><a href="#获取拦截-Advisor" class="headerlink" title="获取拦截 Advisor"></a>获取拦截 Advisor</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">        Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到所有的 Advisor，这里就是直接在容器里面找 Advisor 类型</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="comment">// 过滤一下，找到匹配的 Advisor</span></span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">    <span class="comment">// 给子类扩展扩展一下匹配的集合</span></span><br><span class="line">    extendAdvisors(eligibleAdvisors);</span><br><span class="line">    <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看看  <code>AnnotationAwareAspectJAutoProxyCreator.findCandidateAdvisors</code> 方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Add all the Spring advisors found according to superclass rules.</span></span><br><span class="line">    <span class="comment">// 这里直接在容器里面找 Advisor 的实现</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line">    <span class="comment">// Build Advisors for all AspectJ aspects in the bean factory.</span></span><br><span class="line">    <span class="comment">// 不出意外，上面是空（spring boot 注解情况下）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorsBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里是看 @Aspect 注解的 bean</span></span><br><span class="line">        advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">buildAspectJAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line">            <span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">                List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                aspectNames = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                <span class="comment">// 遍历所有 beanNames</span></span><br><span class="line">                String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">                        <span class="keyword">this</span>.beanFactory, Object<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">                <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!isEligibleBean(beanName)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// We must be careful not to instantiate beans eagerly as in this case they</span></span><br><span class="line">                    <span class="comment">// would be cached by the Spring container but would not have been weaved.</span></span><br><span class="line">                    Class&lt;?&gt; beanType = <span class="keyword">this</span>.beanFactory.getType(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 看是否有 @Aspect 注解，或者有字段是 aspect 类型,通常是 @Aspect，第二个条件无视</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">                        aspectNames.add(beanName);</span><br><span class="line">                        AspectMetadata amd = <span class="keyword">new</span> AspectMetadata(beanType, beanName);</span><br><span class="line">                        <span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">                            <span class="comment">// 一般是这里</span></span><br><span class="line">                            MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">                                    <span class="keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">                            <span class="comment">// 找到 advisor。。。，这里，看怎么从 Aspect 里面获取 Advisor</span></span><br><span class="line">                            List&lt;Advisor&gt; classAdvisors = <span class="keyword">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line">                            <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                                <span class="keyword">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">                            &#125;</span><br><span class="line">                            advisors.addAll(classAdvisors);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// Per target or per this.</span></span><br><span class="line">                            <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Bean with name '"</span> + beanName +</span><br><span class="line">                                        <span class="string">"' is a singleton, but aspect instantiation model is not singleton"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">                                    <span class="keyword">new</span> PrototypeAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">                            <span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">                            advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.aspectBeanNames = aspectNames;</span><br><span class="line">                <span class="keyword">return</span> advisors;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aspectNames.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String aspectName : aspectNames) &#123;</span><br><span class="line">        List&lt;Advisor&gt; cachedAdvisors = <span class="keyword">this</span>.advisorsCache.get(aspectName);</span><br><span class="line">        <span class="keyword">if</span> (cachedAdvisors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            advisors.addAll(cachedAdvisors);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            MetadataAwareAspectInstanceFactory factory = <span class="keyword">this</span>.aspectFactoryCache.get(aspectName);</span><br><span class="line">            advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">getAdvisors</span><span class="params">(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">    String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();</span><br><span class="line">    validate(aspectClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need to wrap the MetadataAwareAspectInstanceFactory with a decorator</span></span><br><span class="line">    <span class="comment">// so that it will only instantiate once.</span></span><br><span class="line">    MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =</span><br><span class="line">            <span class="keyword">new</span> LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);</span><br><span class="line"></span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 这里的方法 getAdvisorMethods 是找除了 @Pointcut 注解标记外的所有方法</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;</span><br><span class="line">        <span class="comment">// 只要不是切入点，其他方法都可能是 Advice ，使用 这个method 构建 通知器 Advisor</span></span><br><span class="line">        Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);</span><br><span class="line">        <span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            advisors.add(advisor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If it's a per target aspect, emit the dummy instantiating aspect.</span></span><br><span class="line">    <span class="keyword">if</span> (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line">        Advisor instantiationAdvisor = <span class="keyword">new</span> SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);</span><br><span class="line">        advisors.add(<span class="number">0</span>, instantiationAdvisor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find introduction fields.</span></span><br><span class="line">    <span class="comment">// 字段有 @DeclareParents 注解</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;</span><br><span class="line">        Advisor advisor = getDeclareParentsAdvisor(field);</span><br><span class="line">        <span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            advisors.add(advisor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Advisor <span class="title">getAdvisor</span><span class="params">(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> declarationOrderInAspect, String aspectName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line"></span><br><span class="line">    AspectJExpressionPointcut expressionPointcut = getPointcut(</span><br><span class="line">            candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line">    <span class="keyword">if</span> (expressionPointcut == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 都是 InstantiationModelAwarePointcutAdvisorImpl 实例了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,</span><br><span class="line">            <span class="keyword">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 创建代理   </span><br><span class="line">创建代理的流程就是动态代理的过程，也就是网上 spring aop 原理讲的最多的 jdk 和 cglig 动态代理    </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, @Nullable String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理工厂，正常的创建代理的流程</span></span><br><span class="line">    ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isProxyTargetClass 就是用来判断使用 cglib 还是 jdk 的动态代理</span></span><br><span class="line">    <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">            proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Advisor 通知器数组</span></span><br><span class="line">    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">    <span class="comment">// 设置</span></span><br><span class="line">    proxyFactory.addAdvisors(advisors);</span><br><span class="line">    proxyFactory.setTargetSource(targetSource);</span><br><span class="line">    customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">    proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">    <span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">        proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建代理</span></span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">        activate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其中 aopProxyFactory 方法获取的是 DefaultAopProxyFactory</span></span><br><span class="line">    <span class="comment">// createAopProxy 其实就用来判断使用的是哪个代理</span></span><br><span class="line">    <span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">                    <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再看看创建代理方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Creating CGLIB proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; rootClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line">        Assert.state(rootClass != <span class="keyword">null</span>, <span class="string">"Target class must be available for creating a CGLIB proxy"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有实现接口，添加一下</span></span><br><span class="line">        Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line">        <span class="keyword">if</span> (ClassUtils.isCglibProxyClass(rootClass)) &#123;</span><br><span class="line">            proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">            Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line">                <span class="keyword">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">        validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cglib 过程了</span></span><br><span class="line">        <span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">        Enhancer enhancer = createEnhancer();</span><br><span class="line">        <span class="comment">// 类加载器</span></span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            enhancer.setClassLoader(classLoader);</span><br><span class="line">            <span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">                    ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">                enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要代理的对象</span></span><br><span class="line">        enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">        <span class="comment">// 要代理的接口</span></span><br><span class="line">        enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">        <span class="comment">// 生成的代理类名，使用自定义格式</span></span><br><span class="line">        enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">        <span class="comment">// 类加载器处理</span></span><br><span class="line">        enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回调，也就是拦截处理器</span></span><br><span class="line">        Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">        Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">            types[x] = callbacks[x].getClass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">        <span class="comment">// 回调过滤，会根据这个 filter 来选择使用哪个回调</span></span><br><span class="line">        enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(</span><br><span class="line">                <span class="keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">        enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line">        <span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Could not generate CGLIB subclass of "</span> + <span class="keyword">this</span>.advised.getTargetClass() +</span><br><span class="line">                <span class="string">": Common causes of this problem include using a final class or a non-visible class"</span>,</span><br><span class="line">                ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Unexpected AOP exception"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面重点是 callback 的设置，spring 里面的callback有如下几个<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些是对应callback 在数组里面的索引，将根据 ProxyCallbackFilter 的返回值来判断使用哪个</span></span><br><span class="line"><span class="comment">// Constants for CGLIB callback array indices</span></span><br><span class="line"><span class="comment">// aop 回调</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AOP_PROXY = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INVOKE_TARGET = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NO_OVERRIDE = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DISPATCH_TARGET = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DISPATCH_ADVISED = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INVOKE_EQUALS = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INVOKE_HASHCODE = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据这个方法的返回值，来判断使用哪个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (AopUtils.isFinalizeMethod(method)) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Found finalize() method - using NO_OVERRIDE"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_OVERRIDE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.isOpaque() &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">            method.getDeclaringClass().isAssignableFrom(Advised<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Method is declared on Advised interface: "</span> + method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DISPATCH_ADVISED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We must always proxy equals, to direct calls to this.</span></span><br><span class="line">    <span class="keyword">if</span> (AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Found 'equals' method: "</span> + method);</span><br><span class="line">        <span class="keyword">return</span> INVOKE_EQUALS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We must always calculate hashCode based on the proxy.</span></span><br><span class="line">    <span class="keyword">if</span> (AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Found 'hashCode' method: "</span> + method);</span><br><span class="line">        <span class="keyword">return</span> INVOKE_HASHCODE;</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt; targetClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line">    <span class="comment">// Proxy is not yet available, but that shouldn't matter.</span></span><br><span class="line">    List&lt;?&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">    <span class="keyword">boolean</span> haveAdvice = !chain.isEmpty();</span><br><span class="line">    <span class="keyword">boolean</span> exposeProxy = <span class="keyword">this</span>.advised.isExposeProxy();</span><br><span class="line">    <span class="keyword">boolean</span> isStatic = <span class="keyword">this</span>.advised.getTargetSource().isStatic();</span><br><span class="line">    <span class="keyword">boolean</span> isFrozen = <span class="keyword">this</span>.advised.isFrozen();</span><br><span class="line">    <span class="keyword">if</span> (haveAdvice || !isFrozen) &#123;</span><br><span class="line">        <span class="comment">// If exposing the proxy, then AOP_PROXY must be used.</span></span><br><span class="line">        <span class="keyword">if</span> (exposeProxy) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Must expose proxy on advised method: "</span> + method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> AOP_PROXY;</span><br><span class="line">        &#125;</span><br><span class="line">        String key = method.toString();</span><br><span class="line">        <span class="comment">// Check to see if we have fixed interceptor to serve this method.</span></span><br><span class="line">        <span class="comment">// Else use the AOP_PROXY.</span></span><br><span class="line">        <span class="keyword">if</span> (isStatic &amp;&amp; isFrozen &amp;&amp; <span class="keyword">this</span>.fixedInterceptorMap.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Method has advice and optimizations are enabled: "</span> + method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// We know that we are optimizing so we can use the FixedStaticChainInterceptors.</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="keyword">this</span>.fixedInterceptorMap.get(key);</span><br><span class="line">            <span class="keyword">return</span> (index + <span class="keyword">this</span>.fixedInterceptorOffset);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Unable to apply any optimizations to advised method: "</span> + method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> AOP_PROXY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// See if the return type of the method is outside the class hierarchy of the target type.</span></span><br><span class="line">        <span class="comment">// If so we know it never needs to have return type massage and can use a dispatcher.</span></span><br><span class="line">        <span class="comment">// If the proxy is being exposed, then must use the interceptor the correct one is already</span></span><br><span class="line">        <span class="comment">// configured. If the target is not static, then we cannot use a dispatcher because the</span></span><br><span class="line">        <span class="comment">// target needs to be explicitly released after the invocation.</span></span><br><span class="line">        <span class="keyword">if</span> (exposeProxy || !isStatic) &#123;</span><br><span class="line">            <span class="keyword">return</span> INVOKE_TARGET;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">        <span class="keyword">if</span> (targetClass != <span class="keyword">null</span> &amp;&amp; returnType.isAssignableFrom(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Method return type is assignable from target type and "</span> +</span><br><span class="line">                        <span class="string">"may therefore return 'this' - using INVOKE_TARGET: "</span> + method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> INVOKE_TARGET;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Method return type ensures 'this' cannot be returned - "</span> +</span><br><span class="line">                        <span class="string">"using DISPATCH_TARGET: "</span> + method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> DISPATCH_TARGET;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>里面重点的是 AOP 的那个回调<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAdvisedInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AdvisedSupport advised;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicAdvisedInterceptor</span><span class="params">(AdvisedSupport advised)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advised = advised;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">        Object target = <span class="keyword">null</span>;</span><br><span class="line">        TargetSource targetSource = <span class="keyword">this</span>.advised.getTargetSource();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这个默认是 false，不需要管</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">                <span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">                oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">                setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Get as late as possible to minimize the time we "own" the target, in case it comes from a pool...</span></span><br><span class="line">            target = targetSource.getTarget();</span><br><span class="line">            Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 看拦截链，一个方法可以触发多个通知</span></span><br><span class="line">            List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">            Object retVal;</span><br><span class="line">            <span class="comment">// Check whether we only have one InvokerInterceptor: that is,</span></span><br><span class="line">            <span class="comment">// no real advice, but just reflective invocation of the target.</span></span><br><span class="line">            <span class="comment">// 没有连接，直接调用</span></span><br><span class="line">            <span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">                <span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span></span><br><span class="line">                <span class="comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span></span><br><span class="line">                <span class="comment">// it does nothing but a reflective operation on the target, and no hot</span></span><br><span class="line">                <span class="comment">// swapping or fancy proxying.</span></span><br><span class="line">                Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">                retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 创建一个 方法调用链</span></span><br><span class="line">                <span class="comment">// We need to create a method invocation...</span></span><br><span class="line">                retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">            &#125;</span><br><span class="line">            retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">            <span class="keyword">return</span> retVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">                targetSource.releaseTarget(target);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">                <span class="comment">// Restore old proxy.</span></span><br><span class="line">                AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == other ||</span><br><span class="line">                (other <span class="keyword">instanceof</span> DynamicAdvisedInterceptor &amp;&amp;</span><br><span class="line">                        <span class="keyword">this</span>.advised.equals(((DynamicAdvisedInterceptor) other).advised)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * CGLIB uses this to drive proxy creation.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.advised.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面的代码是spring对 aop 的处理流程，现在在梳理一遍<br>aop 使用的原理是 动态代理，这句话没毛病，针对接口，使用 jdk 的动态代理，针对类，使用 cglib 的动态代理<br>代理对象的创建，是使用spring 的扩展接口，在bean 实例化过程中切入的<br>切入的过程是 找对有 @Aspect 注解的 bean，排除所有 @Pointcut 注解的方法，其他都可能通知点 Advice<br>使用这些通知点构建通知器 Advisor，通知器作用就是返回 Advice<br>然后根据条件，看该通知器是否跟对应的目标对象匹配，如果匹配，就可以创建代理了</p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>spring</tag>
        <tag>aop</tag>
      </tags>
  </entry>
  <entry>
    <title>spring分析-BeanPostProcessor分析</title>
    <url>/2019/09/19/spring%E5%88%86%E6%9E%90-BeanPostProcessor%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><code>BeanFactory</code> 相关的扩展接口<br></p>
<p>这里主要分析 spring 内部注册的 BeanPostProcessor，看看 spring 是怎么处理的<br>先贴上实例化的代码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="comment">// 这里再注释一遍，args 大部分时候为 null</span></span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// factoryBeanInstanceCache 的注释，如果 beanName 对应的不是 FactoryBean 忽略这里</span></span><br><span class="line">    <span class="comment">// Cache of unfinished FactoryBean instances: FactoryBean name --&gt; BeanWrapper</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不是 FactoryBean ，或者 FactoryBean 是已经完成创建的</span></span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里创建实例，就是构建一个对象出来，不过有 构造方法注入，所以需要处理，这个后面再看</span></span><br><span class="line">        <span class="comment">// 实例可以 factoryBean ，factoryMethod，构造方法</span></span><br><span class="line">        <span class="comment">// 创建过程老复杂了，后面可以详细看看</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里先获取一些基本信息，设置解析出来的类型</span></span><br><span class="line">    <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始要执行 BeanPostProcessor 了，先上锁</span></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="comment">// 判断是否处理过了</span></span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 处理 MergedBeanDefinitionPostProcessor （BeanPostProcessor 的子接口）的 postProcessMergedBeanDefinition 方法</span></span><br><span class="line">                <span class="comment">// 这里给个机会修改一下 BeanDefinition，但是 beanType 没法变了，实例已经创建好了，后面挺多设置一下 properties 或者依赖设置吧</span></span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 标记处理过类</span></span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是可以运行循环依赖的处理</span></span><br><span class="line">    <span class="comment">// 当 A 创建一半，发现需要先创建 B，然后去创建 B，然而 B 也依赖 A了，这个时候，虽然 A 还没创建完</span></span><br><span class="line">    <span class="comment">// 这里就允许这种情况，因为 A 的实例已经创建好了，只是一些属性还没设置完全，依赖只是有一个引用</span></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">                    <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加 对象工厂</span></span><br><span class="line">        <span class="comment">// 处理 SmartInstantiationAwareBeanPostProcessor 接口（getEarlyBeanReference 方法）</span></span><br><span class="line">        <span class="comment">// 当有循环依赖，需要获取早期引用的时候，会调用 getEarlyBeanReference 方法（SmartInstantiationAwareBeanPostProcessor 的方法）</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里依赖注入</span></span><br><span class="line">        <span class="comment">// 老复杂了</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 初始化方法，BeanPostProcessor 接口</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要提前暴露出去</span></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 不为 null，才处理，因为不为 null，代表还没有其他对象引用</span></span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里是代表，经过 BeanPostProcessor 的处理，bean 的引用地址没有改变</span></span><br><span class="line">            <span class="comment">// 也就是说，如果 BeanPostProcessor 没有处理，或者处理的时候 new 新对象，是直接用之前的 bean = new ，而不是直接返回 new，那引用就没有变化</span></span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下面检查是否有依赖了旧版本的 bean</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                            <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                            <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">                            <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">                            <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">                            <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 disposable bean，这样，当 容器关闭之前，先调用这些bean 的 destroy方法</span></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>这个是 spring 框架扩展的核心接口，其他众所周知的各种 *Aware 接口，都是基于这个接口实现的<br>譬如 <code>ApplicationContextAwareProcessor</code> 类，就是处理 <code>EnvironmentAware</code>, <code>EmbeddedValueResolverAware</code>, <code>ResourceLoaderAware</code>, <code>ApplicationEventPublisherAware</code>, <code>MessageSourceAware</code>, <code>ApplicationContextAware</code> 接口的<br>PS: 不是所有 Aware 都是通过这个接口扩展的，还有一些譬如 BeanClassloaderAware 之类的，只在初始化过程中触发的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(<span class="keyword">final</span> Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    AccessControlContext acc = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (bean <span class="keyword">instanceof</span> EnvironmentAware || bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware ||</span><br><span class="line">                    bean <span class="keyword">instanceof</span> ResourceLoaderAware || bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware ||</span><br><span class="line">                    bean <span class="keyword">instanceof</span> MessageSourceAware || bean <span class="keyword">instanceof</span> ApplicationContextAware)) &#123;</span><br><span class="line">        acc = <span class="keyword">this</span>.applicationContext.getBeanFactory().getAccessControlContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (acc != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            invokeAwareInterfaces(bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, acc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        invokeAwareInterfaces(bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">            ((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">            ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">            ((ResourceLoaderAware) bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">            ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">            ((MessageSourceAware) bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">            ((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>BeanPostProcessor</code> 这个接口有两个方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个方法代表初始化之前</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法在初始化之后</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>什么是初始化前，什么是初始化后，我们再瞅一下 bean 的实例化代码实现<br>当一个 bean 创建完毕，依赖注入完毕后，才会开始 <code>BeanPostProcessor</code> 的处理，处理的方法是 <code>AbstractAutowireCapableBeanFactory.initializeBean</code> 方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这里依赖注入</span></span><br><span class="line">    <span class="comment">// 老复杂了</span></span><br><span class="line">    populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">    <span class="comment">// 初始化方法，BeanPostProcessor 接口</span></span><br><span class="line">    exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面至少发一下调用的地方</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发 Aware 接口</span></span><br><span class="line">    <span class="comment">// BeanNameAware  BeanClassLoaderAware  BeanFactoryAware</span></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// postProcessBeforeInitialization</span></span><br><span class="line">        <span class="comment">// 这里就是初始化之前 postProcessBeforeInitialization 方法调用</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用初始化方法 InitializingBean （afterPropertiesSet 方法） 注意，@PostConstruct 注解不在这里处理 </span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">                beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// postProcessAfterInitialization 处理</span></span><br><span class="line">        <span class="comment">// 这里就是初始化之后 postProcessAfterInitialization 方法调用</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通常这两个扩展方法，如果实现类不需要处理，原样返回就可以了，默认方法（jdk8 的接口默认方法）就是这样的</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        Object current = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        result = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        Object current = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        result = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面也可以看到 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用初始化方法 InitializingBean （afterPropertiesSet 方法）  自定义的初始化方法</span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br></pre></td></tr></table></figure>
<p>bean 的初始化方法，是在这两个扩展调用之间的</p>
<h2 id="MergedBeanDefinitionPostProcessor"><a href="#MergedBeanDefinitionPostProcessor" class="headerlink" title="MergedBeanDefinitionPostProcessor"></a>MergedBeanDefinitionPostProcessor</h2><p>这个接口是 <code>BeanPostProcessor</code> 的子接口，多了一个方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Post-process the given merged bean definition for the specified bean.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanDefinition the merged bean definition for the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanType the actual type of the managed bean instance</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>首先，什么是 <code>MergedBeanDefinition</code>? 因为 <code>BeanDefinition</code> 是可以继承的,因此，以 <code>BeanDefinition</code> 为模板构建实例的时候，首先要从父 <code>BeanDefinition</code> 拿到所有信息之后才开始构建<br>然后，这个方法的触发在什么时候呢？答案是在 <code>BeanPostProcessor</code> 的两个方法之前，在spring 创建好实例之后，没依赖注入（非构造注入）之前,允许修改 <code>BeanDefinition</code><br>我们看看发生的地方<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始要执行 BeanPostProcessor 了，先上锁</span></span><br><span class="line"><span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">    <span class="comment">// 判断是否处理过了</span></span><br><span class="line">    <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 处理 MergedBeanDefinitionPostProcessor （BeanPostProcessor 的子接口）的 postProcessMergedBeanDefinition 方法</span></span><br><span class="line">            <span class="comment">// 这里给个机会修改一下 BeanDefinition，但是 beanType 没法变了，实例已经创建好了，后面挺多设置一下 properties 或者依赖设置吧</span></span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标记处理过类</span></span><br><span class="line">        mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里，上面已经说明了，允许修改 <code>BeanDefinition</code><br>那么，一个具体的应用实例，就是 spring 自己的 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解的处理<br>在类 <code>InitDestroyAnnotationBeanPostProcessor</code> 中<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">    LifecycleMetadata metadata = findLifecycleMetadata(beanType);</span><br><span class="line">    metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkConfigMembers</span><span class="params">(RootBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">    Set&lt;LifecycleElement&gt; checkedInitMethods = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.initMethods.size());</span><br><span class="line">    <span class="keyword">for</span> (LifecycleElement element : <span class="keyword">this</span>.initMethods) &#123;</span><br><span class="line">        String methodIdentifier = element.getIdentifier();</span><br><span class="line">        <span class="keyword">if</span> (!beanDefinition.isExternallyManagedInitMethod(methodIdentifier)) &#123;</span><br><span class="line">            <span class="comment">// 这里注册 init</span></span><br><span class="line">            beanDefinition.registerExternallyManagedInitMethod(methodIdentifier);</span><br><span class="line">            checkedInitMethods.add(element);</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Registered init method on class ["</span> + <span class="keyword">this</span>.targetClass.getName() + <span class="string">"]: "</span> + element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;LifecycleElement&gt; checkedDestroyMethods = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.destroyMethods.size());</span><br><span class="line">    <span class="keyword">for</span> (LifecycleElement element : <span class="keyword">this</span>.destroyMethods) &#123;</span><br><span class="line">        String methodIdentifier = element.getIdentifier();</span><br><span class="line">        <span class="keyword">if</span> (!beanDefinition.isExternallyManagedDestroyMethod(methodIdentifier)) &#123;</span><br><span class="line">            <span class="comment">// 这里注册 destroy</span></span><br><span class="line">            beanDefinition.registerExternallyManagedDestroyMethod(methodIdentifier);</span><br><span class="line">            checkedDestroyMethods.add(element);</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Registered destroy method on class ["</span> + <span class="keyword">this</span>.targetClass.getName() + <span class="string">"]: "</span> + element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.checkedInitMethods = checkedInitMethods;</span><br><span class="line">    <span class="keyword">this</span>.checkedDestroyMethods = checkedDestroyMethods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>他在这里注册了一些 <code>@PostConstruct</code> 注解标记的初始化方法，那么是在什么时候调用的呢？答案是在 <code>postProcessBeforeInitialization</code> 这个方法里面<br>而我们之前说过了，这个扩展的调用是在 <code>InitializingBean</code> 接口 和 指定初始化方法（使用 <code>@Bean</code> 注解就可以指定）之前的。<br>因此，很显然，调用顺序是 1. <code>@PostConstruct</code> 2. <code>InitializingBean</code> 3. init-method   </p>
<h2 id="InstantiationAwareBeanPostProcessor"><a href="#InstantiationAwareBeanPostProcessor" class="headerlink" title="InstantiationAwareBeanPostProcessor"></a>InstantiationAwareBeanPostProcessor</h2><p>这个接口里面多了3个方法，实例化之前，实例化之后，处理 properties。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是这里的方法名 <code>Instantiation</code> 跟 <code>BeanPostFactory</code> 的方法名 <code>Initialization</code> 是不一样的<br>我们要注意到，在 <code>BeanPostFactory</code> 接口的两个方法中，参数都是一个 <code>Object</code> 对象，这说明，在调用这里的时候，对象已经是创建好的。<br>但是 <code>InstantiationAwareBeanPostProcessor</code> 的接口方法 before，参数只是 class，所以，大概就猜到这个接口是在 <code>BeanPostFactory</code> 之前触发了，去源码确认一下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 在生成实例之前，这里有一个机会，给对应 BeanPostProcessor 直接生成实例的地方，如果没人处理，就走 spring 下面的创建流程</span></span><br><span class="line">        <span class="comment">// 只有有实现 InstantiationAwareBeanPostProcessor （ BeanPostProcessor 的子接口），才进行处理</span></span><br><span class="line">        <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里就是 spring 默认的创建流程，如果一个类型的bean，没有被 BeanProcessor 提前处理，那就会到这里</span></span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">        <span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">        <span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbdToUse.getResourceDescription(), beanName, <span class="string">"Unexpected exception during bean creation"</span>, ex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，正常的流程是 <code>Object beanInstance = doCreateBean(beanName, mbdToUse, args);</code>  这一行<br>但是，如果 <code>InstantiationAwareBeanPostProcessor</code> 的一个实现，在方法 <code>postProcessBeforeInstantiation</code> 执行后，返回了一个非 null ，那么就不走后面的流程了<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    Object bean = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">        <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">        <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">            Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line">            <span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用的 InstantiationAwareBeanPostProcessor， 依次调用，谁处理了，就返回 bean 不处理的返回null</span></span><br><span class="line">                bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 创建后，如果要处理，就返回新的 bean，不处理就返回原来的bean，要是 返回了 null，那就忽略后面的 处理类了</span></span><br><span class="line">                    bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// bean 不为null，那就是处理过了</span></span><br><span class="line">        mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里只触发了 <code>BeanPostFactory</code> 的 <code>postProcessAfterInitialization</code> 方法<br><code>InstantiationAwareBeanPostProcessor</code> 的另外两个方法是在依赖注入的时候使用的</p>
<h2 id="DestructionAwareBeanPostProcessor"><a href="#DestructionAwareBeanPostProcessor" class="headerlink" title="DestructionAwareBeanPostProcessor"></a>DestructionAwareBeanPostProcessor</h2><p>这个接口也是 <code>BeanPostProcessor</code> 的子接口，有两个方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DestructionAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postProcessBeforeDestruction</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">requiresDestruction</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很明显，这两个方法是 bean 销毁时候的回调。<br>先说回调顺序，首先是 <code>@PreDestroy</code> 然后是 <code>DisposableBean</code> 最后是指定的 destroy-Method<br>为啥捏？<br>直接上销毁的代码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="keyword">this</span>.beanPostProcessors)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (DestructionAwareBeanPostProcessor processor : <span class="keyword">this</span>.beanPostProcessors) &#123;</span><br><span class="line">            processor.postProcessBeforeDestruction(<span class="keyword">this</span>.bean, <span class="keyword">this</span>.beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.invokeDisposableBean) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Invoking destroy() on bean with name '"</span> + <span class="keyword">this</span>.beanName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    ((DisposableBean) bean).destroy();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, acc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ((DisposableBean) bean).destroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            String msg = <span class="string">"Invocation of destroy method failed on bean with name '"</span> + <span class="keyword">this</span>.beanName + <span class="string">"'"</span>;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.warn(msg, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(msg + <span class="string">": "</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        invokeCustomDestroyMethod(<span class="keyword">this</span>.destroyMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethodName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Method methodToCall = determineDestroyMethod(<span class="keyword">this</span>.destroyMethodName);</span><br><span class="line">        <span class="keyword">if</span> (methodToCall != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invokeCustomDestroyMethod(methodToCall);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>很明显的一个顺序，至于销毁在哪里发生的，可以查看这个 destroy 在哪里调用的。。</p>
<h2 id="SmartInstantiationAwareBeanPostProcessor"><a href="#SmartInstantiationAwareBeanPostProcessor" class="headerlink" title="SmartInstantiationAwareBeanPostProcessor"></a>SmartInstantiationAwareBeanPostProcessor</h2><p>这个接口继承 <code>InstantiationAwareBeanPostProcessor</code>， 也有3个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">default</span> Class&lt;?&gt; predictBeanType(Class&lt;?&gt; beanClass, String beanName) <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法只用来选择构造方法用的</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">default</span> Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, String beanName)</span><br><span class="line">			<span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring分析-BeanFactoryPostProcessor分析</title>
    <url>/2019/09/18/spring%E5%88%86%E6%9E%90-BeanFactoryPostProcessor%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>这篇，看看sprnig内部注册的 BeanFactoryPostProcessor 做了些什么<br>主要是 BeanDefinition 的读取注册等<br>主要是 ConfigurationClassPostProcessor 这个类</p>
<h2 id="ConfigurationClassPostProcessor"><a href="#ConfigurationClassPostProcessor" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h2><p>这个类实现的接口是 BeanDefinitionRegistryPostProcessor 排序是 PriorityOrdered<br>因此，先调用的方法是 BeanDefinitionRegistryPostProcessor 接口的，然后是 BeanFactoryPostProcessor 接口的</p>
<h3 id="postProcessBeanDefinitionRegistry"><a href="#postProcessBeanDefinitionRegistry" class="headerlink" title="postProcessBeanDefinitionRegistry"></a>postProcessBeanDefinitionRegistry</h3><p>不做仔细分析，功能就是解析出所有 BeanDefinition，然后注册<br>下面一坨代码就是整个方法的调用过程<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> registryId = System.identityHashCode(registry);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"postProcessBeanDefinitionRegistry already called on this post-processor against "</span> + registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"postProcessBeanFactory already called on this post-processor against "</span> + registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line">    <span class="comment">// 处理 BeanDefinition</span></span><br><span class="line">    processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 从已有的 BeanDefinition 中，找到配置类，然后解析出更多 BeanDefinition</span></span><br><span class="line"><span class="comment">* Build and validate a configuration model based on the registry of</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> Configuration&#125; classes.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取所有 BeanDefinition，这里的 BeanDefinition 构建 Context 的时候注册的，或者 scan 扫描到的部分 BeanDefinition</span></span><br><span class="line">    String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">        BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line">        <span class="comment">// 被解析过了，会有特殊属性，完全配置 还是 部分配置</span></span><br><span class="line">        <span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||</span><br><span class="line">                ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Bean definition has already been processed as a configuration class: "</span> + beanDef);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 BeanDefinition 是配置类（可解析的） 2个条件或</span></span><br><span class="line">        <span class="comment">// 1. Configuration 注解 全配置</span></span><br><span class="line">        <span class="comment">// 2. Component  ComponentScan Import ImportResource 注解或者有带 Bean 注解带方法  部分配置对应上面的 full 和 lite，这里会在 BeanDefinition 上标记 full 和 lite 代表解析到了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">            configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return immediately if no @Configuration classes were found</span></span><br><span class="line">    <span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先排序，从属性里面获得排序字段进行排序</span></span><br><span class="line">    <span class="comment">// Sort by previously determined @Order value, if applicable</span></span><br><span class="line">    configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">        <span class="keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是设置 bean name 生成器，如果其他模块重新了，就用新的，否则用默认的，作为spring的使用者，通常不会覆盖这里的，只可能是spring自己的其他模块</span></span><br><span class="line">    <span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line">    SingletonBeanRegistry sbr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">        sbr = (SingletonBeanRegistry) registry;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line">            BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">            <span class="keyword">if</span> (generator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">                <span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 environment 为 null，就用标准环境</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析类</span></span><br><span class="line">    <span class="comment">// Parse each @Configuration class</span></span><br><span class="line">    ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line">            <span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line">            <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line">    Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 解析</span></span><br><span class="line">        parser.parse(candidates);</span><br><span class="line">        <span class="comment">// 校验</span></span><br><span class="line">        parser.validate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得解析出来的 configClass</span></span><br><span class="line">        Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">        <span class="comment">// 移除已经解析过的</span></span><br><span class="line">        configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line">                    registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line">                    <span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读取 BeanDefinition</span></span><br><span class="line">        <span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">        <span class="comment">// 标记为已经解析过类</span></span><br><span class="line">        alreadyParsed.addAll(configClasses);</span><br><span class="line">        <span class="comment">// 可以清空类</span></span><br><span class="line">        candidates.clear();</span><br><span class="line">        <span class="comment">// 这个判断，代表真解析出来 BeanDefinition 了</span></span><br><span class="line">        <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">            String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">            Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">            Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 主要是判断，解析出来的配置类，还有没有遗漏的配置类没有解析</span></span><br><span class="line">            <span class="comment">// 主要可能是从其他配置（xml）读取的</span></span><br><span class="line">            <span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">                    BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line">                    <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="keyword">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">                            !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">                        candidates.add(<span class="keyword">new</span> BeanDefinitionHolder(bd, candidateName));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            candidateNames = newCandidateNames;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 ImportRegistry</span></span><br><span class="line">    <span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line">    <span class="keyword">if</span> (sbr != <span class="keyword">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">        sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空缓存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">        <span class="comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span></span><br><span class="line">        <span class="comment">// for a shared cache since it'll be cleared by the ApplicationContext.</span></span><br><span class="line">        ((CachingMetadataReaderFactory) <span class="keyword">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.deferredImportSelectors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">        BeanDefinition bd = holder.getBeanDefinition();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 注解配置的走这里</span></span><br><span class="line">            <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 其他配置的（xml）走这里</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 扩展走这里</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                    <span class="string">"Failed to parse configuration class ["</span> + bd.getBeanClassName() + <span class="string">"]"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理延时导入的</span></span><br><span class="line">    processDeferredImportSelectors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(AnnotationMetadata metadata, String beanName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    processConfigurationClass(<span class="keyword">new</span> ConfigurationClass(metadata, beanName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 配置上有 @Condition 注解，那就判断条件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ConfigurationClass existingClass = <span class="keyword">this</span>.configurationClasses.get(configClass);</span><br><span class="line">    <span class="comment">// 如果已经解析过了</span></span><br><span class="line">    <span class="keyword">if</span> (existingClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// configClass 是被其他配置类通过 Import 导入进来的，就结束类</span></span><br><span class="line">        <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">                existingClass.mergeImportedBy(configClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则的话，就是重复配置类，取后一个</span></span><br><span class="line">            <span class="comment">// Explicit bean definition found, probably replacing an import.</span></span><br><span class="line">            <span class="comment">// Let's remove the old one and go with the new one.</span></span><br><span class="line">            <span class="keyword">this</span>.configurationClasses.remove(configClass);</span><br><span class="line">            <span class="keyword">this</span>.knownSuperclasses.values().removeIf(configClass::equals);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统一用 SourceClass 包装一层</span></span><br><span class="line">    <span class="comment">// Recursively process the configuration class and its superclass hierarchy.</span></span><br><span class="line">    SourceClass sourceClass = asSourceClass(configClass);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (sourceClass != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 搜集配置类</span></span><br><span class="line">    <span class="keyword">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先处理内部类</span></span><br><span class="line">    <span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">    processMemberClasses(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 @PropertySource PropertySources 注解</span></span><br><span class="line">    <span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">            sourceClass.getMetadata(), PropertySources<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">            <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">context</span>.<span class="title">annotation</span>.<span class="title">PropertySource</span>.<span class="title">class</span>)) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">            processPropertySource(propertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(<span class="string">"Ignoring @PropertySource annotation on ["</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">                    <span class="string">"]. Reason: Environment must implement ConfigurableEnvironment"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 ComponentScans ComponentScan 注解</span></span><br><span class="line">    <span class="comment">// Process any @ComponentScan annotations</span></span><br><span class="line">    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">            sourceClass.getMetadata(), ComponentScans<span class="class">.<span class="keyword">class</span>, <span class="title">ComponentScan</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 由注解，条件满足</span></span><br><span class="line">    <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">            !<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">            <span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">            <span class="comment">// 扫描包，解析出 BeanDefinition</span></span><br><span class="line">            <span class="comment">// 这里扫出来的 BeanDefinition 全部注册了</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">                    <span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">            <span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">                <span class="keyword">if</span> (bdCand == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    bdCand = holder.getBeanDefinition();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果其中有需要解析的配置类，就解析</span></span><br><span class="line">                <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                    parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 Import 注解</span></span><br><span class="line">    <span class="comment">// Process any @Import annotations</span></span><br><span class="line">    processImports(configClass, sourceClass, getImports(sourceClass), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 ImportResource 注解</span></span><br><span class="line">    <span class="comment">// Process any @ImportResource annotations</span></span><br><span class="line">    AnnotationAttributes importResource =</span><br><span class="line">            AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (importResource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String[] resources = importResource.getStringArray(<span class="string">"locations"</span>);</span><br><span class="line">        Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">"reader"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">            String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">            configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 @Bean 注解的方法</span></span><br><span class="line">    <span class="comment">// Process individual @Bean methods</span></span><br><span class="line">    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">    <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">        configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理本类实现的接口里面默认方法中带 @Bean 注解带方法</span></span><br><span class="line">    <span class="comment">// Process default methods on interfaces</span></span><br><span class="line">    processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有父类</span></span><br><span class="line">    <span class="comment">// Process superclass, if any</span></span><br><span class="line">    <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">        String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">        <span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; !superclass.startsWith(<span class="string">"java"</span>) &amp;&amp;</span><br><span class="line">                !<span class="keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">            <span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">            <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有父类，就处理完毕类</span></span><br><span class="line">    <span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h3><p>这里就是增强配置类，添加一个 ImportAwareBeanPostProcessor，这个类用来处理 ImportAware 接口实现<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> factoryId = System.identityHashCode(beanFactory);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"postProcessBeanFactory already called on this post-processor against "</span> + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.factoriesPostProcessed.add(factoryId);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.registriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">        <span class="comment">// BeanDefinitionRegistryPostProcessor hook apparently not supported...</span></span><br><span class="line">        <span class="comment">// Simply call processConfigurationClasses lazily at this point then.</span></span><br><span class="line">        processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用cglib 增强配置类</span></span><br><span class="line">    enhanceConfigurationClasses(beanFactory);</span><br><span class="line">    <span class="comment">//添加一个 BeanPostProcessor 处理类</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ImportAwareBeanPostProcessor(beanFactory));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enhanceConfigurationClasses</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">        BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">        <span class="comment">// 使用 @Configuration 注解标记的类</span></span><br><span class="line">        <span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(beanDef <span class="keyword">instanceof</span> AbstractBeanDefinition)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Cannot enhance @Configuration bean definition '"</span> +</span><br><span class="line">                        beanName + <span class="string">"' since it is not stored in an AbstractBeanDefinition subclass"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (logger.isWarnEnabled() &amp;&amp; beanFactory.containsSingleton(beanName)) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Cannot enhance @Configuration bean definition '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' since its singleton instance has been created too early. The typical cause "</span> +</span><br><span class="line">                        <span class="string">"is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor "</span> +</span><br><span class="line">                        <span class="string">"return type: Consider declaring such methods as 'static'."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configBeanDefs.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// nothing to enhance -&gt; return immediately</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ConfigurationClassEnhancer enhancer = <span class="keyword">new</span> ConfigurationClassEnhancer();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;</span><br><span class="line">        AbstractBeanDefinition beanDef = entry.getValue();</span><br><span class="line">        <span class="comment">// If a @Configuration class gets proxied, always proxy the target class</span></span><br><span class="line">        beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用增强的子类</span></span><br><span class="line">            <span class="comment">// 增强的效果激素实现 EnhancedConfiguration 接口，这个接口继承 BeanFactoryAware</span></span><br><span class="line">            <span class="comment">// Set enhanced subclass of the user-specified bean class</span></span><br><span class="line">            Class&lt;?&gt; configClass = beanDef.resolveBeanClass(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">            <span class="keyword">if</span> (configClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">                <span class="keyword">if</span> (configClass != enhancedClass) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(String.format(<span class="string">"Replacing bean definition '%s' existing class '%s' with "</span> +</span><br><span class="line">                                <span class="string">"enhanced class '%s'"</span>, entry.getKey(), configClass.getName(), enhancedClass.getName()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    beanDef.setBeanClass(enhancedClass);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot load configuration class: "</span> + beanDef.getBeanClassName(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目前来说，单纯的 spring 启动，内部只有这个 BeanFactoryPostProcessor 用来解析 BeanDefinition 用的</p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-ioc分析</title>
    <url>/2019/09/18/spring-ioc%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>先放一张图：<br><img src="/2019/09/18/spring-ioc%E5%88%86%E6%9E%90/spring-ioc.png" class="" title="This is an example image"></p>
<p>从 AnnotationConfigApplicationContext 分析</p>
<p>目前由于springboot 快速流行<br>而springboot是基于注解的，因此以 AnnotationConfigApplicationContext 为源头开始分析源码。<br>分析的是 spring-framework 里面的 ioc 相关的内容，主要集中在 core bean context 包里面<br>我们先看官方的hello world</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(Application<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  MessagePrinter printer = context.getBean(MessagePrinter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  printer.printMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AnnotationConfigApplicationContext 主要有两种构造方法，一种指定带注解的 class，一种指定要扫描的包名<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>();</span><br><span class="line">  scan(basePackages);</span><br><span class="line">  refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>();</span><br><span class="line">  register(annotatedClasses);</span><br><span class="line">  refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>直接指定配置类或者包是组合用法，可以使用无参数构造方法，然后使用 scan 或者 register 方法，最后自己手动 refresh，同样可以启动 spring 容器<br>refresh 是spring启动的核心方法，后面重点看这个。</p>
<h2 id="refresh-之前的准备工作"><a href="#refresh-之前的准备工作" class="headerlink" title="refresh 之前的准备工作"></a>refresh 之前的准备工作</h2><p>构造 AnnotatedBeanDefinitionReader 和 ClassPathBeanDefinitionScanner</p>
<p>现在先看 AnnotatedBeanDefinitionReader 这个构造，因为在构造里面会添加几个系统的 BeanPostProcessor 类</p>
<ol>
<li>ConfigurationClassPostProcessor</li>
<li>AutowiredAnnotationBeanPostProcessor</li>
<li>RequiredAnnotationBeanPostProcessor</li>
<li>CommonAnnotationBeanPostProcessor<br>如果 jsr250 在classpath 下面，就添加这个<br>什么是jsr250，就是注解 <code>javax.annotation.Resource</code> 在的jar包</li>
<li>PersistenceAnnotationBeanPostProcessor<br>没用 JPA 就没有这个类</li>
<li>EventListenerMethodProcessor</li>
<li>DefaultEventListenerFactory  </li>
</ol>
<p>ClassPathBeanDefinitionScanner 这个类只是正常初始化，然后就是 <code>register(annotatedClasses);</code> 注册，这个方法是将启动指定的配置类解析成 BeanDefinition 注入到容器中<br>这个 BeanDefinition 的解析在后面执行，这里只是简单的注入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line">  Assert.notEmpty(annotatedClasses, <span class="string">"At least one annotated class must be specified"</span>);</span><br><span class="line">  <span class="keyword">this</span>.reader.register(annotatedClasses);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Class&lt;?&gt; annotatedClass : annotatedClasses) &#123;</span><br><span class="line">    registerBean(annotatedClass);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;?&gt; annotatedClass)</span> </span>&#123;</span><br><span class="line">  doRegisterBean(annotatedClass, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(annotatedClass);</span><br><span class="line">  <span class="comment">// 一样，判断 Condition</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// null</span></span><br><span class="line">  abd.setInstanceSupplier(instanceSupplier);</span><br><span class="line">  <span class="comment">// 默认 scope</span></span><br><span class="line">  ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">  abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">  <span class="comment">// 生成 beanName</span></span><br><span class="line">  String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置一些值，lazyinit primary role primary 等</span></span><br><span class="line">  AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">  <span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Primary<span class="class">.<span class="keyword">class</span> </span>== qualifier) &#123;</span><br><span class="line">        abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (Lazy<span class="class">.<span class="keyword">class</span> </span>== qualifier) &#123;</span><br><span class="line">        abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (BeanDefinitionCustomizer customizer : definitionCustomizers) &#123;</span><br><span class="line">    customizer.customize(abd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">  definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">  <span class="comment">// 注册到容器</span></span><br><span class="line">  BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">  String beanName = definitionHolder.getBeanName();</span><br><span class="line">  registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">  String[] aliases = definitionHolder.getAliases();</span><br><span class="line">  <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">      registry.registerAlias(beanName, alias);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="refresh-方法"><a href="#refresh-方法" class="headerlink" title="refresh 方法"></a>refresh 方法</h2><p>这个是核心方法，完成 spring 的启动流程，在 AbstractApplicationContext 类中定义的模版启动<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    <span class="comment">// 设置启动时间，设置激活标记，初始化 properties sources </span></span><br><span class="line">    <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">    prepareRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 beanFactory 这个就是 ApplicationContext 内部用的类，一般是 DefaultListableBeanFactory 类型</span></span><br><span class="line">    <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备阶段，为 benaFactory 设置一些扩展的接口和忽略的接口</span></span><br><span class="line">    <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 空方法，子类可以做先事情，这里代表 BeanFactory 已经准备完毕了</span></span><br><span class="line">      <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">      postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 准备完毕后调用 BeanFactoryPostProcessor 实现类</span></span><br><span class="line">      <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">      registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">      initMessageSource();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">      initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">      onRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">      registerListeners();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">      finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">      finishRefresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">            <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">      destroyBeans();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">      cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">      <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">      resetCommonCaches();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>refresh 方法固定了启动要做的事情，启动前先上锁<br>接下来每个方法都看一下</p>
<h3 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh"></a>prepareRefresh</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 设置启动时间，设置激活标记，初始化 properties sources </span></span><br><span class="line"><span class="comment">  * Prepare this context for refreshing, setting its startup date and</span></span><br><span class="line"><span class="comment">  * active flag as well as performing any initialization of property sources.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">    logger.info(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里是一个空方法，留个子类扩展</span></span><br><span class="line">  <span class="comment">// Initialize any placeholder property sources in the context environment</span></span><br><span class="line">  initPropertySources();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查必须的参数是否存在</span></span><br><span class="line">  <span class="comment">// Validate that all properties marked as required are resolvable</span></span><br><span class="line">  <span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">  getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">  <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">  <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法做的事情很简单，就是初始化参数和参数检查</p>
<h3 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory();"></a>obtainFreshBeanFactory();</h3><p><code>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</code></p>
<p>获取 <code>BeanFactory</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 子类实现的，刷新 BeanFactory</span></span><br><span class="line">  refreshBeanFactory();</span><br><span class="line">  <span class="comment">// getBeanFactory 获取的是内部 BeanFactory 的实现，默认是 DefaultListableBeanFactory</span></span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// refreshBeanFactory 的两个实现，基于注解的 AnnotationConfigApplication 继承的是 GenericApplicationContext</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GenericApplicationContext 类中的实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">"GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.beanFactory.setSerializationId(getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractRefreshableApplicationContext 中的实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">    destroyBeans();</span><br><span class="line">    closeBeanFactory();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">    beanFactory.setSerializationId(getId());</span><br><span class="line">    customizeBeanFactory(beanFactory);</span><br><span class="line">    loadBeanDefinitions(beanFactory);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">      <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="prepareBeanFactory"><a href="#prepareBeanFactory" class="headerlink" title="prepareBeanFactory"></a>prepareBeanFactory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanFactory 准备阶段</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Tell the internal bean factory to use the context's class loader etc.</span></span><br><span class="line">  <span class="comment">// 设置类加载器</span></span><br><span class="line">  beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">  <span class="comment">//设置beanFactory的表达式语言处理器，Spring3增加了表达式语言的支持，  </span></span><br><span class="line">  <span class="comment">//默认可以使用#&#123;bean.xxx&#125;的形式来调用相关属性值 </span></span><br><span class="line">  beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">  <span class="comment">//为beanFactory增加了一个默认的propertyEditor，这个主要是对bean的属性等设置管理的一个工具  </span></span><br><span class="line">  beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">  <span class="comment">// 添加BeanPostProcessor, 这个是用来调用实现了 Aware 接口的bean 的方法</span></span><br><span class="line">  <span class="comment">// 从这里就可以看到 Aware 接口就是通过 BeaPostProcessor 接口扩展出来的</span></span><br><span class="line">  <span class="comment">// BeaPostProcessor 接口，可以在 Bean 实例化前后做一些增强，譬如动态代理等</span></span><br><span class="line">  <span class="comment">// 这个类处理的是 EnvironmentAware EmbeddedValueResolverAware ResourceLoaderAware ApplicationEventPublisherAware MessageSourceAware ApplicationContextAware 这些 Aware接口</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置了几个忽略自动装配的接口  </span></span><br><span class="line">  beanFactory.ignoreDependencyInterface(EnvironmentAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ResourceLoaderAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  beanFactory.ignoreDependencyInterface(MessageSourceAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ApplicationContextAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">  <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">  <span class="comment">// 设置了几个自动装配的特殊 规则  , 就是需要注入 一下接口的时候，注入的是给定的实例，不需要注册 BeanDefinition</span></span><br><span class="line">  beanFactory.registerResolvableDependency(BeanFactory<span class="class">.<span class="keyword">class</span>, <span class="title">beanFactory</span>)</span>;</span><br><span class="line">  beanFactory.registerResolvableDependency(ResourceLoader<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">  beanFactory.registerResolvableDependency(ApplicationEventPublisher<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">  beanFactory.registerResolvableDependency(ApplicationContext<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">  <span class="comment">// 设置 Bean 处理器，用来处理内部的 ApplicationListeners</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">  <span class="comment">// //增加对AspectJ的支持 </span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    <span class="comment">// 这里同样是 Aware 支持，LoadTimeWeaverAware</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register default environment beans.</span></span><br><span class="line">  <span class="comment">// 注册系统 Bean，注意一下 Bean 和 BeanDefinition 不一样 BeanDefinition 会解析成 Bean，但是也可以直接添加 Bean，正常情况下 Bean 比 BeanDefinition 多</span></span><br><span class="line">  <span class="comment">// 因为 BeanDefinition 里面可以解析出多个 Bean</span></span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过看一个 BeanPostProcessor 的实现，看他的作用<br>ApplicationContextAwareProcessor<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(<span class="keyword">final</span> Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  AccessControlContext acc = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">      (bean <span class="keyword">instanceof</span> EnvironmentAware || bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware ||</span><br><span class="line">          bean <span class="keyword">instanceof</span> ResourceLoaderAware || bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware ||</span><br><span class="line">          bean <span class="keyword">instanceof</span> MessageSourceAware || bean <span class="keyword">instanceof</span> ApplicationContextAware)) &#123;</span><br><span class="line">    acc = <span class="keyword">this</span>.applicationContext.getBeanFactory().getAccessControlContext();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (acc != <span class="keyword">null</span>) &#123;</span><br><span class="line">    AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">      invokeAwareInterfaces(bean);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;, acc);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    invokeAwareInterfaces(bean);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">      ((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">      ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">      ((ResourceLoaderAware) bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">      ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">      ((MessageSourceAware) bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">      ((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>看方法很简单，就是在 bean 实例化之前，如果 bean 实现了 Aware 接口，那就调用，带上需要的资源<br>至于 BeanPostProcessor 在哪里调用的，继续向下面看。</p>
<h3 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br></pre></td></tr></table></figure>
<p>这是一个空方法，留给子类实现，子类可以对 BeanFactory 做一些处理，添加一些Bean，BeanPostProcessor 添加忽略的接口等等<br>扩展这个接口一般也是spring其他模块的事情，作为spring的使用者，通常不关心这个方法</p>
<h3 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors"></a>invokeBeanFactoryPostProcessors</h3><p>这个实现挺长的，不过很重要，得分析一下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 功能就是调用 BeanFactoryPostProcessor 和 BeanDefinitionRegistryPostProcessor </span></span><br><span class="line">  <span class="comment">// BeanFactoryPostProcessor 接口跟 BeanPostProcessor 类似，不过是 BeanFactory 初始化好了后调用实现类</span></span><br><span class="line">  <span class="comment">// BeanDefinitionRegistryPostProcessor 接口参数跟上面不一样，是 BeanDefinitionRegistry 上面的是 BeanFactory</span></span><br><span class="line">  PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">  <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">  <span class="comment">// 这个BeanPostProcessor 在上面这个方法里面好像已经注册了</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">  Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是不是 BeanDefinitionRegistry 接口的实现</span></span><br><span class="line">  <span class="comment">// 内部的 beanFactory 的实例是 DefaultListableBeanFactory 实现了 BeanDefinitionRegistry</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">    BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历给定参数 beanFactoryPostProcessors ，这个是在 applicationContext 上面添加的，不是在容器里面的</span></span><br><span class="line">    <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">      <span class="comment">// BeanDefinitionRegistryPostProcessor 是 BeanFactoryPostProcessor 的子接口，传递的参数不一样，不过在内部，很可能是同一个实例，只是以不同的接口展示出去</span></span><br><span class="line">      <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">        BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">            (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">        <span class="comment">// 这里直接调用</span></span><br><span class="line">        registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">        registryProcessors.add(registryProcessor);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是 BeanFactoryPostProcessor 接口，那就先添加</span></span><br><span class="line">        regularPostProcessors.add(postProcessor);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">    <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">    <span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line">    <span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">    List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步，调用实现 BeanDefinitionRegistryPostProcessors 和 PriorityOrdered 接口的</span></span><br><span class="line">    <span class="comment">// PriorityOrdered 继承 Ordered 接口，里面没有方法，只是标记为 PriorityOrdered 类的优先级比 Ordered 高</span></span><br><span class="line">    <span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">    String[] postProcessorNames =</span><br><span class="line">        beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">      <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        processedBeans.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">    registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">    currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来，调用实现 BeanDefinitionRegistryPostProcessors 和 Ordered 接口的</span></span><br><span class="line">    <span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">    postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">      <span class="comment">// processedBeans 就是已经处理过的 Bean names</span></span><br><span class="line">      <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        processedBeans.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">    registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">    currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后，调用所有其他的实现（上面没调用到的）</span></span><br><span class="line">    <span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line">    <span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">      reiterate = <span class="keyword">false</span>;</span><br><span class="line">      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">      <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">          currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">          processedBeans.add(ppName);</span><br><span class="line">          reiterate = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">      registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">      currentRegistryProcessors.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后，调用 BeanFactoryPostProcessor 接口实现</span></span><br><span class="line">    <span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">    <span class="comment">// 这个是调用  BeanDefinitionRegistryPostProcessor 实现</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">    <span class="comment">// 这个是调用纯 BeanFactoryPostProcessor 实现</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 beanFactory 没有实现 BeanDefinitionRegistry 接口，就直接调用传递过来的参数</span></span><br><span class="line">    <span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面就是找 容器里面的 BeanFactoryPostProcessor 实现，进行调用，同样分三次，PriorityOrdered Ordered 和没有排序的</span></span><br><span class="line">  <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">  <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">  String[] postProcessorNames =</span><br><span class="line">      beanFactory.getBeanNamesForType(BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">  <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">  List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">      <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">      priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">      orderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">  sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">  invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">  List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">    orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">  invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">  List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">    nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">  <span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">  beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，总结一下 postProcessBeanFactory 做的事情，<br>就是调用 applicationContext 里面注册的和容器里面的 BeanFactoryPostProcessor（包括子接口 BeanDefinitionRegistryPostProcessor）<br>按照 PriorityOrdered Ordered 和 没有排序接口的顺序进行调用<br>到这里，其实 BeanDefinition 已经注册类，不过bean的没新建出来，建bean 需要调用 getBean</p>
<h3 id="registerBeanPostProcessors"><a href="#registerBeanPostProcessors" class="headerlink" title="registerBeanPostProcessors"></a>registerBeanPostProcessors</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line">  <span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line">  <span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line">  <span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">  <span class="comment">// 这里添加一个 BeanPostProcessor 的实现 BeanPostProcessorChecker</span></span><br><span class="line">  <span class="comment">// 注意，是在 BeanFactory 实现上面添加的，不是添加的bean</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">  <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      priorityOrderedPostProcessors.add(pp);</span><br><span class="line">      <span class="comment">// MergedBeanDefinitionPostProcessor 是 BeanPostProcessor 的子接口</span></span><br><span class="line">      <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">        internalPostProcessors.add(pp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">      orderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同样分3步，第一步注册 PriorityOrdered 接口的实现</span></span><br><span class="line">  <span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">  sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二部，注册 Ordered 的实现</span></span><br><span class="line">  <span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">    BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    orderedPostProcessors.add(pp);</span><br><span class="line">    <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">      internalPostProcessors.add(pp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第三步，注册没实现 Ordered 接口的实现</span></span><br><span class="line">  <span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">    BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    nonOrderedPostProcessors.add(pp);</span><br><span class="line">    <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">      internalPostProcessors.add(pp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后，注册 MergedBeanDefinitionPostProcessor 接口的实现</span></span><br><span class="line">  <span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line">  sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后，添加一个 ApplicationListenerDetector</span></span><br><span class="line">  <span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">  <span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意到的是，最后在 容器里面注册的 BeanPostProcessor 实现，都添加到 beanFactory 实例上了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ConfigurableListableBeanFactory beanFactory, List&lt;BeanPostProcessor&gt; postProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (BeanPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结，这个方法就是注册 BeanPostFactory，除了可以通过 beanFactory 注册外，容器里面的实现也会被添加</p>
<h3 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource"></a>initMessageSource</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">      HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="keyword">this</span>.messageSource;</span><br><span class="line">      <span class="keyword">if</span> (hms.getParentMessageSource() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line">        <span class="comment">// registered already.</span></span><br><span class="line">        hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Using MessageSource ["</span> + <span class="keyword">this</span>.messageSource + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line">    DelegatingMessageSource dms = <span class="keyword">new</span> DelegatingMessageSource();</span><br><span class="line">    dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">    <span class="keyword">this</span>.messageSource = dms;</span><br><span class="line">    beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="keyword">this</span>.messageSource);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Unable to locate MessageSource with name '"</span> + MESSAGE_SOURCE_BEAN_NAME +</span><br><span class="line">          <span class="string">"': using default ["</span> + <span class="keyword">this</span>.messageSource + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是初始化 MessageSource，添加到容器里面，如果是 HierarchicalMessageSource ，同时设置父节点<br>这个类的作用后面再看</p>
<hr>
<h3 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster"></a>initApplicationEventMulticaster</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">        beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Using ApplicationEventMulticaster ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">    beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Unable to locate ApplicationEventMulticaster with name '"</span> +</span><br><span class="line">          APPLICATION_EVENT_MULTICASTER_BEAN_NAME +</span><br><span class="line">          <span class="string">"': using default ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是初始化 ApplicationEventMulticaster，如果容器里面有，就赋值给本实例字段，如果没有，使用默认的 SimpleApplicationEventMulticaster，注册到容器里面<br>这个类的作用后面再看</p>
<h3 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh"></a>onRefresh</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">onRefresh();</span><br></pre></td></tr></table></figure>
<p>这个方法在本类里面是一个空方法，留给扩展用的</p>
<hr>
<h3 id="registerListeners"><a href="#registerListeners" class="headerlink" title="registerListeners"></a>registerListeners</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Add beans that implement ApplicationListener as listeners.</span></span><br><span class="line"><span class="comment">  * Doesn't affect other listeners, which can be added without being beans.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Register statically specified listeners first.</span></span><br><span class="line">  <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">    getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">  <span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">  String[] listenerBeanNames = getBeanNamesForType(ApplicationListener<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">  <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">    getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line">  Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line">  <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (earlyEventsToProcess != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">      getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加 ApplicationListener 实现（实例上的和容器里面的），发布 early 事件</p>
<hr>
<h3 id="finishBeanFactoryInitialization"><a href="#finishBeanFactoryInitialization" class="headerlink" title="finishBeanFactoryInitialization"></a>finishBeanFactoryInitialization</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Finish the initialization of this context's bean factory,</span></span><br><span class="line"><span class="comment">  * initializing all remaining singleton beans.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">  <span class="comment">// 初始化 conversion</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">      beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">    beanFactory.setConversionService(</span><br><span class="line">        beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册 valueResolver</span></span><br><span class="line">  <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">  <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">  <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">    beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有 LoadTimeWeaverAware （aspectj）就调用 getBean 触发实例化</span></span><br><span class="line">  <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">  String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">  <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">    getBean(weaverAwareName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 停止使用临时类加载器</span></span><br><span class="line">  <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">  beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存当前的 BeanDefinitionNames</span></span><br><span class="line">  <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">  beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化单例</span></span><br><span class="line">  <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">  beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的方法是 DefaultListableBeanFactory 的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freezeConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.configurationFrozen = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">this</span>.frozenBeanDefinitionNames = StringUtils.toStringArray(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.logger.debug(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">  <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">  List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="comment">// 获取 beanName 对应的 BeanDefinition</span></span><br><span class="line">    RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    <span class="comment">// 非抽象，单例，非延时加载</span></span><br><span class="line">    <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">      <span class="comment">// 如果是 FactoryBean</span></span><br><span class="line">      <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">        <span class="comment">// 初始化 FactoryBean 实例，用来判断下面是否需要先加载一个</span></span><br><span class="line">        Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">          <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">          <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">          <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">            isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                    ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                getAccessControlContext());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果需要及时加载，那就调用getBean</span></span><br><span class="line">          <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">            getBean(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 调用 getBean 进行初始化</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        getBean(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面如果实例是 SmartInitializingSingleton ，那就调用 afterSingletonsInstantiated 方法</span></span><br><span class="line">  <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    Object singletonInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">      <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">          smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是 getBean 的代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 转换一下name，功能是 如果以 &amp;开头，去掉这个符号，如果name是别名，找到最开始的name</span></span><br><span class="line">  <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">  Object bean;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先检查缓存</span></span><br><span class="line">  <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">  Object sharedInstance = getSingleton(beanName);</span><br><span class="line">  <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line">            <span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是原型创建中，错误</span></span><br><span class="line">    <span class="comment">// Fail if we're already creating this bean instance:</span></span><br><span class="line">    <span class="comment">// We're assumably within a circular reference.</span></span><br><span class="line">    <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 beanName 不在本 beanFactory 里面，而且还有 parent，那就交给parent去处理</span></span><br><span class="line">    <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">    BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">      <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">      String nameToLookup = originalBeanName(name);</span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">            nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">        <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">        <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不做类型检查，标记 beanName 为已经创建</span></span><br><span class="line">    <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">      markBeanAsCreated(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这里重新合并，并坚持 BeanDefinition 不能是抽象的</span></span><br><span class="line">      <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">      checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果有依赖，那就先加载依赖</span></span><br><span class="line">      <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">      String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">      <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">          <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 注册一下依赖关系，就是添加两个map映射</span></span><br><span class="line">          registerDependentBean(dep, beanName);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化依赖</span></span><br><span class="line">            getBean(dep);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">"'"</span> + beanName + <span class="string">"' depends on missing bean '"</span> + dep + <span class="string">"'"</span>, ex);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果是单例的</span></span><br><span class="line">      <span class="comment">// Create bean instance.</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        <span class="comment">// 创建逻辑在 createBean 里面</span></span><br><span class="line">        sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// createBean 方法，在创建前后会调用 BeanPostProcessor</span></span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">            <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">            <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">            destroySingleton(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 获取实例，正常bean 直接返回，如果是 factory 才需要特殊处理</span></span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 原型</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">        <span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">        Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          beforePrototypeCreation(beanName);</span><br><span class="line">          prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">          afterPrototypeCreation(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 非单例 非原型 那就是扩展的作用域了，跟原型差不多，有一个 beforePrototypeCreation 然后 createBean 然后 afterPrototypeCreation， 最后 getObjectForBeanInstance</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        String scopeName = mbd.getScope();</span><br><span class="line">        <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">        <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">            beforePrototypeCreation(beanName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">              afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">              <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line">              <span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">              ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果指定类类型类，进行类型检查和转换</span></span><br><span class="line">  <span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">  <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">      <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> convertedBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">            ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果创建失败，移除</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">cleanupAfterBeanCreationFailure</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.mergedBeanDefinitions) &#123;</span><br><span class="line">    <span class="keyword">this</span>.alreadyCreated.remove(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记 beanName 为创建中，删除 mergedBeanDefinition，重新合并</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">markBeanAsCreated</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.alreadyCreated.contains(beanName)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.mergedBeanDefinitions) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.alreadyCreated.contains(beanName)) &#123;</span><br><span class="line">        <span class="comment">// Let the bean definition get re-merged now that we're actually creating</span></span><br><span class="line">        <span class="comment">// the bean... just in case some of its metadata changed in the meantime.</span></span><br><span class="line">        clearMergedBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">this</span>.alreadyCreated.add(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">clearMergedBeanDefinition</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.mergedBeanDefinitions.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应 getSingleton</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getSinglegon</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先去缓存看看</span></span><br><span class="line">  Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">  <span class="comment">// 如果null，并且在创建</span></span><br><span class="line">  <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">      singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">        ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">          singletonObject = singletonFactory.getObject();</span><br><span class="line">          <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">          <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line">            <span class="string">"Singleton bean creation not allowed while singletons of this factory are in destruction "</span> +</span><br><span class="line">            <span class="string">"(Do not request a bean from a BeanFactory in a destroy method implementation!)"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Creating shared instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      beforeSingletonCreation(beanName);</span><br><span class="line">      <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">        <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        singletonObject = singletonFactory.getObject();</span><br><span class="line">        newSingleton = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">        <span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">        <span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">        singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">          <span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">            ex.addRelatedCause(suppressedException);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">          <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        afterSingletonCreation(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">        addSingleton(beanName, singletonObject);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingletonCurrentlyInCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.singletonsCurrentlyInCreation.contains(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getObjectForBeanInstance 第一个方法是子类的，第二个是父类的</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  String currentlyCreatedBean = <span class="keyword">this</span>.currentlyCreatedBean.get();</span><br><span class="line">  <span class="keyword">if</span> (currentlyCreatedBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">    registerDependentBean(beanName, currentlyCreatedBean);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.getObjectForBeanInstance(beanInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 name 是否有 FactoryBean 前缀</span></span><br><span class="line">  <span class="comment">// Don't let calling code try to dereference the factory if the bean isn't a factory.</span></span><br><span class="line">  <span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是 FactoryBean 那就直接返回</span></span><br><span class="line">  <span class="comment">// Now we have the bean instance, which may be a normal bean or a FactoryBean.</span></span><br><span class="line">  <span class="comment">// If it's a FactoryBean, we use it to create a bean instance, unless the</span></span><br><span class="line">  <span class="comment">// caller actually wants a reference to the factory.</span></span><br><span class="line">  <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">    <span class="keyword">return</span> beanInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Object object = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 如果 mdb（BeanDefinition） 为null，则从缓存的 FactoryBean Map 里面获取实例</span></span><br><span class="line">  <span class="keyword">if</span> (mbd == <span class="keyword">null</span>) &#123;</span><br><span class="line">    object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果缓存里面没有</span></span><br><span class="line">  <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Return bean instance from factory.</span></span><br><span class="line">    FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">    <span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">      mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">    object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="keyword">boolean</span> shouldPostProcess)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line">      Object object = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">      <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">        object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">        <span class="comment">// Only post-process and store if not put there already during getObject() call above</span></span><br><span class="line">        <span class="comment">// (e.g. because of circular reference processing triggered by custom getBean calls)</span></span><br><span class="line">        Object alreadyThere = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (alreadyThere != <span class="keyword">null</span>) &#123;</span><br><span class="line">          object = alreadyThere;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">              <span class="comment">// Temporarily return non-post-processed object, not storing it yet..</span></span><br><span class="line">              <span class="keyword">return</span> object;</span><br><span class="line">            &#125;</span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                  <span class="string">"Post-processing of FactoryBean's singleton object failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">              afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    Object object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">    <span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Post-processing of FactoryBean's object failed"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法就是初始化 bean，有点长</p>
<hr>
<h3 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh"></a>finishRefresh</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">finishRefresh();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清理缓存</span></span><br><span class="line">  <span class="comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line">  clearResourceCaches();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 LifecycleProcessor</span></span><br><span class="line">  <span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line">  initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//启动 LifeCycle 接口</span></span><br><span class="line">  <span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line">  getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布事件</span></span><br><span class="line">  <span class="comment">// Publish the final event.</span></span><br><span class="line">  publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册 MBean</span></span><br><span class="line">  <span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line">  LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearResourceCaches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.resourceCaches.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initLifecycleProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.lifecycleProcessor =</span><br><span class="line">        beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Using LifecycleProcessor ["</span> + <span class="keyword">this</span>.lifecycleProcessor + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    DefaultLifecycleProcessor defaultProcessor = <span class="keyword">new</span> DefaultLifecycleProcessor();</span><br><span class="line">    defaultProcessor.setBeanFactory(beanFactory);</span><br><span class="line">    <span class="keyword">this</span>.lifecycleProcessor = defaultProcessor;</span><br><span class="line">    beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, <span class="keyword">this</span>.lifecycleProcessor);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Unable to locate LifecycleProcessor with name '"</span> +</span><br><span class="line">          LIFECYCLE_PROCESSOR_BEAN_NAME +</span><br><span class="line">          <span class="string">"': using default ["</span> + <span class="keyword">this</span>.lifecycleProcessor + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结束启动，清理缓存，启动周期接口，发布事件</p>
<p>如果启动异常删除所有实例，然后取消启动</p>
<h2 id="最后清理所有缓存"><a href="#最后清理所有缓存" class="headerlink" title="最后清理所有缓存"></a>最后清理所有缓存</h2><h3 id="ConfigurationClassPostProcessor"><a href="#ConfigurationClassPostProcessor" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h3><p>看他实现的接口</p>
<ol>
<li>BeanDefinitionRegistryPostProcessor</li>
<li>PriorityOrdered</li>
<li>ResourceLoaderAware</li>
<li>BeanClassLoaderAware</li>
<li>EnvironmentAware</li>
</ol>
<p>第一个接口 BeanDefinitionRegistryPostProcessor 继承自 BeanFactoryPostProcessor<br>第二个接口 PriorityOrdered 继承自 Ordered，这是一个排序接口，用来标记配置类的加载顺序，值越小，优先级越高<br>后面3个 Aware 接口是获取 spring 内部内容的感知接口，就是一个set 方法，譬如 ResourceLoaderAware 就是一个 setResourceLoader 方法，参数 ResourceLoader，就是spring内部使用的，实现类可以获取这个实例，spring 中一些其他的 Aware 接口，功能是一样的</p>
<p>在 ConfigurationClassPostProcessor 实现里面，重要的是 BeanDefinitionRegistryPostProcessor 接口方法 postProcessBeanDefinitionRegistry 的实现，其他接口获取资源，都是为这个方法准备的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Derive further bean definitions from the configuration classes in the registry.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> registryId = System.identityHashCode(registry);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">"postProcessBeanDefinitionRegistry already called on this post-processor against "</span> + registry);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">"postProcessBeanFactory already called on this post-processor against "</span> + registry);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line"></span><br><span class="line">  processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Build and validate a configuration model based on the registry of</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> Configuration&#125; classes.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这个变量搜集将要处理的 BeanDefinition </span></span><br><span class="line">  List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拿到所有 BeanDefinition 的 name</span></span><br><span class="line">  String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">    BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line">    <span class="comment">// 如果 BeanDefinition 属性 configurationClass（前面加上 ConfigurationClassPostProcessor 的全名.）为 lite 或者 full，代表以及处理过了</span></span><br><span class="line">    <span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||</span><br><span class="line">        ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Bean definition has already been processed as a configuration class: "</span> + beanDef);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否为配置类，1. 有类注解 Configuration，标记为 full 2. 有类注解 Component，ComponentScan，Import，ImportResource 标记为 lite 3. 有 Bean 注解的方法</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">      configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return immediately if no @Configuration classes were found</span></span><br><span class="line">  <span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 配置处理排序，值越小优先级越高（先处理）</span></span><br><span class="line">  <span class="comment">// Sort by previously determined @Order value, if applicable</span></span><br><span class="line">  configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">    <span class="keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">    <span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line">  <span class="comment">// 这里可以修改 BeanNameGenerator 的实现, 系统内部用的，就是自己定义了，由于是延时注入的，首先注入的 BeanDefinition 是系统的和配置 Bean，到这里的时候自定义的 bean 还没开始处理</span></span><br><span class="line">  SingletonBeanRegistry sbr = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">    sbr = (SingletonBeanRegistry) registry;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line">      BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">      <span class="keyword">if</span> (generator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">        <span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 环境</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse each @Configuration class</span></span><br><span class="line">  ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line">      <span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line">      <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 待处理的配置类</span></span><br><span class="line">  Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line">  Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 这里就开始解析了</span></span><br><span class="line">    parser.parse(candidates);</span><br><span class="line">    parser.validate();</span><br><span class="line"></span><br><span class="line">    Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">    configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line">          registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line">          <span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">    alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">    candidates.clear();</span><br><span class="line">    <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">      String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">      Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">      Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">        alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">          BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line">          <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="keyword">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">              !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">            candidates.add(<span class="keyword">new</span> BeanDefinitionHolder(bd, candidateName));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      candidateNames = newCandidateNames;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line">  <span class="keyword">if</span> (sbr != <span class="keyword">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">    sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">    <span class="comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span></span><br><span class="line">    <span class="comment">// for a shared cache since it'll be cleared by the ApplicationContext.</span></span><br><span class="line">    ((CachingMetadataReaderFactory) <span class="keyword">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下 ConfigurationClassParser 的解析过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.deferredImportSelectors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历处理， AnnotatedBeanDefinition 代表是注解配置进来的， AbstractBeanDefinition 代表是 其他方式配置进来的，再else 就代表是扩展的了</span></span><br><span class="line">  <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">    BeanDefinition bd = holder.getBeanDefinition();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">        parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">        parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">          <span class="string">"Failed to parse configuration class ["</span> + bd.getBeanClassName() + <span class="string">"]"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  processDeferredImportSelectors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终解析的是 ConfigurationClass</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(@Nullable String className, String beanName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Assert.notNull(className, <span class="string">"No bean class name for configuration class bean definition"</span>);</span><br><span class="line">  MetadataReader reader = <span class="keyword">this</span>.metadataReaderFactory.getMetadataReader(className);</span><br><span class="line">  processConfigurationClass(<span class="keyword">new</span> ConfigurationClass(reader, beanName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Class&lt;?&gt; clazz, String beanName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  processConfigurationClass(<span class="keyword">new</span> ConfigurationClass(clazz, beanName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(AnnotationMetadata metadata, String beanName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  processConfigurationClass(<span class="keyword">new</span> ConfigurationClass(metadata, beanName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是具体的解析逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 看是不是有 Condition 条件，如果有判断条件</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果configClass 已经处理过了</span></span><br><span class="line">  ConfigurationClass existingClass = <span class="keyword">this</span>.configurationClasses.get(configClass);</span><br><span class="line">  <span class="keyword">if</span> (existingClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">        existingClass.mergeImportedBy(configClass);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 重复定义，后一个更新前一个</span></span><br><span class="line">      <span class="comment">// Explicit bean definition found, probably replacing an import.</span></span><br><span class="line">      <span class="comment">// Let's remove the old one and go with the new one.</span></span><br><span class="line">      <span class="keyword">this</span>.configurationClasses.remove(configClass);</span><br><span class="line">      <span class="keyword">this</span>.knownSuperclasses.values().removeIf(configClass::equals);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recursively process the configuration class and its superclass hierarchy.</span></span><br><span class="line">  SourceClass sourceClass = asSourceClass(configClass);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (sourceClass != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring分析-bean实例化流程</title>
    <url>/2019/09/17/spring%E5%88%86%E6%9E%90-bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>前面的分析，没有分析 bean 实例化的具体流程<br>这里具体分析一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始实例化 singletons 类型的 bean 了</span></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br></pre></td></tr></table></figure>
<p>这里的 beanFactory 是 DefaultListableBeanFactory 实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.debug(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到所有 BeanDefinition 的name 复制</span></span><br><span class="line">    <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">    <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历一遍，初始化所有非 lazy 的 单例</span></span><br><span class="line">    <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        <span class="comment">// 获得 BeanDefinition 定义，</span></span><br><span class="line">        <span class="comment">// getMergedLocalBeanDefinition 方法主要是处理 BeanDefinition 有继承其他 BeanDefinition 的情况，那就复制父 BeanDefinition 的信息，然后用本 BeanDefinition 覆盖</span></span><br><span class="line">        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="comment">// 非抽象，单例，非延时，才初始化</span></span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">            <span class="comment">// 如果是 FactoryBean</span></span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                <span class="comment">// 初始化 FactoryBean</span></span><br><span class="line">                Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">                    <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">                    <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                        isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                                        ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                                getAccessControlContext());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                                ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 判断 FactoryBean 是否需要及时初始化，如果需要，就初始化</span></span><br><span class="line">                    <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                        getBean(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不是 FactoryBean 正常初始化</span></span><br><span class="line">                getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">    <span class="comment">// 这里判断 bean 实例是否实现类 SmartInitializingSingleton ，如果实现类，就调用 afterSingletonsInstantiated 方法</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        <span class="comment">// 获取 单例</span></span><br><span class="line">        Object singletonInstance = getSingleton(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">            <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例化的实际方式是 getBean 方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 beanName</span></span><br><span class="line">    <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取给定 beanName 的单例对象</span></span><br><span class="line">    <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">    <span class="comment">// 这个方法获取步骤</span></span><br><span class="line">    <span class="comment">// 1. 从已经创建的map中获取 singletonObjects</span></span><br><span class="line">    <span class="comment">// 2. 没有获取到，从早期缓存获取 earlySingletonObjects</span></span><br><span class="line">    <span class="comment">// 3. 如果还没有获取到，则尝试获取该 bean 的对象工厂,后面如果需要支持循环依赖，会丢一个创建对象工厂</span></span><br><span class="line">    <span class="comment">// 4. 如果获取到工厂，就创建对象，丢到 earlySingletonObjects</span></span><br><span class="line">    <span class="comment">// 5. 没有对象工厂就返回 null</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// getObjectForBeanInstance 方法是处理 FactoryBean 的情况</span></span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// prototype 类型的bean在创建中，提前异常出去</span></span><br><span class="line">        <span class="comment">// Fail if we're already creating this bean instance:</span></span><br><span class="line">        <span class="comment">// We're assumably within a circular reference.</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 BeanDefinition 在不在本 factory 中，如果不在，就尝试从 parent getBean 完成初始化</span></span><br><span class="line">        <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">            String nameToLookup = originalBeanName(name);</span><br><span class="line">            <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">                        nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不做类型检查，标记 beanName 为已经创建，alreadyCreated。add</span></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 BeanDefinition，前面说过了，getMergedLocalBeanDefinition 方法是用来合并继承过来的 BeanDefinition</span></span><br><span class="line">            <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            <span class="comment">// 非抽象</span></span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里的 dependsOn 不是 bean 需要注入啥，而是使用 @DependsOn 注解标记的，代表需要提前初始化的</span></span><br><span class="line">            <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">                    <span class="comment">// 检查 beanName 是否依赖 dep，直接，间接依赖都算</span></span><br><span class="line">                    <span class="comment">// 这里是以 beanName 为key 获取，如果有 dep，那就是循环依赖了</span></span><br><span class="line">                    <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 这里注册依赖关系 key:dep  value:[...,beanName]</span></span><br><span class="line">                    <span class="comment">// 所以存的含义是 value 为 依赖 key 的 beanName 集合</span></span><br><span class="line">                    registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 先初始化依赖的 bean</span></span><br><span class="line">                        getBean(dep);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                <span class="string">"'"</span> + beanName + <span class="string">"' depends on missing bean '"</span> + dep + <span class="string">"'"</span>, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是 单例</span></span><br><span class="line">            <span class="comment">// Create bean instance.</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                <span class="comment">// 这里传类一个 lambda，是一个 ObjectFactory，对象创建逻辑就是 createBean 方法</span></span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 需要注意的是，通常来说，调用getBean 的时候很少传参数进来的，因此 args 大部分时候都是为null 的</span></span><br><span class="line">						<span class="comment">// spring 初始化的时候也是为 null 的</span></span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                        <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">                        <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">                        <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">                        destroySingleton(beanName);</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// getObjectForBeanInstance 方法是处理 FactoryBean 的情况</span></span><br><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 原型</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">                <span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">                Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforePrototypeCreation(beanName);</span><br><span class="line">                    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterPrototypeCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 其他作用域类型，扩展的 譬如 request session</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                String scopeName = mbd.getScope();</span><br><span class="line">                <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">                <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">                        beforePrototypeCreation(beanName);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">finally</span> &#123;</span><br><span class="line">                            afterPrototypeCreation(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                            <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line">                            <span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">                            ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查类型，如果需要，则进行类型转换</span></span><br><span class="line">    <span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">            <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> convertedBean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">                        ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们先只关心单例的创建。重要的方法有 getSingleton，getObjectForBeanInstance，createBean 方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先从已经生成好的对象里面获取</span></span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">// 如果没有，并且在创建中</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="comment">// 先上锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 从更早的缓存获取,早期缓存是为了处理循环依赖用的</span></span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">// 如果还没有，并且允许早期引用</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="comment">// 获取对象工厂</span></span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="comment">// 如果存在</span></span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 创建对象</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="comment">// 丢到早期缓存里面</span></span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="comment">// 移除对象工厂（单例），不再需要工厂创建了</span></span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看是不是 FactoryBean 的 beanName（&amp;开头的）</span></span><br><span class="line">    <span class="comment">// Don't let calling code try to dereference the factory if the bean isn't a factory.</span></span><br><span class="line">    <span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">            <span class="keyword">return</span> beanInstance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是，直接返回</span></span><br><span class="line">    <span class="comment">// Now we have the bean instance, which may be a normal bean or a FactoryBean.</span></span><br><span class="line">    <span class="comment">// If it's a FactoryBean, we use it to create a bean instance, unless the</span></span><br><span class="line">    <span class="comment">// caller actually wants a reference to the factory.</span></span><br><span class="line">    <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object object = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 先从缓存里面获取</span></span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span>) &#123;</span><br><span class="line">        object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有，就根据 FactoryBean 的方法创建</span></span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Return bean instance from factory.</span></span><br><span class="line">        FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">        <span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">        <span class="comment">// 老复杂的方法了，后面细看</span></span><br><span class="line">        object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line">    <span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line">    <span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line">    <span class="comment">// 获取 beanClass</span></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是从 beanClassName 解析出来的 class，重新生成 BeanDefinition</span></span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare method overrides.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查 overrides</span></span><br><span class="line">        <span class="comment">// 不太清楚是干啥的</span></span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">                beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 在生成实例之前，这里有一个机会，给对应 BeanPostProcessor 直接生成实例的地方，如果没人处理，就走 spring 下面的创建流程</span></span><br><span class="line">        <span class="comment">// 只有有实现 InstantiationAwareBeanPostProcessor （ BeanPostProcessor 的子接口），才进行处理</span></span><br><span class="line">        <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里就是 spring 默认的创建流程，如果一个类型的bean，没有被 BeanProcessor 提前处理，那就会到这里</span></span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">        <span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">        <span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbdToUse.getResourceDescription(), beanName, <span class="string">"Unexpected exception during bean creation"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面中，重要的方法是 doCreateBean，这个方法是创建的正常流程<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="comment">// 这里再注释一遍，args 大部分时候为 null</span></span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// factoryBeanInstanceCache 的注释，如果 beanName 对应的不是 FactoryBean 忽略这里</span></span><br><span class="line">    <span class="comment">// Cache of unfinished FactoryBean instances: FactoryBean name --&gt; BeanWrapper</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不是 FactoryBean ，或者 FactoryBean 是已经完成创建的</span></span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里创建实例，就是构建一个对象出来，不过有 构造方法注入，所以需要处理，这个后面再看</span></span><br><span class="line">        <span class="comment">// 实例可以 factoryBean ，factoryMethod，构造方法</span></span><br><span class="line">        <span class="comment">// 创建过程老复杂了，后面可以详细看看</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里先获取一些基本信息，设置解析出来的类型</span></span><br><span class="line">    <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始要执行 BeanPostProcessor 了，先上锁</span></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="comment">// 判断是否处理过了</span></span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 处理 MergedBeanDefinitionPostProcessor （BeanPostProcessor 的子接口）的 postProcessMergedBeanDefinition 方法</span></span><br><span class="line">                <span class="comment">// 这里给个机会修改一下 BeanDefinition，但是 beanType 没法变了，实例已经创建好了，后面挺多设置一下 properties 或者依赖设置吧</span></span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 标记处理过类</span></span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是可以运行循环依赖的处理</span></span><br><span class="line">    <span class="comment">// 当 A 创建一半，发现需要先创建 B，然后去创建 B，然而 B 也依赖 A了，这个时候，虽然 A 还没创建完</span></span><br><span class="line">    <span class="comment">// 这里就允许这种情况，因为 A 的实例已经创建好了，只是一些属性还没设置完全，依赖只是有一个引用</span></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">                    <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加 对象工厂</span></span><br><span class="line">        <span class="comment">// 处理 SmartInstantiationAwareBeanPostProcessor 接口（getEarlyBeanReference 方法）</span></span><br><span class="line">        <span class="comment">// 当有循环依赖，需要获取早期引用的时候，会调用 getEarlyBeanReference 方法（SmartInstantiationAwareBeanPostProcessor 的方法）</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里依赖注入</span></span><br><span class="line">        <span class="comment">// 老复杂了</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 初始化方法，BeanPostProcessor 接口</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要提前暴露出去</span></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 不为 null，才处理，因为不为 null，代表还没有其他对象引用</span></span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里是代表，经过 BeanPostProcessor 的处理，bean 的引用地址没有改变</span></span><br><span class="line">            <span class="comment">// 也就是说，如果 BeanPostProcessor 没有处理，或者处理的时候 new 新对象，是直接用之前的 bean = new ，而不是直接返回 new，那引用就没有变化</span></span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下面检查是否有依赖了旧版本的 bean</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                            <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                            <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">                            <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">                            <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">                            <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 disposable bean，这样，当 容器关闭之前，先调用这些bean 的 destroy方法</span></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>里面有两个老复杂的方法，后面先不看了</p>
<ol>
<li>createBeanInstance 这个方法，如果是构造方法创建，那么会有构造注入</li>
<li>populateBean 这个方法处理依赖注入</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">    <span class="comment">// 确保 class 已经解析了</span></span><br><span class="line">    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象提供接口</span></span><br><span class="line">    Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">    <span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// factory method 方法获取对象</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>)  &#123;</span><br><span class="line">        <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line">    <span class="comment">// 判断一下是否处理过了，就是解析出来要用的 构造方法和参数没</span></span><br><span class="line">    <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                resolved = <span class="keyword">true</span>;</span><br><span class="line">                autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后面就是用解析出来的使用的构造方法 或者默认构造方法构建实例了</span></span><br><span class="line">    <span class="comment">// 解析出来的构造方法，需要注入</span></span><br><span class="line">    <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">        <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">            <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Need to determine the constructor...</span></span><br><span class="line">    <span class="comment">// 解析要用的构造方法</span></span><br><span class="line">    <span class="comment">// 解析是用 BeanPostProcessor 接口的子接口 SmartInstantiationAwareBeanPostProcessor 的来扩展的</span></span><br><span class="line">    <span class="comment">// 注入相关的是 AutowiredAnnotationBeanPostProcessor 处理</span></span><br><span class="line">    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">        <span class="comment">// 构造方法依赖注入</span></span><br><span class="line">        <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不需要特殊处理，使用默认的构造方法</span></span><br><span class="line">    <span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line">    <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 里面老复杂，流程就是找构造方法，选择使用的构造方法，根据构造方法的参数，选择注入，看是 value 还是 需要注入 bean，如果需要注入bean 那就getBean 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">autowireConstructor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String beanName, RootBeanDefinition mbd, @Nullable Constructor&lt;?&gt;[] ctors, @Nullable Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConstructorResolver(<span class="keyword">this</span>).autowireConstructor(beanName, mbd, ctors, explicitArgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是根据 name 和 type 注入的地方，就不细看了</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line">    <span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line">    <span class="comment">// to support styles of field injection.</span></span><br><span class="line">    <span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">                    continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">        MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">            <span class="comment">// 根据 beanName 注入</span></span><br><span class="line">            autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">            <span class="comment">// 类型注入</span></span><br><span class="line">            autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pvs = newPvs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">    <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pvs = mbd.getPropertyValues();</span><br><span class="line">        &#125;</span><br><span class="line">        PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">        <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">            <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                    pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">                    <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">            checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring分析-启动大致流程</title>
    <url>/2019/09/17/spring%E5%88%86%E6%9E%90-%E5%90%AF%E5%8A%A8%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>从spring 的启动开始，启动始终绕不开 refresh 方法，这个是spring的核心方法，用来启动spring<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* spring 启动的核心方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalStateException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        <span class="comment">// 准备启动阶段，记录启动时间，准备 properties 和 验证</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 beanFactory  通常是 DefaultListableBeanFactory 实例，在 注解配置 和 xml 配置中的实现稍微有些不同</span></span><br><span class="line">        <span class="comment">// 不同总的来说就是获取一个 DefaultListableBeanFactory</span></span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备阶段，就是对 beanFactory 进行一些配置</span></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 准备完毕后的一个方法，子类可以对 beanFactory 继续做一些修改，本类中是一个空方法</span></span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这是一个重要的地方，对应接口为 BeanFactoryPostProcessor 以及子接口 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">            <span class="comment">// BeanFactoryPostProcessor 接口是可以针对 beanFactory 做一些修改，譬如添加一些 bean 之类的</span></span><br><span class="line">            <span class="comment">// BeanDefinitionRegistryPostProcessor 接口只是方法参数为 BeanDefinitionRegistry，可以再添加一些 BeanDefinition</span></span><br><span class="line">            <span class="comment">// 这个接口是一个重要的扩展接口，spring 内部 或者外部都可以通过这个接口的实现来扩展</span></span><br><span class="line">            <span class="comment">// 可以通过 ApplicationContext 的 addBeanFactoryPostProcessor 方法添加，或者注册 Bean，spring 就可以感知到，进行触发</span></span><br><span class="line">            <span class="comment">// 发生顺序很重要，先调用通过 beanFactory.add 添加的，然后调用 BeanDefinition 容器里面的</span></span><br><span class="line">            <span class="comment">// spring 内部的第一个调用的容器中的定义就是 ConfigurationClassPostProcessor，这个用了根据 配置类来找各个地方的 BeanDefinition ，注册到 容器中</span></span><br><span class="line">            <span class="comment">// 无论xml配置还是注解配置，通常有一个入口配置（springboot 中通常就是 Application），然后根据这个配置类，找到其他的配置类，根据所有配置类（找到一个解析一个）找到定义的 bean</span></span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 经过上一步调用后，所有的 BeanDefinition 都已经找到并且注册到容器中类</span></span><br><span class="line">            <span class="comment">// 这一步就是找到容器中实现 BeanPostProcessor 的 BeanDefinition，然后添加到 beanFactory 中</span></span><br><span class="line">            <span class="comment">// BeanPostProcessor 这个也是一个非常重要的扩展接口，譬如spring内部各种 Aware 接口，就是有 这个接口的实现类扩展出来的</span></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化 MessageSource 接口，如果没有，就使用默认的，注册到容器里面</span></span><br><span class="line">            <span class="comment">// 这里需要说明一下，spring 内部有两个容器，一个是 bean 容器的，一个是 BeanDefinition 容器的，实例是根据 BeanDefinition 的定义生成的</span></span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化 ApplicationEventMulticaster 接口，如果没有，就使用默认的，注册到容器里面</span></span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这是一个空方法，子类可以实现，可以在 bean 容器里面添加一些东西</span></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里是注册 ApplicationListener ，一些是通过 beanFactory 注册的，一些是用户自定义的 Bean ，然后发布 early 事件</span></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这个方法里面将实例化所有非延时加载的单例 bean</span></span><br><span class="line">            <span class="comment">// 实例化就是调用 getBean 方法</span></span><br><span class="line">            <span class="comment">// 这里将触发 BeanPostProcessor </span></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里是最后一步，清空 resource缓存，注册生命周期处理bean，然后获取所有 周期接口的实现启动，发布启动事件，注册到 JMX</span></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                        <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果启动出现异常，就销毁所有已经创建的实例</span></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取消refresh</span></span><br><span class="line">            <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 最后一步，清空所有缓存</span></span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法固定住了 spring 的启动步骤，已经预留了扩展空方法（内部扩展用），和扩展接口（外部扩展用）<br>譬如不同环境下的 ApplicationContext 可以重写空方法来适应直接的环境（譬如web），spring的使用者，或者第三方框架集成到spirng，则可以通过扩展接口。<br>整个流程并不复杂，复杂的地方在可以通过扩展接口来修改内部的一些内容，spring 内部也是实现这些接口来进行扩展的 BeanFactoryPostProcessor BeanDefinitionRegistryPostProcessor 这两个接口在BeanFactory 准备好后进行修改，可以注册 bean 或者 BeanDefinition，譬如注解配置，主要找到主配置如果，就可以根据主配置上的信息寻找到各个地方的 BeanDefinition ，注册到 BeanFactory 中<br>BeanPostProcessor 接口，可以在 Bean 实例化前后进行调用，spring 内部扩展出来的各种 Aware 接口，就根据这个接口的实现扩展出来的</p>
<p>我们根据启动流程，来完整分析一下spirng的启动细节，先从注解配置开始看</p>
<h2 id="AnnotationConfigApplicationContext"><a href="#AnnotationConfigApplicationContext" class="headerlink" title="AnnotationConfigApplicationContext"></a>AnnotationConfigApplicationContext</h2><h3 id="refresh-之前"><a href="#refresh-之前" class="headerlink" title="refresh 之前"></a>refresh 之前</h3><p>使用注解配置启动，最简单的启动代码如下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">MessageService <span class="title">mockMessageService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanFactoryPostProcessor <span class="title">beanFactoryPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanFactoryPostProcessor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">" = = = = = = = = = = == = =  = "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(Application<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        MessagePrinter printer = context.getBean(MessagePrinter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        printer.printMessage();</span><br><span class="line">        System.out.println(<span class="string">"================= beanDefinition names ==========="</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"============= bean names ============="</span>);</span><br><span class="line">        Iterator&lt;String&gt; beanNamesIterator = ((AnnotationConfigApplicationContext) context).getBeanFactory().getBeanNamesIterator();</span><br><span class="line">        <span class="keyword">while</span> (beanNamesIterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(beanNamesIterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常指定一个或者多个配置类，或者指定要扫描的包,最后调用的构造方法为<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意，这个里面在 beanFactory 中添加类一些 BeanFactoryPostProcessor</span></span><br><span class="line">    <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定配置类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    register(annotatedClasses);</span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定包扫描</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    scan(basePackages);</span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在构造 reader 的时候回添加几个 BeanFactoryPostProcessor 的实现，这里就不贴调用过程，直接贴最后调用注册的地方<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">registerAnnotationConfigProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通常来说 ApplicationContext 内部的 beanFactory 是 DefaultListableBeanFactory 实现</span></span><br><span class="line">    DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">    <span class="keyword">if</span> (beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置依赖排序实现</span></span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置注入候选解析</span></span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">            beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> ContextAnnotationAutowireCandidateResolver());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面添加一些 BeanDefinition 到 registry</span></span><br><span class="line">    <span class="comment">// 注意，这里用的是 LinkedHashSet，是有顺序的</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 ConfigurationClassPostProcessor，这个类第一个添加，实现 BeanDefinitionRegistryPostProcessor，功能就是根据配置类，解析 BeanDefinition</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 AutowiredAnnotationBeanPostProcessor，功能后面分析</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 RequiredAnnotationBeanPostProcessor，功能后面分析</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(RequiredAnnotationBeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有 jsr250 jar在classpath下面的时候才添加 CommonAnnotationBeanPostProcessor，什么是 jsr250？就是 @Resource 注解标记定义 bean</span></span><br><span class="line">    <span class="comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果jpa在classpath下，添加 org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor</span></span><br><span class="line">    <span class="comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class="line">                    AnnotationConfigUtils<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()))</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Cannot load optional framework class: "</span> + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 EventListenerMethodProcessor</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  添加 DefaultEventListenerFactory</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面添加的 BeanFactoryPostProcessor 实现，后面再分析，这些实现很重要。</p>
<p>然后就是 register 和 scan 方法了<br>registry 就是注册 BeanDefinition<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,</span></span></span><br><span class="line"><span class="function"><span class="params">			@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义 BeanDefinition</span></span><br><span class="line">    AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(annotatedClass);</span><br><span class="line">    <span class="comment">// 判断是否要跳过，就是看有没有 @Conditional 注解，如果有，满足不满足条件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提示提供，生成对象的方法</span></span><br><span class="line">    abd.setInstanceSupplier(instanceSupplier);</span><br><span class="line">    <span class="comment">// 默认是 singletons</span></span><br><span class="line">    ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">    abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 bean name</span></span><br><span class="line">    String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一些基本信息，lazyInit，primary，dependsOn，role，description 等</span></span><br><span class="line">    AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记的注解</span></span><br><span class="line">    <span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Primary<span class="class">.<span class="keyword">class</span> </span>== qualifier) &#123;</span><br><span class="line">                abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Lazy<span class="class">.<span class="keyword">class</span> </span>== qualifier) &#123;</span><br><span class="line">                abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看有没有处理 BeanDefinition 的逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionCustomizer customizer : definitionCustomizers) &#123;</span><br><span class="line">        customizer.customize(abd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 Holder 包裹</span></span><br><span class="line">    BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">    <span class="comment">// 看是否需要 Scope 代理处理，如果需要，beanClass 就换成 ScopedProxyFactoryBean，装饰之前的 BeanDefinition</span></span><br><span class="line">    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">    <span class="comment">// 注册 BeanDefinition</span></span><br><span class="line">    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意到，这个只是注册参数的配置类，还没开始解析。</p>
<p>再来看看 scan 方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> beanCountAtScanStart = <span class="keyword">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line">    </span><br><span class="line">    doScan(basePackages);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里注册 BeanFactoryPostProcessor 跟 new reader 里面注册调用的是同一个方法</span></span><br><span class="line">    <span class="comment">// Register annotation config processors, if necessary.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">        <span class="comment">// 扫描包，或者 BeanDefinition</span></span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">            <span class="comment">// BeanDefinition 添加基本信息</span></span><br><span class="line">            ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">            candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">            String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果有重复定义，看看可不可以覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">                <span class="comment">// 是否需要 Scope 包裹</span></span><br><span class="line">                definitionHolder =</span><br><span class="line">                        AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">                beanDefinitions.add(definitionHolder);</span><br><span class="line">                <span class="comment">// 注册</span></span><br><span class="line">                registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面只有简单的注释，过于细节的没有贴代码，先要有一个 spring 启动的整体印象，后面再来填充细节<br>讲到这里，其实就是在讲 refresh 方法之前，做了什么<br>总结的说，就是先注册了一些 BeanDefinition，其中一些 BeanDefinition 是辅助启动的（BeanFactoryPostProcessor）<br>我们先把这个辅助实现单独列出来，后面单独分析</p>
<ol>
<li>ConfigurationClassPostProcessor</li>
<li>AutowiredAnnotationBeanPostProcessor 这是一个 BeanPostProcessor</li>
<li>RequiredAnnotationBeanPostProcessor 这是一个 BeanPostProcessor</li>
<li>CommonAnnotationBeanPostProcessor 可选 jsr250</li>
<li>PersistenceAnnotationBeanPostProcessor 可选 jpa</li>
<li>EventListenerMethodProcessor 这是一个 SmartInitializingSingleton</li>
</ol>
<h3 id="refresh-方法"><a href="#refresh-方法" class="headerlink" title="refresh 方法"></a>refresh 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* spring 启动的核心方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalStateException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        <span class="comment">// 准备启动阶段，记录启动时间，准备 properties 和 验证</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 beanFactory  通常是 DefaultListableBeanFactory 实例，在 注解配置 和 xml 配置中的实现稍微有些不同</span></span><br><span class="line">        <span class="comment">// 不同总的来说就是获取一个 DefaultListableBeanFactory</span></span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备阶段，就是对 beanFactory 进行一些配置</span></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 准备完毕后的一个方法，子类可以对 beanFactory 继续做一些修改，本类中是一个空方法</span></span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这是一个重要的地方，对应接口为 BeanFactoryPostProcessor 以及子接口 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">            <span class="comment">// BeanFactoryPostProcessor 接口是可以针对 beanFactory 做一些修改，譬如添加一些 bean 之类的</span></span><br><span class="line">            <span class="comment">// BeanDefinitionRegistryPostProcessor 接口只是方法参数为 BeanDefinitionRegistry，可以再添加一些 BeanDefinition</span></span><br><span class="line">            <span class="comment">// 这个接口是一个重要的扩展接口，spring 内部 或者外部都可以通过这个接口的实现来扩展</span></span><br><span class="line">            <span class="comment">// 可以通过 ApplicationContext 的 addBeanFactoryPostProcessor 方法添加，或者注册 Bean，spring 就可以感知到，进行触发</span></span><br><span class="line">            <span class="comment">// 发生顺序很重要，先调用通过 beanFactory.add 添加的，然后调用 BeanDefinition 容器里面的</span></span><br><span class="line">            <span class="comment">// spring 内部的第一个调用的容器中的定义就是 ConfigurationClassPostProcessor，这个用了根据 配置类来找各个地方的 BeanDefinition ，注册到 容器中</span></span><br><span class="line">            <span class="comment">// 无论xml配置还是注解配置，通常有一个入口配置（springboot 中通常就是 Application），然后根据这个配置类，找到其他的配置类，根据所有配置类（找到一个解析一个）找到定义的 bean</span></span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 经过上一步调用后，所有的 BeanDefinition 都已经找到并且注册到容器中类</span></span><br><span class="line">            <span class="comment">// 这一步就是找到容器中实现 BeanPostProcessor 的 BeanDefinition，然后添加到 beanFactory 中</span></span><br><span class="line">            <span class="comment">// BeanPostProcessor 这个也是一个非常重要的扩展接口，譬如spring内部各种 Aware 接口，就是有 这个接口的实现类扩展出来的</span></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化 MessageSource 接口，如果没有，就使用默认的，注册到容器里面</span></span><br><span class="line">            <span class="comment">// 这里需要说明一下，spring 内部有两个容器，一个是 bean 容器的，一个是 BeanDefinition 容器的，实例是根据 BeanDefinition 的定义生成的</span></span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化 ApplicationEventMulticaster 接口，如果没有，就使用默认的，注册到容器里面</span></span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这是一个空方法，子类可以实现，可以在 bean 容器里面添加一些东西</span></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里是注册 ApplicationListener ，一些是通过 beanFactory 注册的，一些是用户自定义的 Bean ，然后发布 early 事件</span></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这个方法里面将实例化所有非延时加载的单例 bean</span></span><br><span class="line">            <span class="comment">// 实例化就是调用 getBean 方法</span></span><br><span class="line">            <span class="comment">// 这里将触发 BeanPostProcessor </span></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里是最后一步，清空 resource缓存，注册生命周期处理bean，然后获取所有 周期接口的实现启动，发布启动事件，注册到 JMX</span></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                        <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果启动出现异常，就销毁所有已经创建的实例</span></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取消refresh</span></span><br><span class="line">            <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 最后一步，清空所有缓存</span></span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里吧 refresh 的代码再贴一遍，这里我们具体分析一下启动过程</p>
<h4 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh"></a>prepareRefresh</h4><p>准备阶段，主要是准备一些配置信息<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动时间</span></span><br><span class="line">    <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 设置开启状态</span></span><br><span class="line">    <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 properties 默认只有 systemProperties 和 environment ，子类可以实现添加，这里是空方法</span></span><br><span class="line">    <span class="comment">// Initialize any placeholder property sources in the context environment</span></span><br><span class="line">    initPropertySources();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验必须的属性是否存在</span></span><br><span class="line">    <span class="comment">// Validate that all properties marked as required are resolvable</span></span><br><span class="line">    <span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">    getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来收集 early 事件</span></span><br><span class="line">    <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">    <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">    <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory"></a>obtainFreshBeanFactory</h4><p>获取 beanFactory，就是new出来的 DefaultListableBeanFactory，在 注解ApplicationContext 和 xmlApplicationContext 中不一样,我们先只看注解的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 刷新，注解里面还是直接返回，xml里面销毁里面的 bean，重新构建的</span></span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="comment">// 获取刷新完的 beanFactory</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.beanFactory.setSerializationId(getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法里面也没什么内容，我们要知道 beanFactory 是一个 DefaultListableBeanFactory 对象就行了</p>
<h4 id="prepareBeanFactory"><a href="#prepareBeanFactory" class="headerlink" title="prepareBeanFactory"></a>prepareBeanFactory</h4><p>准备 BeanFactory<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Tell the internal bean factory to use the context's class loader etc.</span></span><br><span class="line">    <span class="comment">// 设置类加载器</span></span><br><span class="line">    beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">    <span class="comment">//设置beanFactory的表达式语言处理器，Spring3增加了表达式语言的支持，</span></span><br><span class="line">    <span class="comment">//默认可以使用#&#123;bean.xxx&#125;的形式来调用相关属性值</span></span><br><span class="line">    beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">    <span class="comment">//为beanFactory增加了一个默认的propertyEditor，这个主要是对bean的属性等设置管理的一个工具</span></span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">    <span class="comment">// 添加 BeanPostProcessor, 这个是用来调用实现了 Aware 接口的bean 的方法</span></span><br><span class="line">    <span class="comment">// 从这里就可以看到 Aware 接口就是通过 BeaPostProcessor 接口扩展出来的</span></span><br><span class="line">    <span class="comment">// BeaPostProcessor 接口，可以在 Bean 实例化前后做一些增强，譬如动态代理等</span></span><br><span class="line">    <span class="comment">// 这个类处理的是 EnvironmentAware EmbeddedValueResolverAware ResourceLoaderAware ApplicationEventPublisherAware MessageSourceAware ApplicationContextAware 这些 Aware接口</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里忽略的接口，就是 ApplicationContextAwareProcessor 里面处理的接口</span></span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ResourceLoaderAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(MessageSourceAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationContextAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">    <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">    <span class="comment">// 这里添加处理依赖时候的映射，也就是说，当有其他类依赖 key 类型（需要注入，跟 dependsOn 不一样）,注入的就是 value</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory<span class="class">.<span class="keyword">class</span>, <span class="title">beanFactory</span>)</span>;</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 BeanPostProcessor ，这个类 ApplicationListenerDetector 是用来找到 bean 里面实现了 ApplicationListener 接口的实例，</span></span><br><span class="line">    <span class="comment">// 添加到 beanFactory 的事件监听列表里面，用来接收事件的</span></span><br><span class="line">    <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里实际是是添加一个 Aware，LoadTimeWeaverAware，其中要set 的是 LOAD_TIME_WEAVER_BEAN_NAME 对应的bean</span></span><br><span class="line">    <span class="comment">// 如果容器中有这个bean，那么 LoadTimeWeaverAware 接口才处理</span></span><br><span class="line">    <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="comment">// 添加 BeanPostProcessor  </span></span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">        <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一些环境相关的 bean</span></span><br><span class="line">    <span class="comment">// environment， systemProperties，systemEnvironment</span></span><br><span class="line">    <span class="comment">// Register default environment beans.</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>准备节点，就是配置一下 BeanFactory</p>
<h4 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h4><p>这是一个空方法，子类可以重写，对已经准备好的 BeanFactory 再做一些修改,譬如web里面的扩展<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.servletContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ServletContextAwareProcessor(<span class="keyword">this</span>.servletContext));</span><br><span class="line">        beanFactory.ignoreDependencyInterface(ServletContextAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, <span class="keyword">this</span>.servletContext);</span><br><span class="line">    WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, <span class="keyword">this</span>.servletContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>代码贴出来只是说明这个方法使用的时机，这里的代码不做讲解</p>
<h4 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors"></a>invokeBeanFactoryPostProcessors</h4><p>这是一个重要的方法，调用 BeanFactoryProcessor 接口实现类，包括系统自己注册的，和用户自定义的。<br>肯定是有顺序的，因为这个时候，用户自定义的 Bean 有点还没读取，经过这个方法，调用了系统内部的实现后，所有的 BeanDefinition 将读取完毕<br>BeanFactoryProcessor 的系统实现后面一一再看，这里只看调用的逻辑<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体的调用在这里，getBeanFactoryPostProcessors() 获取的是 applicationContext 上面直接添加的 BeanFactoryProcessor</span></span><br><span class="line">    <span class="comment">// 记住，BeanFactoryPostProcessor 是在 ApplicationContext 上面添加的，因为 ApplicationContext 持有 BeanFactory，完成 BeanFactory 的启动</span></span><br><span class="line">    <span class="comment">// 而 BeanPostProcessor 是添加在 BeanFactory 上的，因为 bean 有 BeanFactory 直接管理</span></span><br><span class="line">    <span class="comment">// 如果是分步骤启动的（直接new之后，经过处理再调用refresh），可以在启动之前添加 BeanFactoryProcessor， 这个优先级是最高的</span></span><br><span class="line">    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line">    <span class="comment">// 这个已经在 prepare 里面处理过了</span></span><br><span class="line">    <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">    <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里记录已经调用的 BeanDefinitionRegistryPostProcessor 的 beanName</span></span><br><span class="line">    <span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">    Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先调用的是 BeanFactoryProcessor 的子接口 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">    <span class="comment">// BeanDefinitionRegistryPostProcessor 这个接口，代表 BeanDefinitionRegistry 准备好了，接下来可以注册 BeanDefinition 了和做一些修改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// beanFactory 是 DefaultListableBeanFactory ，是实现类 BeanDefinitionRegistry 接口的</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">        BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">        <span class="comment">// 收集 BeanFactoryProcessor</span></span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 收集处理过的 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先处理的是参数传过来的，也就是直接添加在 beanFactory 上的</span></span><br><span class="line">        <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">            <span class="comment">// 首先处理 BeanDefinitionRegistryPostProcessor 的实现</span></span><br><span class="line">            <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">                BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">                        (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">                <span class="comment">// 这里直接调用</span></span><br><span class="line">                registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">                <span class="comment">// 收集 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">                registryProcessors.add(registryProcessor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 收集 BeanFactoryProcessor</span></span><br><span class="line">                regularPostProcessors.add(postProcessor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">        <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">        <span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line">        <span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">        <span class="comment">// 这里收集将要执行的 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里第一个要处理的 BeanDefinitionRegistryPostProcessor 就是 ConfigurationClassPostProcessor</span></span><br><span class="line">        <span class="comment">// 系统内建的 实现 PriorityOrdered 接口优先级最高，然后 ConfigurationClassPostProcessor 会注册自定义的 BeanDefinitionRegistryPostProcessor BeanFactoryPostProcessor 到 BeanFactory</span></span><br><span class="line">        <span class="comment">// 然后，下面找 BeanDefinitionRegistryPostProcessor 实现的时候，自定义的就可以看到然后被调用了</span></span><br><span class="line">        <span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">        String[] postProcessorNames =</span><br><span class="line">                beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">        <span class="comment">// 先处理 BeanDefinitionRegistryPostProcessor 和 PriorityOrdered</span></span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="comment">// PriorityOrdered 先处理</span></span><br><span class="line">            <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        <span class="comment">// 调用</span></span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        <span class="comment">// 清空</span></span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再处理 BeanDefinitionRegistryPostProcessor 和 Ordered</span></span><br><span class="line">        <span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后处理 BeanDefinitionRegistryPostProcessor 不排序的</span></span><br><span class="line">        <span class="comment">// 为啥是 while，因为 BeanDefinitionRegistryPostProcessor 的作用就是注册 BeanDefinition 的，可能注册的 BeanDefinition 有包含了 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">        <span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line">        <span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">            reiterate = <span class="keyword">false</span>;</span><br><span class="line">            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">                    processedBeans.add(ppName);</span><br><span class="line">                    reiterate = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">            registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">            currentRegistryProcessors.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 现在，调用 BeanFactoryProcessor，先调用 BeanDefinitionRegistryPostProcessor 接口的（是子接口），然后调用只是实现 BeanFactoryProcessor 的</span></span><br><span class="line">        <span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">        <span class="comment">// registryProcessors 里面包含 参数传进来的和 容器里的</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">        <span class="comment">// regularPostProcessors 只包含参数里面传进来的</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 beanFactory 不是 BeanDefinitionRegistry 类型的，那就只需要调用 BeanFactoryProcessor 了</span></span><br><span class="line">        <span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面就是调用 容器里面的 BeanFactoryProcessor，顺序一样的 PriorityOrdered -》 Ordered -》 无序</span></span><br><span class="line">    <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">    <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">    String[] postProcessorNames =</span><br><span class="line">            beanFactory.getBeanNamesForType(BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">    <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="comment">// 处理过的跳过</span></span><br><span class="line">        <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">            <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            orderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先处理 PriorityOrdered 接口的，排序，调用</span></span><br><span class="line">    <span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在处理 Ordered 接口的</span></span><br><span class="line">    <span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后处理没排序的</span></span><br><span class="line">    <span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 经过上面的处理后， BeanDefinition 可能修改了，清理缓存</span></span><br><span class="line">    <span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">    <span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">    beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过上面的调用 BeanDefinition ，该注册的注册，该修改的修改<br>记住，BeanFactoryPostProcessor 是在 ApplicationContext 上面添加的，因为 ApplicationContext 持有 BeanFactory，完成 BeanFactory 的启动<br>而 BeanPostProcessor 是添加在 BeanFactory 上的，因为 bean 有 BeanFactory 直接管理</p>
<h4 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource"></a>initMessageSource</h4><p>这个方法就是初始化 MessageSource，具体作用，再分析<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">    <span class="comment">// 如果已经有了，那就使用已经有的，设置一下 parent</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">            HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="keyword">this</span>.messageSource;</span><br><span class="line">            <span class="keyword">if</span> (hms.getParentMessageSource() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line">                <span class="comment">// registered already.</span></span><br><span class="line">                hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Using MessageSource ["</span> + <span class="keyword">this</span>.messageSource + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有，那就使用默认的 DelegatingMessageSource</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line">        DelegatingMessageSource dms = <span class="keyword">new</span> DelegatingMessageSource();</span><br><span class="line">        dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">        <span class="keyword">this</span>.messageSource = dms;</span><br><span class="line">        beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="keyword">this</span>.messageSource);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Unable to locate MessageSource with name '"</span> + MESSAGE_SOURCE_BEAN_NAME +</span><br><span class="line">                    <span class="string">"': using default ["</span> + <span class="keyword">this</span>.messageSource + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>继续看后面，再看看这个类是怎么用的</p>
<h4 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster"></a>initApplicationEventMulticaster</h4><p>这个就是初始化事件管理类，事件和事件监听对象都是在这个上面<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">    <span class="comment">// 一样的，如果有，就用有的，如果没有，就用默认的 SimpleApplicationEventMulticaster</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">                beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Using ApplicationEventMulticaster ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Unable to locate ApplicationEventMulticaster with name '"</span> +</span><br><span class="line">                    APPLICATION_EVENT_MULTICASTER_BEAN_NAME +</span><br><span class="line">                    <span class="string">"': using default ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh"></a>onRefresh</h4><p>这是一个空方法，容器内部的 bean 还没开始实例化，这个时候，还可以注册一些 bean之类的操作<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="finishBeanFactoryInitialization"><a href="#finishBeanFactoryInitialization" class="headerlink" title="finishBeanFactoryInitialization"></a>finishBeanFactoryInitialization</h4><p>这个方法就是开始实例化 bean 了，所有的非延时加载的singletons的都要实例化<br>实例化是调用 getBean 完成的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 ConversionService，这是一个类型转换接口</span></span><br><span class="line">    <span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        beanFactory.setConversionService(</span><br><span class="line">                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册默认的 value 解析器</span></span><br><span class="line">    <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">    <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">    <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">        beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先初始化 LoadTimeWeaverAware</span></span><br><span class="line">    <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">        getBean(weaverAwareName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止使用临时类加载器</span></span><br><span class="line">    <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存配置，不希望再有变化类，就是这个时候，不要再注册 BeanDefinition 了</span></span><br><span class="line">    <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">    beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始实例化 singletons 类型的 bean 了</span></span><br><span class="line">    <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>preInstantiateSingletons 这个方法是 DefaultListableBeanFactory 内部实例化的过程，这里先不说明，后面再看</p>
<h4 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh"></a>finishRefresh</h4><p>结束启动<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清理 resource 缓存</span></span><br><span class="line">    <span class="comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line">    clearResourceCaches();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 LifecycleProcessor 这是 Lifecycle 接口的管理器</span></span><br><span class="line">    <span class="comment">// 有定义就用定义的，没有就用默认的，挂在 context 上</span></span><br><span class="line">    <span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line">    initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 Lifecycle</span></span><br><span class="line">    <span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line">    getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布 ContextRefreshedEvent 事件</span></span><br><span class="line">    <span class="comment">// Publish the final event.</span></span><br><span class="line">    publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 JMX </span></span><br><span class="line">    <span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line">    LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="resetCommonCaches"><a href="#resetCommonCaches" class="headerlink" title="resetCommonCaches"></a>resetCommonCaches</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">resetCommonCaches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReflectionUtils.clearCache();</span><br><span class="line">    AnnotationUtils.clearCache();</span><br><span class="line">    ResolvableType.clearCache();</span><br><span class="line">    CachedIntrospectionResults.clearClassLoader(getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清理使用到的缓存<br>到这里，正常启动流程就完了<br>如果启动异常的话，是调用<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果启动出现异常，就销毁所有已经创建的实例</span></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消refresh</span></span><br><span class="line"><span class="comment">// Reset 'active' flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br></pre></td></tr></table></figure></p>
<p>到这里，spring 启动的整个启动流程就大致过了一遍了。<br>后面要看的，就是 BeanDefinition 是在哪里注册的，那些扩展接口在干什么<br>bean 的实例化流程细节，等待下回分析</p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSL使用</title>
    <url>/2019/09/16/OpenSSL%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。<br>在OpenSSL被曝出现严重安全漏洞后，发现多数通过SSL协议加密的网站使用名为OpenSSL的开源软件包。由于这是互联网应用最广泛的安全传输方法，被网银、在线支付、电商网站、门户网站、电子邮件等重要网站广泛使用，所以该漏洞影响范围广大。    </p>
<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>OpenSSL一共提供了8种对称加密算法，其中7种是分组加密算法，仅有的一种流加密算法是RC4。这7种分组加密算法分别是AES、DES、Blowfish、CAST、IDEA、RC2、RC5，都支持电子密码本模式（ECB）、加密分组链接模式（CBC）、加密反馈模式（CFB）和输出反馈模式（OFB）四种常用的分组密码加密模式。其中，AES使用的加密反馈模式（CFB）和输出反馈模式（OFB）分组长度是128位，其它算法使用的则是64位。事实上，DES算法里面不仅仅是常用的DES算法，还支持三个密钥和两个密钥3DES算法。        </p>
<h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><p>OpenSSL一共实现了4种非对称加密算法，包括DH算法、RSA算法、DSA算法和椭圆曲线算法（EC）。DH算法一般用户密钥交换。RSA算法既可以用于密钥交换，也可以用于数字签名，当然，如果你能够忍受其缓慢的速度，那么也可以用于数据加密。DSA算法则一般只用于数字签名。        </p>
<h2 id="信息摘要算法"><a href="#信息摘要算法" class="headerlink" title="信息摘要算法"></a>信息摘要算法</h2><p>OpenSSL实现了5种信息摘要算法，分别是MD2、MD5、MDC2、SHA（SHA1）和RIPEMD。SHA算法事实上包括了SHA和SHA1两种信息摘要算法，此外，OpenSSL还实现了DSS标准中规定的两种信息摘要算法DSS和DSS1。        </p>
<h2 id="密钥和证书管理"><a href="#密钥和证书管理" class="headerlink" title="密钥和证书管理"></a>密钥和证书管理</h2><p>密钥和证书管理是PKI的一个重要组成部分，OpenSSL为之提供了丰富的功能，支持多种标准。     </p>
<p>首先，OpenSSL实现了ASN.1的证书和密钥相关标准，提供了对证书、公钥、私钥、证书请求以及CRL等数据对象的DER、PEM和BASE64的编解码功能。OpenSSL提供了产生各种公开密钥对和对称密钥的方法、函数和应用程序，同时提供了对公钥和私钥的DER编解码功能。并实现了私钥的PKCS#12和PKCS#8的编解码功能。OpenSSL在标准中提供了对私钥的加密保护功能，使得密钥可以安全地进行存储和分发。     </p>
<p>在此基础上，OpenSSL实现了对证书的X.509标准编解码、PKCS#12格式的编解码以及PKCS#7的编解码功能。并提供了一种文本数据库，支持证书的管理功能，包括证书密钥产生、请求产生、证书签发、吊销和验证等功能。     </p>
<p>事实上，OpenSSL提供的CA应用程序就是一个小型的证书管理中心（CA），实现了证书签发的整个流程和证书管理的大部分机制。        </p>
<h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><ol>
<li>消息摘要算法应用例子        </li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 用SHA1算法计算文件file.txt的哈西值，输出到stdout</span><br><span class="line"># openssl dgst -sha1 file.txt</span><br><span class="line"></span><br><span class="line">#用SHA1算法计算文件file.txt的哈西值,输出到文件digest.txt</span><br><span class="line"># openssl sha1 -out digest.txt file.txt	</span><br><span class="line"></span><br><span class="line"># 用DSS1(SHA1)算法为文件file.txt签名,输出到文件dsasign.bin</span><br><span class="line"># 签名的private key必须为DSA算法产生的，保存在文件dsakey.pem中</span><br><span class="line"># openssl dgst -dss1 -sign dsakey.pem -out dsasign.bin file.txt</span><br><span class="line"></span><br><span class="line"># 用dss1算法验证file.txt的数字签名dsasign.bin，</span><br><span class="line"># 验证的private key为DSA算法产生的文件dsakey.pem</span><br><span class="line"># openssl dgst -dss1 -prverify dsakey.pem -signature dsasign.bin file.txt</span><br><span class="line"></span><br><span class="line"># 用sha1算法为文件file.txt签名,输出到文件rsasign.bin</span><br><span class="line"># 签名的private key为RSA算法产生的文件rsaprivate.pem</span><br><span class="line"># openssl sha1 -sign rsaprivate.pem -out rsasign.bin file.txt</span><br><span class="line"></span><br><span class="line"># 用sha1算法验证file.txt的数字签名rsasign.bin，</span><br><span class="line"># 验证的public key为RSA算法生成的rsapublic.pem</span><br><span class="line"># openssl sha1 -<span class="built_in">verify</span> rsapublic.pem -signature rsasign.bin file.txt</span><br></pre></td></tr></table></figure>
<ol>
<li>对称加密应用例子        </li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 对称加密应用例子</span><br><span class="line"># 用DES3算法的CBC模式加密文件plaintext.doc，</span><br><span class="line"># 加密结果输出到文件ciphertext.bin</span><br><span class="line"># openssl enc -des3 -salt -<span class="keyword">in</span> plaintext.doc -out ciphertext.bin</span><br><span class="line"></span><br><span class="line"># 用DES3算法的OFB模式解密文件ciphertext.bin，</span><br><span class="line"># 提供的口令为trousers，输出到文件plaintext.doc</span><br><span class="line"># 注意：因为模式不同，该命令不能对以上的文件进行解密</span><br><span class="line"># openssl enc -des-ede3-ofb -d -<span class="keyword">in</span> ciphertext.bin -out plaintext.doc -pass pass:trousers</span><br><span class="line"></span><br><span class="line"># 用Blowfish的CFB模式加密plaintext.doc，口令从环境变量PASSWORD中取</span><br><span class="line"># 输出到文件ciphertext.bin</span><br><span class="line"># openssl bf-cfb -salt -<span class="keyword">in</span> plaintext.doc -out ciphertext.bin -pass env:PASSWORD</span><br><span class="line"></span><br><span class="line"># 给文件ciphertext.bin用base64编码，输出到文件base64.txt</span><br><span class="line"># openssl base64 -<span class="keyword">in</span> ciphertext.bin -out base64.txt</span><br><span class="line"></span><br><span class="line"># 用RC5算法的CBC模式加密文件plaintext.doc</span><br><span class="line"># 输出到文件ciphertext.bin，</span><br><span class="line"># salt、key和初始化向量(iv)在命令行指定</span><br><span class="line"># openssl rc5 -<span class="keyword">in</span> plaintext.doc -out ciphertext.bin -S C62CB1D49F158ADC -iv E9EDACA1BD7090C6 -K <span class="number">89</span>D4B1678D604FAA3DBFFD030A314B29</span><br></pre></td></tr></table></figure>
<ol>
<li>Diffie-Hellman应用例子        </li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 使用生成因子<span class="number">2</span>和随机的<span class="number">1024</span>-bit的素数产生D0ffie-Hellman参数</span><br><span class="line"># 输出保存到文件dhparam.pem</span><br><span class="line"># openssl dhparam -out dhparam.pem -<span class="number">2</span> <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"># 从dhparam.pem中读取Diffie-Hell参数，以C代码的形式</span><br><span class="line"># 输出到stdout</span><br><span class="line"># openssl dhparam -<span class="keyword">in</span> dhparam.pem -noout -C</span><br></pre></td></tr></table></figure>
<ol>
<li>DSA应用例子应用例子        </li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 生成<span class="number">1024</span>位DSA参数集，并输出到文件dsaparam.pem</span><br><span class="line"># openssl dsaparam -out dsaparam.pem <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"># 使用参数文件dsaparam.pem生成DSA私钥匙，</span><br><span class="line"># 采用<span class="number">3</span>DES加密后输出到文件dsaprivatekey.pem</span><br><span class="line"># openssl gendsa -out dsaprivatekey.pem -des3 dsaparam.pem</span><br><span class="line"></span><br><span class="line"># 使用私钥匙dsaprivatekey.pem生成公钥匙，</span><br><span class="line"># 输出到dsapublickey.pem</span><br><span class="line"># openssl dsa -<span class="keyword">in</span> dsaprivatekey.pem -pubout -out dsapublickey.pem</span><br><span class="line"></span><br><span class="line"># 从dsaprivatekey.pem中读取私钥匙，解密并输入新口令进行加密，</span><br><span class="line"># 然后写回文件dsaprivatekey.pem</span><br><span class="line"># openssl dsa -<span class="keyword">in</span> dsaprivatekey.pem -out dsaprivatekey.pem -des3 -passin</span><br></pre></td></tr></table></figure>
<ol>
<li>RSA应用例子        </li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 产生<span class="number">1024</span>位RSA私匙，用<span class="number">3</span>DES加密它，口令为trousers，</span><br><span class="line"># 输出到文件rsaprivatekey.pem</span><br><span class="line"># openssl genrsa -out rsaprivatekey.pem -passout pass:trousers -des3 <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"># 从文件rsaprivatekey.pem读取私匙，用口令trousers解密，</span><br><span class="line"># 生成的公钥匙输出到文件rsapublickey.pem</span><br><span class="line"># openssl rsa -<span class="keyword">in</span> rsaprivatekey.pem -passin pass:trousers -pubout -out rsapubckey.pem</span><br><span class="line"></span><br><span class="line"># 用公钥匙rsapublickey.pem加密文件plain.txt，</span><br><span class="line"># 输出到文件cipher.txt</span><br><span class="line"># openssl rsautl -encrypt -pubin -inkey rsapublickey.pem -<span class="keyword">in</span> plain.txt -out cipher.txt</span><br><span class="line"></span><br><span class="line"># 使用私钥匙rsaprivatekey.pem解密密文cipher.txt，</span><br><span class="line"># 输出到文件plain.txt</span><br><span class="line"># openssl rsautl -decrypt -inkey rsaprivatekey.pem -<span class="keyword">in</span> cipher.txt -out plain.txt</span><br><span class="line"></span><br><span class="line"># 用私钥匙rsaprivatekey.pem给文件plain.txt签名，</span><br><span class="line"># 输出到文件signature.bin</span><br><span class="line"># openssl rsautl -sign -inkey rsaprivatekey.pem -<span class="keyword">in</span> plain.txt -out signature.bin</span><br><span class="line"></span><br><span class="line"># 用公钥匙rsapublickey.pem验证签名signature.bin，</span><br><span class="line"># 输出到文件plain.txt</span><br><span class="line"># openssl rsautl -<span class="built_in">verify</span> -pubin -inkey rsapublickey.pem -<span class="keyword">in</span> signature.bin -out plain</span><br><span class="line"></span><br><span class="line"># 从X.<span class="number">509</span>证书文件cert.pem中获取公钥匙，</span><br><span class="line"># 用<span class="number">3</span>DES加密mail.txt</span><br><span class="line"># 输出到文件mail.enc</span><br><span class="line"># openssl smime -encrypt -<span class="keyword">in</span> mail.txt -des3 -out mail.enc cert.pem</span><br><span class="line"></span><br><span class="line"># 从X.<span class="number">509</span>证书文件cert.pem中获取接收人的公钥匙，</span><br><span class="line"># 用私钥匙key.pem解密S/MIME消息mail.enc，</span><br><span class="line"># 结果输出到文件mail.txt</span><br><span class="line"># openssl smime -decrypt -<span class="keyword">in</span> mail.enc -recip cert.pem -inkey key.pem -out mail.txt</span><br><span class="line"></span><br><span class="line"># cert.pem为X.<span class="number">509</span>证书文件，用私匙key,pem为mail.txt签名，</span><br><span class="line"># 证书被包含在S/MIME消息中，输出到文件mail.sgn</span><br><span class="line"># openssl smime -sign -<span class="keyword">in</span> mail.txt -signer cert.pem -inkey key.pem -out mail.sgn</span><br><span class="line"></span><br><span class="line"># 验证S/MIME消息mail.sgn，输出到文件mail.txt</span><br><span class="line"># 签名者的证书应该作为S/MIME消息的一部分包含在mail.sgn中</span><br><span class="line"># openssl smime -<span class="built_in">verify</span> -<span class="keyword">in</span> mail.sgn -out mail.txt</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 学习笔记</title>
    <url>/2019/09/15/redis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>redis 之前只是会用，经常看一些博客和官网的使用说明，但是还没成体系的学习过<br>最近买了本 <code>Redis 开发与运维</code> ，买这本书对理由是我虽然会用，但是对譬如哨兵，集群方案，<br>内部 redis 之间是怎么通信对等一些细节不是很了解。想要详细了解下   </p>
<p>写这篇笔记，目的是，以后redis 相关等至少看自己等这篇笔记就可以了，不用经常回去翻书<br>其实书早就看完了。感觉要补一篇学习笔记。顺便用耗子哥说的总结归纳方法试一下<br>只归纳以下重点，具体细节就不罗列了</p>
<p>先套下学习模板  </p>
<ol>
<li>这个技术出现的背景，初衷和要达到什么样的目标或者是要解决什么样的问题</li>
<li>这个技术的优势和劣势分别是什么，或者说，这个技术的 trade-off 是什么</li>
<li>这个技术的适用场景</li>
<li>技术的组成部分和关键点</li>
<li>技术的底层原理和关键实现</li>
<li>已有的实现和它之间的对比</li>
</ol>
<h2 id="这个技术出现的背景"><a href="#这个技术出现的背景" class="headerlink" title="这个技术出现的背景"></a>这个技术出现的背景</h2><p><code>redis</code> 的作者实现原因是因为想要实现高性能的队列功能，用传统的 <code>mysql</code> 没办法达到性能要求<br>因此想要做一个专属的 <code>LLOOGG</code> 数据库。<br>这样看起来，简单的来说，<code>redis</code> 的出现背景是针对 传统数据库存储的性能不足 </p>
<h2 id="这个技术的优势和劣势分别是什么"><a href="#这个技术的优势和劣势分别是什么" class="headerlink" title="这个技术的优势和劣势分别是什么"></a>这个技术的优势和劣势分别是什么</h2><ol>
<li>速度快。 读写达到10w/s</li>
<li>基于键值对对数据结构服务器。支持常用的数据结构</li>
<li>丰富的功能。键过期，发布订阅，lua脚本，简单事务，流水线</li>
<li>简单稳定。单线程模型</li>
<li>支持的客户端语言多</li>
<li>支持持久化</li>
<li>主从复制</li>
<li>高可用和分布式</li>
</ol>
<h2 id="这个技术的适用场景"><a href="#这个技术的适用场景" class="headerlink" title="这个技术的适用场景"></a>这个技术的适用场景</h2><ol>
<li>缓存。大部分使用场景都是这个</li>
<li>消息队列系统。简单的消息队列，基于发布订阅或者阻塞队列。这个只针对简单的队列功能，无持久化，重复，等复杂功能</li>
<li>排行榜和计数器应用。。。这是书上说的，感觉其实就是使用 <code>redis</code> 里面的数据结构实现的一些功能。</li>
</ol>
<p>不适用的场景：1. 数据存储。<code>redis</code> 是基于内存的，不应该将全部数据或者冷数据放到 <code>redis</code> </p>
<h2 id="技术的组成部分和关键点"><a href="#技术的组成部分和关键点" class="headerlink" title="技术的组成部分和关键点"></a>技术的组成部分和关键点</h2><p><strong>单线程模型</strong><br>首先，就是单线程模型，这个一定要知道。<br>所谓单线程模型，不代表 redis 进程内部只有一个线程，而是，只用单线程处理客户请求的命令<br>所以从客户端发请求到响应要经过以下过程：</p>
<ol>
<li>命令网络传输</li>
<li>命令队列等待时间</li>
<li>命令处理时间</li>
<li>命令响应网络传输</li>
</ol>
<p>通常 redis 保证命令处理时间很短，当然，在有大量 key 的 redis 使用 keys 命令也是会执行很长时间的</p>
<p><strong>数据结构</strong><br>支持5种数据结构。 string，hash，list，set，zset</p>
<p>string 内部编码是 </p>
<ol>
<li>raw &gt;39个字节的字符串</li>
<li>int 8个字节长整型</li>
<li>embstr &lt;= 39 个字节的字符串<br>hash 的内部编码：</li>
<li>hashtable  不满足下面的情况下使用</li>
<li>ziplist  hash类型元素个数小于 hash-max-ziplist-entries 默认 512 个，这个是一个紧凑的结构，节省内存<br>list 的内部编码是 </li>
<li>linkedlist 不满足下面的条件</li>
<li>ziplist 列表元素个数小于 list-max-ziplist-entries 默认 512 个，同时列表每个元素的值小于 list-max-ziplist-value 默认 64 字节<br>set 的内部编码是 </li>
<li>hashtable 不满足下面</li>
<li>intset 元素是整数，并且数量小于 set-man-intset-entries<br>zset 的内部编码是 </li>
<li>skiplist 不满足下面条件</li>
<li>ziplist 元素个数小于 zet-max-ziplist-entries 默认 128 个 同时元素小于 zset-max-ziplist-value 默认 64 字节</li>
</ol>
<p><strong>键过期</strong><br><code>expire</code> 设置过期时间 和 <code>ttl</code> 查询存活时间，返回 -1 代表没设置过期时间，-2 键不存在<br>键过期有两种方式，一种是惰性的，当访问到 key 到时候检查 key 过期了才移除，另一种是定时抽样检查移除过期的 key，如果比例大于 25%，继续进行抽样，直到运行超时 25ms </p>
<p><strong>pipeline</strong><br>pipeline 简单点说，就是将一批命令，整体打包发送给 redis，这样节省了 客户端与redis 的网络通信时间</p>
<p><strong>持久化</strong><br>主要有两种持久化方式 rdb 和 aof </p>
<ol>
<li><p>rdb<br>rdb 相当于当前 redis 数据的快照，生成文件存放在硬盘<br>分为自动触发和手动触发，手动使用 <code>bgsave</code> 自动就是配置 <code>save m n</code> 标示 m 秒内有 n 次修改触发<br>文件保存 dir 配置的目录下，文件名韦 dbfilename 配置<br>rdb 没办法做到实时持久化，是一个紧凑的 二进制文件，redis 加载 rdb 文件比 aof 快</p>
</li>
<li><p>aof<br>就是以独立日志记录每次写命令，<br>开启需要 appendonly yes 配置开启 文件名为 appendfilename 配置<br>里面关键的是文件同步策略。每次命令是写在缓冲区，什么时候刷盘，需要配置 appendfsync 有 always everysec no 默认是 everysec<br>当 aof 文件很大的时候可以重写，直接使用当前 redis 的数据重写 aof 文件<br>手动触发 使用命令 bgrewriteaof<br>自动触发 根据配置 auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage </p>
</li>
</ol>
<p><strong>事务</strong><br>将一组要执行的命令放在 multi  和 exec 命令中间<br>可以使用 discard 命令停止事务<br>如果命令过程中有语法错误，事务不执行<br>如果命令用错了，譬如 sadd 写成了 zadd ，错误前面的命令会执行。。</p>
<p><strong>支持主从复制</strong><br>主从是高可用的基础<br>启动的时候使用配置 slaveof host port 配置<br>也可以在运行过程中执行命令 slaveof host port<br>查看主从信息，可以 info replication 命令<br>断开主从，可以 slaveof no one 断开主从连接，不会删除已有数据，只是无法接收新的数据变化<br>可以先断开主从，然后切换新的主节点，注意，切换过程中原有数据将删除，重新同步新的主节点数据，slave 默认只读<br>每个 redis 节点根据 运行id 区分，每次启动都会动态分配一个 40 位的运行 id</p>
<p><strong>高可用-哨兵</strong><br>哨兵基于主从复制，在主节点出现故障的时候完成故障转移操作，提升一个从节点为主节点，并将其他从节点修改主节点地址<br>判断主节点故障至少需要 n/2 + 1 个哨兵确认<br>客户端获取主节点地址要通过哨兵获取，每监控一个主键点，其实就是一个 mastername，一套哨兵可以同时监控多个主节点</p>
<p>故障转移的步骤简单说</p>
<ol>
<li>判断主节点故障</li>
<li>选择一个 sentinal 节点完成故障转移功能</li>
<li>选择一个数据最全的从节点作为新的主节点</li>
<li>切换</li>
</ol>
<p>当然，中间有很多细节，就不写了。就算看了也估计就能记一段时间，这些概念还是能够理解的</p>
<p><strong>高可用-集群</strong><br>当数据量过大，单个节点存不下所有数据，需要多个 redis 节点分担的时候，使用 redis 集群方案<br>数据分区规则：<br>根据虚拟槽分区，使用一个 hash 函数，将数据映射到一个 整数集合中，定义为 slot 槽，redis 到 slot 范围为 0 - 16383<br>每个 redis 主节点负责一部分 slot，一个 redis 集群，必须每个 slot 都有节点负责，这个时候 redis 集群才能正常工作  </p>
<p>以集群模式启动 redis 需要配置<br>cluster-enabled yes<br>配置内部配置文件，这个通常是生成的配置<br>cluster-config-file node-port.conf  </p>
<p>然后完成节点握手 通过 gossip 流言协议，达到互相感知<br>cluster meet host port 命令</p>
<p>然后分配 slot<br>cluster addslots {0…5461} </p>
<p>分配了slot 的节点可以认为是主节点，然后配置其他节点复制响应的主节点，根据 nodeid 复制<br>cluster replicate nodeid</p>
<p>当然，手动配置比较复杂，使用 redis-trib.rb 搭建集群简单点 </p>
<p>当有新的节点加入，可以将部分 slot 转移个新节点<br>当有主节点退出，也可以将他负责的 slot 转移给其他节点</p>
<h2 id="已有的实现和它之间的对比"><a href="#已有的实现和它之间的对比" class="headerlink" title="已有的实现和它之间的对比"></a>已有的实现和它之间的对比</h2><p>memcached 多线程模型，只支持 key value<br>好吧，其实我没用过，也没了解过这个东西。。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>除了上面的5个数据结构，还有一些扩展 </p>
<p><strong>位图</strong><br>bitmap<br>事件上是字符串，内部存 0 1<br>命令 setbit key offset value    getbit key offset<br>还有一些其他的命令，用到的时候可以详细看  </p>
<p><strong>hyperloglog</strong><br>这实际上是一个基数算法，可以使用更少的内存空间完成集合运算，当然存在一定误差</p>
<p><strong>pub/sub</strong><br>基于频道的发布订阅，之前高可用内部通信很多都是基于这个<br>可以看着简单的队列<br>命令：<br>publish chennel message<br>subscribe channel<br>unsubscribe channel</p>
<p><strong>geo</strong><br>地理位置信息<br>geoadd key longtitude latitude member 。。。</p>
<p>完成地理位置信息的录入后，可以做些计算。。没用过  </p>
<p><strong>stream</strong><br>redis5 新增的一个消息队列<br>与 kafka 类型，之前的发布订阅，订阅者可以获取全量数据，并且无法获取之前的数据<br>stream 目前会存一份原数据，消费者也分为消费者组，每个组消费全量数据，组内每个消费者竞争获取</p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 索引使用的注意事项</title>
    <url>/2019/09/13/MySQL-%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<p>索引能够加快查询速度，但是维护索引和更新索引也会消耗时间，<br>不过通常只要建立合适的索引，从加快查询速度获取的收益是可以忽略掉维护和更新索引的消耗时间的  </p>
<p>创建索引的原则：</p>
<ol>
<li>更新频繁的列不应设置索引</li>
<li>重复数据多的字段不应设为索引</li>
<li>首先应该考虑对where 和 order by 涉及的列上建立索引</li>
</ol>
<p>可以使用 explain 来查看查询是否走索引了。<br>重点是</p>
<ol>
<li><p>type </p>
<ul>
<li>system 表中就一行</li>
<li>const 通过索引一次找到</li>
<li>eq_ref 唯一索引，包括主键索引</li>
<li>ref 索引</li>
<li>range 范围索引</li>
<li>index  只遍历索引树</li>
<li>all 全部扫描</li>
</ul>
<p>顺便说下，走索引不一定查询时间就慢，还有看表里面有多少行数据<br>实际上一条查询语句的快慢是根据扫描行数确定的  </p>
</li>
</ol>
<p>优化语句：</p>
<ol>
<li>不要在 <code>=</code> 左边用函数，例如 where a/2 = 10</li>
<li>不要用 <code>&lt;&gt;</code>, <code>!=</code>, <code>not in</code></li>
<li>不用 null 判断</li>
<li>like 不要用左模糊 %abc</li>
<li>避免用 or ，用 union 代替</li>
<li>exist 代替 in</li>
<li>不要使用类型隐式转换</li>
<li>联合索引的时候条件顺序<br>。。。</li>
</ol>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis细节分析</title>
    <url>/2019/09/11/mybatis%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>主要看看一些功能点的实现，譬如 扩展，一二级缓存，mapper 接口    </p>
<h2 id="扩展（plugins）"><a href="#扩展（plugins）" class="headerlink" title="扩展（plugins）"></a>扩展（plugins）</h2><p>直接看在哪里增加扩展的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    <span class="keyword">return</span> parameterHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">      ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">    <span class="keyword">return</span> resultSetHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">// 这里就是扩展了，使用插件扩展，主要扩展接口是 Interceptor ，被代理的是 StatementHandler 的实现类</span></span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    <span class="keyword">return</span> statementHandler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到自定义插件可以扩展的接口有4个 Executor，ParameterHandler，ResultSetHandler，StatementHandler<br>基本涵盖了整个执行流程，都是调用 <code>interceptorChain.pluginAll</code>,我们看看怎么实现的扩展<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们自定义的扩展需要实现 Interceptor 接口，然后注册到 InterceptorChain 中，最后，依次调用 plugin 方法<br>我们看一个示例<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;</span><br><span class="line">      <span class="meta">@Signature</span>(type = Map<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"get"</span>, args = &#123;Object<span class="class">.<span class="keyword">class</span>&#125;)&#125;)</span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">static</span> <span class="title">class</span> <span class="title">AlwaysMapPlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Always"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>扩展必须要实现 Interceptor 接口，里面有3个方法  </p>
<ol>
<li><p>setProperties<br>这个方法是在解析的时候，可以配置一些参数到里面，在add之前被调用<br>我们看一下插件解析过程就清楚了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pluginElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      String interceptor = child.getStringAttribute(<span class="string">"interceptor"</span>);</span><br><span class="line">      Properties properties = child.getChildrenAsProperties();</span><br><span class="line">      Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();</span><br><span class="line">      interceptorInstance.setProperties(properties);</span><br><span class="line">      configuration.addInterceptor(interceptorInstance);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>plugin<br>这个方法的调用可以看到是在做扩展的时候。<br>一般调用 <code>Plugin.wrap(target, this)</code> 方法，<br>或者，可以做条件判断，是自己要处理就就这样调用，不是自己处理的，就直接返回 target。 </p>
</li>
<li><p>intercept<br>这个方法就是具体的拦截信息了<br>可以在类上添加注解，拦截注解想要的类和方法，这样 Invocation 里面就是自己想要的东西了    </p>
</li>
</ol>
<p>我们具体看看 <code>Plugin.wrap</code> 方法，这个方式是实现扩展的关键，原理就是动态代理<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK 的动态代理，实现 Plugin 扩展</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Interceptor interceptor;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Plugin</span><span class="params">(Object target, Interceptor interceptor, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    <span class="keyword">this</span>.interceptor = interceptor;</span><br><span class="line">    <span class="keyword">this</span>.signatureMap = signatureMap;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取注解数据</span></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    <span class="comment">// 如果经过多次代理，那这里就是代理对象的 class了</span></span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    <span class="comment">// 就是过滤出上面需要的代理的接口，实现代理就行了</span></span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">          type.getClassLoader(),</span><br><span class="line">          interfaces,</span><br><span class="line">          <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">      <span class="comment">// 如果满足条件，就调用拦截器</span></span><br><span class="line">      <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 否则调用原本对象的方法</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) &#123;</span><br><span class="line">    Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// issue #251</span></span><br><span class="line">    <span class="comment">// 看到，Interceptor 扩展 必须要有 Intercepts 注解</span></span><br><span class="line">    <span class="keyword">if</span> (interceptsAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> PluginException(<span class="string">"No @Intercepts annotation was found in interceptor "</span> + interceptor.getClass().getName());      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿到所有签名,就是过滤条件。。就是要代理哪个对象的哪个方法，可以指定多个</span></span><br><span class="line">    Signature[] sigs = interceptsAnnotation.value();</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Signature sig : sigs) &#123;</span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.computeIfAbsent(sig.type(), k -&gt; <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Method method = sig.type().getMethod(sig.method(), sig.args());</span><br><span class="line">        methods.add(method);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> PluginException(<span class="string">"Could not find method on "</span> + sig.type() + <span class="string">" named "</span> + sig.method() + <span class="string">". Cause: "</span> + e, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signatureMap;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt;[] getAllInterfaces(Class&lt;?&gt; type, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123;</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; interfaces = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (type != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; c : type.getInterfaces()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signatureMap.containsKey(c)) &#123;</span><br><span class="line">          interfaces.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      type = type.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> interfaces.toArray(<span class="keyword">new</span> Class&lt;?&gt;[interfaces.size()]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到，扩展必须要标记 @Intercepts 注解， @Signature 代表要拦截的类型，方法，参数，可以指定多个，最后，@Signature 标记过的类型（接口），才被代理<br>使用的是 JDK 代理，调用的就是这里的 invoke 方法<br>原理很简单，可以扩展的接口就是上面说的4个（也就是 @Signature 注解里面 type 可以指定的，如果指定了其他类型是无效的，为啥无效，请自己分析）   </p>
<h2 id="缓存（cache）"><a href="#缓存（cache）" class="headerlink" title="缓存（cache）"></a>缓存（cache）</h2><p>缓存在执行分析里面看过了，只不过没有细讲，我们先从二级缓存开始，也就是 CachingExecutor 类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 cache，可能开了二级缓存，但是对应的 mapper 没有定义，二级缓存的粒度是到 mapper 的</span></span><br><span class="line">  <span class="comment">// 这里的 cache 是跟 ms 绑定的</span></span><br><span class="line">  Cache cache = ms.getCache();</span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 看是否需要刷新缓存</span></span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 这里是 callable 需要的</span></span><br><span class="line">      ensureNoOutParams(ms, boundSql);</span><br><span class="line">      <span class="comment">// 先从缓存里面获取</span></span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">      <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有就去查询，这里没有缓存穿透处理，处理再一级缓存里面</span></span><br><span class="line">        <span class="comment">// 一级缓存，就是跟 executor 绑定的</span></span><br><span class="line">        list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        <span class="comment">// 放入缓存</span></span><br><span class="line">        tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果没有定义缓存，直接查询</span></span><br><span class="line">  <span class="keyword">return</span> delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">  Cache cache = ms.getCache();</span><br><span class="line">  <span class="comment">// 这里 ms 代表一条sql，或者一个方法，每个方法都可以单独设置是否刷新缓存，默认是 查询不刷新，增删改刷新</span></span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;      </span><br><span class="line">    tcm.clear(cache);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>二级缓存使用 TransactionalCache 装饰 一级缓存   </p>
<h2 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h2><p>通常，我们不会直接使用 SqlSession.selectOne 这样去查询，因为不方便维护<br>大部分时候，我们都用 getMapper 来获取对应 Dao<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里调用 configuration 的 getMapper</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type Mapper interface class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> configuration.&lt;T&gt;getMapper(type, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">  <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在之前的解析中，对应的 Mapper ，都put MapperProxyFactory  对象了，当 getMapper 的时候，就是调用 newInstance 方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxyFactory</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getMapperInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;Method, MapperMethod&gt; <span class="title">getMethodCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里又使用了 JDK 的动态代理，实现类是 MapperProxy<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过 getMapper 获取的接口</span></span><br><span class="line"><span class="comment"> * 确切的说，直接使用 modelNameMapper 里面的方法的，都是走这个代理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6424540398559729838L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    <span class="keyword">this</span>.methodCache = methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line">        <span class="comment">// Object 类里面的方法 toString 之类的</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">        <span class="comment">// 默认方法 接口的默认方法</span></span><br><span class="line">        <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 或者 MapperMethod 对象，不需要重复创建，有缓存</span></span><br><span class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">    <span class="comment">// 调用方法</span></span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> methodCache.computeIfAbsent(method, k -&gt; <span class="keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 调用接口的默认方法</span></span><br><span class="line"><span class="comment">   * 这些 API 第一次见</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@UsesJava</span>7</span><br><span class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">invokeDefaultMethod</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Constructor&lt;MethodHandles.Lookup&gt; constructor = MethodHandles.Lookup<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">        .<span class="title">getDeclaredConstructor</span>(<span class="title">Class</span>.<span class="title">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (!constructor.isAccessible()) &#123;</span><br><span class="line">      constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">    <span class="keyword">return</span> constructor</span><br><span class="line">        .newInstance(declaringClass,</span><br><span class="line">            MethodHandles.Lookup.PRIVATE | MethodHandles.Lookup.PROTECTED</span><br><span class="line">                | MethodHandles.Lookup.PACKAGE | MethodHandles.Lookup.PUBLIC)</span><br><span class="line">        .unreflectSpecial(method, declaringClass).bindTo(proxy).invokeWithArguments(args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Backport of java.lang.reflect.Method#isDefault()</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDefaultMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (method.getModifiers()</span><br><span class="line">        &amp; (Modifier.ABSTRACT | Modifier.PUBLIC | Modifier.STATIC)) == Modifier.PUBLIC</span><br><span class="line">        &amp;&amp; method.getDeclaringClass().isInterface();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>里面，实际调用在 MapperMethod 里面<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlCommand command;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MethodSignature method;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MapperMethod</span><span class="params">(Class&lt;?&gt; mapperInterface, Method method, Configuration config)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造 SqlCommand</span></span><br><span class="line">  <span class="keyword">this</span>.command = <span class="keyword">new</span> SqlCommand(config, mapperInterface, method);</span><br><span class="line">  <span class="comment">// 构造方法签名</span></span><br><span class="line">  <span class="keyword">this</span>.method = <span class="keyword">new</span> MethodSignature(config, mapperInterface, method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">  Object result;</span><br><span class="line">  <span class="comment">// 里面还是调用 SqlSession 的方法</span></span><br><span class="line">  <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">      <span class="comment">// 增删改的返回类型可以是 int long boolean（包括包装类型）</span></span><br><span class="line">  	Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> SELECT:</span><br><span class="line">      <span class="comment">// 重点是查询方法的返回处理</span></span><br><span class="line">      <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">        <span class="comment">// 如果返回为空，或者自定义返回结果处理</span></span><br><span class="line">        executeWithResultHandler(sqlSession, args);</span><br><span class="line">        result = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">        <span class="comment">// 返回 list 或者 array</span></span><br><span class="line">        result = executeForMany(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">        <span class="comment">// 返回 map</span></span><br><span class="line">        result = executeForMap(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">        <span class="comment">// 返回游标</span></span><br><span class="line">        result = executeForCursor(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他情况 java8 的 Optional</span></span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">        <span class="keyword">if</span> (method.returnsOptional() &amp;&amp;</span><br><span class="line">            (result == <span class="keyword">null</span> || !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">          result = OptionalUtil.ofNullable(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FLUSH:</span><br><span class="line">      result = sqlSession.flushStatements();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + command.getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName() </span><br><span class="line">        + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + method.getReturnType() + <span class="string">")."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;E&gt; result;</span><br><span class="line">  Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">  <span class="keyword">if</span> (method.hasRowBounds()) &#123;</span><br><span class="line">    RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line">    result = sqlSession.&lt;E&gt;selectList(command.getName(), param, rowBounds);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = sqlSession.&lt;E&gt;selectList(command.getName(), param);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// issue #510 Collections &amp; arrays support</span></span><br><span class="line">  <span class="keyword">if</span> (!method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getReturnType().isArray()) &#123;</span><br><span class="line">      <span class="keyword">return</span> convertToArray(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">rowCountResult</span><span class="params">(<span class="keyword">int</span> rowCount)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Object result;</span><br><span class="line">  <span class="keyword">if</span> (method.returnsVoid()) &#123;</span><br><span class="line">    result = <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Integer<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getReturnType</span>()) || <span class="title">Integer</span>.<span class="title">TYPE</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getReturnType</span>())) </span>&#123;</span><br><span class="line">    result = rowCount;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Long<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getReturnType</span>()) || <span class="title">Long</span>.<span class="title">TYPE</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getReturnType</span>())) </span>&#123;</span><br><span class="line">    result = (<span class="keyword">long</span>)rowCount;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Boolean<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getReturnType</span>()) || <span class="title">Boolean</span>.<span class="title">TYPE</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getReturnType</span>())) </span>&#123;</span><br><span class="line">    result = rowCount &gt; <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName() + <span class="string">"' has an unsupported return type: "</span> + method.getReturnType());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 SqlCommand 和 MethodSignature 都静态内部类，获取一些辅助信息<br>内部还是使用 sqlsession.select update delete insert 方法<br>内部细节就不具体分析了，注意一点的就是默认方法直接调用，利用这个特性，当有一个通用的查询接口后（example），其他个性查询可以使用默认方法来实现，不需要写sql，或者在service里面实现   </p>
<p>mapper 接口里面的参数将会被封装<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">convertArgsToSqlCommandParam</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> paramNameResolver.getNamedParams(args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getNamedParams</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> paramCount = names.size();</span><br><span class="line">  <span class="keyword">if</span> (args == <span class="keyword">null</span> || paramCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasParamAnnotation &amp;&amp; paramCount == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> args[names.firstKey()];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, Object&gt; param = <span class="keyword">new</span> ParamMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;</span><br><span class="line">      param.put(entry.getValue(), args[entry.getKey()]);</span><br><span class="line">      <span class="comment">// add generic param names (param1, param2, ...)</span></span><br><span class="line">      <span class="keyword">final</span> String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// ensure not to overwrite parameter named with @Param</span></span><br><span class="line">      <span class="keyword">if</span> (!names.containsValue(genericParamName)) &#123;</span><br><span class="line">        param.put(genericParamName, args[entry.getKey()]);</span><br><span class="line">      &#125;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> param;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>特别注意，两个特殊类型不会在这里面 RowBounds ResultHandler  </p>
<h2 id="SqlSource"><a href="#SqlSource" class="headerlink" title="SqlSource"></a>SqlSource</h2><p>一般初次构建的类型是 DynamicSqlSource 和 RawSqlSource<br>这是不能直接用的。譬如 DynamicSqlSource 里面的标签都还没解析<br>所以获取 BoundSql 的时候，开始解析，重新获得 SqlSource<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构建 DynamicContext</span></span><br><span class="line">  DynamicContext context = <span class="keyword">new</span> DynamicContext(configuration, parameterObject);</span><br><span class="line">  <span class="comment">// 这里的 SqlNode 是 MixedSqlNode ，内部包含 SqlNode 的一个list，对list 里面按顺序依次解析，具体的解析过程，可以看对应 Node 里面</span></span><br><span class="line">  rootSqlNode.apply(context);</span><br><span class="line">  SqlSourceBuilder sqlSourceParser = <span class="keyword">new</span> SqlSourceBuilder(configuration);</span><br><span class="line">  Class&lt;?&gt; parameterType = parameterObject == null ? Object.class : parameterObject.getClass();</span><br><span class="line">  <span class="comment">// 这里的 getBindings 默认带有两个参数 _databaseId 和 _parameter， 动态sql 经过上面的解析后，就变成静态的了，#&#123;&#125; 就换成了 ? 了</span></span><br><span class="line">  SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());</span><br><span class="line">  <span class="comment">// 获取 BoundSql</span></span><br><span class="line">  BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line">  <span class="comment">// 传递内部参数</span></span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) &#123;</span><br><span class="line">    boundSql.setAdditionalParameter(entry.getKey(), entry.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> boundSql;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，解析完成获得一个 SqlSource 后，继续调用 getBoundSql，我们看看解析过程<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parse</span><span class="params">(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters)</span> </span>&#123;</span><br><span class="line">  ParameterMappingTokenHandler handler = <span class="keyword">new</span> ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);</span><br><span class="line">  GenericTokenParser parser = <span class="keyword">new</span> GenericTokenParser(<span class="string">"#&#123;"</span>, <span class="string">"&#125;"</span>, handler);</span><br><span class="line">  String sql = parser.parse(originalSql);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> StaticSqlSource(configuration, sql, handler.getParameterMappings());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>说一句 <code>rootSqlNode.apply(context);</code> 这一行执行后，xml 里面的标签已经解析完成了。<br>可以看到，解析就是替换 <code>#{}</code> 换成 <code>?</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">handleToken</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">     parameterMappings.add(buildParameterMapping(content));</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"?"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ParameterMapping <span class="title">buildParameterMapping</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">     Map&lt;String, String&gt; propertiesMap = parseParameterMapping(content);</span><br><span class="line">     <span class="comment">// property 也就是 #&#123;&#125; 里面的内容，字段名</span></span><br><span class="line">     String property = propertiesMap.get(<span class="string">"property"</span>);</span><br><span class="line">     Class&lt;?&gt; propertyType;</span><br><span class="line">     <span class="comment">// 找到字段类型</span></span><br><span class="line">     <span class="keyword">if</span> (metaParameters.hasGetter(property)) &#123; <span class="comment">// issue #448 get type from additional params</span></span><br><span class="line">       propertyType = metaParameters.getGetterType(property);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterType)) &#123;</span><br><span class="line">       propertyType = parameterType;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (JdbcType.CURSOR.name().equals(propertiesMap.get(<span class="string">"jdbcType"</span>))) &#123;</span><br><span class="line">       propertyType = java.sql.ResultSet<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (property == <span class="keyword">null</span> || Map<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">parameterType</span>)) </span>&#123;</span><br><span class="line">       propertyType = Object<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       MetaClass metaClass = MetaClass.forClass(parameterType, configuration.getReflectorFactory());</span><br><span class="line">       <span class="keyword">if</span> (metaClass.hasGetter(property)) &#123;</span><br><span class="line">         propertyType = metaClass.getGetterType(property);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         propertyType = Object<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ParameterMapping.Builder builder = <span class="keyword">new</span> ParameterMapping.Builder(configuration, property, propertyType);</span><br><span class="line">     Class&lt;?&gt; javaType = propertyType;</span><br><span class="line">     String typeHandlerAlias = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">// 语法支持，大部分时候啥都没做，一般，我们也只用 #&#123;username&#125; 这样的</span></span><br><span class="line">     <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : propertiesMap.entrySet()) &#123;</span><br><span class="line">       String name = entry.getKey();</span><br><span class="line">       String value = entry.getValue();</span><br><span class="line">       <span class="keyword">if</span> (<span class="string">"javaType"</span>.equals(name)) &#123;</span><br><span class="line">         javaType = resolveClass(value);</span><br><span class="line">         builder.javaType(javaType);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"jdbcType"</span>.equals(name)) &#123;</span><br><span class="line">         builder.jdbcType(resolveJdbcType(value));</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"mode"</span>.equals(name)) &#123;</span><br><span class="line">         builder.mode(resolveParameterMode(value));</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"numericScale"</span>.equals(name)) &#123;</span><br><span class="line">         builder.numericScale(Integer.valueOf(value));</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"resultMap"</span>.equals(name)) &#123;</span><br><span class="line">         builder.resultMapId(value);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"typeHandler"</span>.equals(name)) &#123;</span><br><span class="line">         typeHandlerAlias = value;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"jdbcTypeName"</span>.equals(name)) &#123;</span><br><span class="line">         builder.jdbcTypeName(value);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"property"</span>.equals(name)) &#123;</span><br><span class="line">         <span class="comment">// Do Nothing</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"expression"</span>.equals(name)) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Expression based parameters are not supported yet"</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"An invalid property '"</span> + name + <span class="string">"' was found in mapping #&#123;"</span> + content + <span class="string">"&#125;.  Valid properties are "</span> + parameterProperties);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (typeHandlerAlias != <span class="keyword">null</span>) &#123;</span><br><span class="line">       builder.typeHandler(resolveTypeHandler(javaType, typeHandlerAlias));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> builder.build();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里会生成参数映射。<br>最后返回的是 <code>StaticSqlSource</code>  </p>
<p><code>parseParameterMapping</code> 方法解析，可以参见单元测试内容<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleProperty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; result = <span class="keyword">new</span> ParameterExpression(<span class="string">"id"</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">1</span>, result.size());</span><br><span class="line">    Assert.assertEquals(<span class="string">"id"</span>, result.get(<span class="string">"property"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">propertyWithSpacesInside</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; result = <span class="keyword">new</span> ParameterExpression(<span class="string">" with spaces "</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">1</span>, result.size());</span><br><span class="line">    Assert.assertEquals(<span class="string">"with spaces"</span>, result.get(<span class="string">"property"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simplePropertyWithOldStyleJdbcType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; result = <span class="keyword">new</span> ParameterExpression(<span class="string">"id:VARCHAR"</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">2</span>, result.size());</span><br><span class="line">    Assert.assertEquals(<span class="string">"id"</span>, result.get(<span class="string">"property"</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">"VARCHAR"</span>, result.get(<span class="string">"jdbcType"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oldStyleJdbcTypeWithExtraWhitespaces</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; result = <span class="keyword">new</span> ParameterExpression(<span class="string">" id :  VARCHAR "</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">2</span>, result.size());</span><br><span class="line">    Assert.assertEquals(<span class="string">"id"</span>, result.get(<span class="string">"property"</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">"VARCHAR"</span>, result.get(<span class="string">"jdbcType"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expressionWithOldStyleJdbcType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; result = <span class="keyword">new</span> ParameterExpression(<span class="string">"(id.toString()):VARCHAR"</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">2</span>, result.size());</span><br><span class="line">    Assert.assertEquals(<span class="string">"id.toString()"</span>, result.get(<span class="string">"expression"</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">"VARCHAR"</span>, result.get(<span class="string">"jdbcType"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simplePropertyWithOneAttribute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; result = <span class="keyword">new</span> ParameterExpression(<span class="string">"id,name=value"</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">2</span>, result.size());</span><br><span class="line">    Assert.assertEquals(<span class="string">"id"</span>, result.get(<span class="string">"property"</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">"value"</span>, result.get(<span class="string">"name"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expressionWithOneAttribute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; result = <span class="keyword">new</span> ParameterExpression(<span class="string">"(id.toString()),name=value"</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">2</span>, result.size());</span><br><span class="line">    Assert.assertEquals(<span class="string">"id.toString()"</span>, result.get(<span class="string">"expression"</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">"value"</span>, result.get(<span class="string">"name"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simplePropertyWithManyAttributes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; result = <span class="keyword">new</span> ParameterExpression(<span class="string">"id, attr1=val1, attr2=val2, attr3=val3"</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">4</span>, result.size());</span><br><span class="line">    Assert.assertEquals(<span class="string">"id"</span>, result.get(<span class="string">"property"</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">"val1"</span>, result.get(<span class="string">"attr1"</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">"val2"</span>, result.get(<span class="string">"attr2"</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">"val3"</span>, result.get(<span class="string">"attr3"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expressionWithManyAttributes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; result = <span class="keyword">new</span> ParameterExpression(<span class="string">"(id.toString()), attr1=val1, attr2=val2, attr3=val3"</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">4</span>, result.size());</span><br><span class="line">    Assert.assertEquals(<span class="string">"id.toString()"</span>, result.get(<span class="string">"expression"</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">"val1"</span>, result.get(<span class="string">"attr1"</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">"val2"</span>, result.get(<span class="string">"attr2"</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">"val3"</span>, result.get(<span class="string">"attr3"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simplePropertyWithOldStyleJdbcTypeAndAttributes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; result = <span class="keyword">new</span> ParameterExpression(<span class="string">"id:VARCHAR, attr1=val1, attr2=val2"</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">4</span>, result.size());</span><br><span class="line">    Assert.assertEquals(<span class="string">"id"</span>, result.get(<span class="string">"property"</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">"VARCHAR"</span>, result.get(<span class="string">"jdbcType"</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">"val1"</span>, result.get(<span class="string">"attr1"</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">"val2"</span>, result.get(<span class="string">"attr2"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simplePropertyWithSpaceAndManyAttributes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; result = <span class="keyword">new</span> ParameterExpression(<span class="string">"user name, attr1=val1, attr2=val2, attr3=val3"</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">4</span>, result.size());</span><br><span class="line">    Assert.assertEquals(<span class="string">"user name"</span>, result.get(<span class="string">"property"</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">"val1"</span>, result.get(<span class="string">"attr1"</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">"val2"</span>, result.get(<span class="string">"attr2"</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">"val3"</span>, result.get(<span class="string">"attr3"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldIgnoreLeadingAndTrailingSpaces</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; result = <span class="keyword">new</span> ParameterExpression(<span class="string">" id , jdbcType =  VARCHAR,  attr1 = val1 ,  attr2 = val2 "</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">4</span>, result.size());</span><br><span class="line">    Assert.assertEquals(<span class="string">"id"</span>, result.get(<span class="string">"property"</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">"VARCHAR"</span>, result.get(<span class="string">"jdbcType"</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">"val1"</span>, result.get(<span class="string">"attr1"</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">"val2"</span>, result.get(<span class="string">"attr2"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidOldJdbcTypeFormat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> ParameterExpression(<span class="string">"id:"</span>);</span><br><span class="line">      Assert.fail();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BuilderException e) &#123;</span><br><span class="line">      Assert.assertTrue(e.getMessage().contains(<span class="string">"Parsing error in &#123;id:&#125; in position 3"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidJdbcTypeOptUsingExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> ParameterExpression(<span class="string">"(expression)+"</span>);</span><br><span class="line">      Assert.fail();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BuilderException e) &#123;</span><br><span class="line">      Assert.assertTrue(e.getMessage().contains(<span class="string">"Parsing error in &#123;(expression)+&#125; in position 12"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这上面，也就是  <code>#{}</code> 的用法了。  </p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-springboot 分析 </title>
    <url>/2019/09/10/mybatis-springboot-%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>主要是分析一个 spring-boot-starter 是怎么写的   </p>
<p>在 resource/META-INF 目录下面，要有 spring.factories 文件<br><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</span></span><br></pre></td></tr></table></figure></p>
<p>这里就是表明 MybatisAutoConfiguration 添加到 Configuration 定义<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@org</span>.springframework.context.annotation.Configuration</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; SqlSessionFactory<span class="class">.<span class="keyword">class</span>, <span class="title">SqlSessionFactoryBean</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnSingleCandidate</span>(<span class="title">DataSource</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(<span class="title">MybatisProperties</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(<span class="title">DataSourceAutoConfiguration</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MybatisAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SqlSessionFactory</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SqlSessionFactoryBean factory = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">    factory.setDataSource(dataSource);</span><br><span class="line">    factory.setVfs(SpringBootVFS<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.properties.getConfigLocation())) &#123;</span><br><span class="line">      factory.setConfigLocation(<span class="keyword">this</span>.resourceLoader.getResource(<span class="keyword">this</span>.properties.getConfigLocation()));</span><br><span class="line">    &#125;</span><br><span class="line">    applyConfiguration(factory);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.properties.getConfigurationProperties() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      factory.setConfigurationProperties(<span class="keyword">this</span>.properties.getConfigurationProperties());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="keyword">this</span>.interceptors)) &#123;</span><br><span class="line">      factory.setPlugins(<span class="keyword">this</span>.interceptors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.databaseIdProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">      factory.setDatabaseIdProvider(<span class="keyword">this</span>.databaseIdProvider);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(<span class="keyword">this</span>.properties.getTypeAliasesPackage())) &#123;</span><br><span class="line">      factory.setTypeAliasesPackage(<span class="keyword">this</span>.properties.getTypeAliasesPackage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.properties.getTypeAliasesSuperType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      factory.setTypeAliasesSuperType(<span class="keyword">this</span>.properties.getTypeAliasesSuperType());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(<span class="keyword">this</span>.properties.getTypeHandlersPackage())) &#123;</span><br><span class="line">      factory.setTypeHandlersPackage(<span class="keyword">this</span>.properties.getTypeHandlersPackage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="keyword">this</span>.properties.resolveMapperLocations())) &#123;</span><br><span class="line">      factory.setMapperLocations(<span class="keyword">this</span>.properties.resolveMapperLocations());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> factory.getObject();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyConfiguration</span><span class="params">(SqlSessionFactoryBean factory)</span> </span>&#123;</span><br><span class="line">    Configuration configuration = <span class="keyword">this</span>.properties.getConfiguration();</span><br><span class="line">    <span class="keyword">if</span> (configuration == <span class="keyword">null</span> &amp;&amp; !StringUtils.hasText(<span class="keyword">this</span>.properties.getConfigLocation())) &#123;</span><br><span class="line">      configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configuration != <span class="keyword">null</span> &amp;&amp; !CollectionUtils.isEmpty(<span class="keyword">this</span>.configurationCustomizers)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (ConfigurationCustomizer customizer : <span class="keyword">this</span>.configurationCustomizers) &#123;</span><br><span class="line">        customizer.customize(configuration);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    factory.setConfiguration(configuration);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SqlSessionTemplate</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">    ExecutorType executorType = <span class="keyword">this</span>.properties.getExecutorType();</span><br><span class="line">    <span class="keyword">if</span> (executorType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory, executorType);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里面可以，注册一些bean，譬如这里的 SqlSessionFactory 和 SqlSessionTemplate<br>还有自定义配置项 MybatisProperties，当然，自己的属性都是可以配置的<br>在类上，还有加载条件和顺序  </p>
<p>然后就没了。    </p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-spring分析</title>
    <url>/2019/09/10/mybatis-spring%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>mybatis 跟 spring 是如何集成的。    </p>
<p>跟 spring 集成主要利用了 FactoryBean<br>一般只用配置一个 SqlSessionFactory 就可以了,当然，数据库连接池是必备的<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里使用了一个 FactoryBean。<br>FactoryBean 的作用就是创建对象的，这里的 FactoryBean，就是创建 SqlSessionFactory 的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> SqlSessionFactory <span class="title">buildSqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">  Configuration configuration;</span><br><span class="line"></span><br><span class="line">  XMLConfigBuilder xmlConfigBuilder = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 如果自定义了 Configuration，那就用自定义的</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.configuration != <span class="keyword">null</span>) &#123;</span><br><span class="line">    configuration = <span class="keyword">this</span>.configuration;</span><br><span class="line">    <span class="keyword">if</span> (configuration.getVariables() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      configuration.setVariables(<span class="keyword">this</span>.configurationProperties);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.configurationProperties != <span class="keyword">null</span>) &#123;</span><br><span class="line">      configuration.getVariables().putAll(<span class="keyword">this</span>.configurationProperties);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.configLocation != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果配置了文件路径（配置文件）,就根据路径创建 Configuration</span></span><br><span class="line">    xmlConfigBuilder = <span class="keyword">new</span> XMLConfigBuilder(<span class="keyword">this</span>.configLocation.getInputStream(), <span class="keyword">null</span>, <span class="keyword">this</span>.configurationProperties);</span><br><span class="line">    configuration = xmlConfigBuilder.getConfiguration();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则，就用默认的</span></span><br><span class="line">    LOGGER.debug(() -&gt; <span class="string">"Property 'configuration' or 'configLocation' not specified, using default MyBatis Configuration"</span>);</span><br><span class="line">    configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">    <span class="comment">// 设置属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.configurationProperties != <span class="keyword">null</span>) &#123;</span><br><span class="line">      configuration.setVariables(<span class="keyword">this</span>.configurationProperties);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面就是自定义 Configuration 里面的配置了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对象工厂 返回值对象创建工厂，一般不会改这里</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.objectFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">    configuration.setObjectFactory(<span class="keyword">this</span>.objectFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里一般也不会动</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.objectWrapperFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">    configuration.setObjectWrapperFactory(<span class="keyword">this</span>.objectWrapperFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个可能会动，在不同的容器里面找资源的方式不同</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.vfs != <span class="keyword">null</span>) &#123;</span><br><span class="line">    configuration.setVfsImpl(<span class="keyword">this</span>.vfs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 别名，指定包</span></span><br><span class="line">  <span class="keyword">if</span> (hasLength(<span class="keyword">this</span>.typeAliasesPackage)) &#123;</span><br><span class="line">    String[] typeAliasPackageArray = tokenizeToStringArray(<span class="keyword">this</span>.typeAliasesPackage,</span><br><span class="line">        ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line">    <span class="keyword">for</span> (String packageToScan : typeAliasPackageArray) &#123;</span><br><span class="line">      configuration.getTypeAliasRegistry().registerAliases(packageToScan,</span><br><span class="line">              typeAliasesSuperType == null ? Object.class : typeAliasesSuperType);</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">"Scanned package: '"</span> + packageToScan + <span class="string">"' for aliases"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 别名，直接指明 class</span></span><br><span class="line">  <span class="keyword">if</span> (!isEmpty(<span class="keyword">this</span>.typeAliases)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; typeAlias : <span class="keyword">this</span>.typeAliases) &#123;</span><br><span class="line">      configuration.getTypeAliasRegistry().registerAlias(typeAlias);</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">"Registered type alias: '"</span> + typeAlias + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插件扩展</span></span><br><span class="line">  <span class="keyword">if</span> (!isEmpty(<span class="keyword">this</span>.plugins)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Interceptor plugin : <span class="keyword">this</span>.plugins) &#123;</span><br><span class="line">      configuration.addInterceptor(plugin);</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">"Registered plugin: '"</span> + plugin + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自定义类型处理（java 类型到 sql 类型），包扫描</span></span><br><span class="line">  <span class="keyword">if</span> (hasLength(<span class="keyword">this</span>.typeHandlersPackage)) &#123;</span><br><span class="line">    String[] typeHandlersPackageArray = tokenizeToStringArray(<span class="keyword">this</span>.typeHandlersPackage,</span><br><span class="line">        ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line">    <span class="keyword">for</span> (String packageToScan : typeHandlersPackageArray) &#123;</span><br><span class="line">      configuration.getTypeHandlerRegistry().register(packageToScan);</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">"Scanned package: '"</span> + packageToScan + <span class="string">"' for type handlers"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自定义类型处理（java 类型到 sql 类型），class</span></span><br><span class="line">  <span class="keyword">if</span> (!isEmpty(<span class="keyword">this</span>.typeHandlers)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (TypeHandler&lt;?&gt; typeHandler : <span class="keyword">this</span>.typeHandlers) &#123;</span><br><span class="line">      configuration.getTypeHandlerRegistry().register(typeHandler);</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">"Registered type handler: '"</span> + typeHandler + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据库标识</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.databaseIdProvider != <span class="keyword">null</span>) &#123;<span class="comment">//fix #64 set databaseId before parse mapper xmls</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      configuration.setDatabaseId(<span class="keyword">this</span>.databaseIdProvider.getDatabaseId(<span class="keyword">this</span>.dataSource));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">"Failed getting a databaseId"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    configuration.addCache(<span class="keyword">this</span>.cache);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (xmlConfigBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果需要解析（自定义配置文件路径）,就开始解析</span></span><br><span class="line">      xmlConfigBuilder.parse();</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">"Parsed configuration file: '"</span> + <span class="keyword">this</span>.configLocation + <span class="string">"'"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">"Failed to parse config resource: "</span> + <span class="keyword">this</span>.configLocation, ex);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置事务工厂，通常不会用这个的。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.transactionFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.transactionFactory = <span class="keyword">new</span> SpringManagedTransactionFactory();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置环境（数据源和事务工厂）</span></span><br><span class="line">  configuration.setEnvironment(<span class="keyword">new</span> Environment(<span class="keyword">this</span>.environment, <span class="keyword">this</span>.transactionFactory, <span class="keyword">this</span>.dataSource));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mapper 文件路径</span></span><br><span class="line">  <span class="keyword">if</span> (!isEmpty(<span class="keyword">this</span>.mapperLocations)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Resource mapperLocation : <span class="keyword">this</span>.mapperLocations) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mapperLocation == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        XMLMapperBuilder xmlMapperBuilder = <span class="keyword">new</span> XMLMapperBuilder(mapperLocation.getInputStream(),</span><br><span class="line">            configuration, mapperLocation.toString(), configuration.getSqlFragments());</span><br><span class="line">        xmlMapperBuilder.parse();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">"Failed to parse mapping resource: '"</span> + mapperLocation + <span class="string">"'"</span>, e);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">      &#125;</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">"Parsed mapper file: '"</span> + mapperLocation + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LOGGER.debug(() -&gt; <span class="string">"Property 'mapperLocations' was not specified or no matching resources found"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造 SqlSessionFactory</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.sqlSessionFactoryBuilder.build(configuration);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    afterPropertiesSet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.sqlSessionFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;? extends SqlSessionFactory&gt; getObjectType() &#123;</span><br><span class="line">  return this.sqlSessionFactory == null ? SqlSessionFactory.class : this.sqlSessionFactory.getClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面很简单，就是创建一个 SqlSessionFactory，只要在 spring 中定义这个 bean 就可以使用了。    </p>
<p>但是这只能是基本使用，获取 SqlSession，我们通常都是使用 UserMapper 这样的接口，怎么实现的呢？<br>通常我们会使用注解 @MapperScan<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(MapperScannerRegistrar.RepeatingRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">MapperScans</span> </span>&#123;</span><br><span class="line">  MapperScan[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(MapperScannerRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Repeatable</span>(<span class="title">MapperScans</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">MapperScan</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Alias for the &#123;<span class="doctag">@link</span> #basePackages()&#125; attribute. Allows for more concise</span></span><br><span class="line"><span class="comment">   * annotation declarations e.g.:</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> <span class="doctag">@MapperScan</span>("org.my.pkg")&#125; instead of &#123;<span class="doctag">@code</span> <span class="doctag">@MapperScan</span>(basePackages = "org.my.pkg"&#125;)&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> base package names</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Base packages to scan for MyBatis interfaces. Note that only interfaces</span></span><br><span class="line"><span class="comment">   * with at least one method will be registered; concrete classes will be</span></span><br><span class="line"><span class="comment">   * ignored.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> base package names for scanning mapper interface</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Type-safe alternative to &#123;<span class="doctag">@link</span> #basePackages()&#125; for specifying the packages</span></span><br><span class="line"><span class="comment">   * to scan for annotated components. The package of each class specified will be scanned.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;Consider creating a special no-op marker class or interface in each package</span></span><br><span class="line"><span class="comment">   * that serves no purpose other than being referenced by this attribute.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> classes that indicate base package for scanning mapper interface</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The &#123;<span class="doctag">@link</span> BeanNameGenerator&#125; class to be used for naming detected components</span></span><br><span class="line"><span class="comment">   * within the Spring container.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the class of &#123;<span class="doctag">@link</span> BeanNameGenerator&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Class&lt;? extends BeanNameGenerator&gt; nameGenerator() <span class="keyword">default</span> BeanNameGenerator<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * This property specifies the annotation that the scanner will search for.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * The scanner will register all interfaces in the base package that also have</span></span><br><span class="line"><span class="comment">   * the specified annotation.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * Note this can be combined with markerInterface.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the annotation that the scanner will search for</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Class&lt;? extends Annotation&gt; annotationClass() <span class="keyword">default</span> Annotation<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * This property specifies the parent that the scanner will search for.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * The scanner will register all interfaces in the base package that also have</span></span><br><span class="line"><span class="comment">   * the specified interface class as a parent.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * Note this can be combined with annotationClass.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the parent that the scanner will search for</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Class&lt;?&gt; markerInterface() <span class="keyword">default</span> Class<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Specifies which &#123;<span class="doctag">@code</span> SqlSessionTemplate&#125; to use in the case that there is</span></span><br><span class="line"><span class="comment">   * more than one in the spring context. Usually this is only needed when you</span></span><br><span class="line"><span class="comment">   * have more than one datasource.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the bean name of &#123;<span class="doctag">@code</span> SqlSessionTemplate&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">String <span class="title">sqlSessionTemplateRef</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Specifies which &#123;<span class="doctag">@code</span> SqlSessionFactory&#125; to use in the case that there is</span></span><br><span class="line"><span class="comment">   * more than one in the spring context. Usually this is only needed when you</span></span><br><span class="line"><span class="comment">   * have more than one datasource.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the bean name of &#123;<span class="doctag">@code</span> SqlSessionFactory&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">String <span class="title">sqlSessionFactoryRef</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Specifies a custom MapperFactoryBean to return a mybatis proxy as spring bean.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the class of &#123;<span class="doctag">@code</span> MapperFactoryBean&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Class&lt;? extends MapperFactoryBean&gt; factoryBean() <span class="keyword">default</span> MapperFactoryBean<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重点在于跟 spring 的结合，@Import 注解里面的类就是解析类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    AnnotationAttributes mapperScanAttrs = AnnotationAttributes</span><br><span class="line">        .fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">    <span class="keyword">if</span> (mapperScanAttrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">      registerBeanDefinitions(mapperScanAttrs, registry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里就是一个类扫描，下面全是定义规则</span></span><br><span class="line">    ClassPathMapperScanner scanner = <span class="keyword">new</span> ClassPathMapperScanner(registry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this check is needed in Spring 3.1</span></span><br><span class="line">    <span class="keyword">if</span> (resourceLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">      scanner.setResourceLoader(resourceLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(<span class="string">"annotationClass"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Annotation<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">annotationClass</span>)) </span>&#123;</span><br><span class="line">      scanner.setAnnotationClass(annotationClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; markerInterface = annoAttrs.getClass(<span class="string">"markerInterface"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Class<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">markerInterface</span>)) </span>&#123;</span><br><span class="line">      scanner.setMarkerInterface(markerInterface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass(<span class="string">"nameGenerator"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!BeanNameGenerator<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">generatorClass</span>)) </span>&#123;</span><br><span class="line">      scanner.setBeanNameGenerator(BeanUtils.instantiateClass(generatorClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass(<span class="string">"factoryBean"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!MapperFactoryBean<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">mapperFactoryBeanClass</span>)) </span>&#123;</span><br><span class="line">      scanner.setMapperFactoryBean(BeanUtils.instantiateClass(mapperFactoryBeanClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scanner.setSqlSessionTemplateBeanName(annoAttrs.getString(<span class="string">"sqlSessionTemplateRef"</span>));</span><br><span class="line">    scanner.setSqlSessionFactoryBeanName(annoAttrs.getString(<span class="string">"sqlSessionFactoryRef"</span>));</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; basePackages = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    basePackages.addAll(</span><br><span class="line">        Arrays.stream(annoAttrs.getStringArray(<span class="string">"value"</span>))</span><br><span class="line">            .filter(StringUtils::hasText)</span><br><span class="line">            .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">    basePackages.addAll(</span><br><span class="line">        Arrays.stream(annoAttrs.getStringArray(<span class="string">"basePackages"</span>))</span><br><span class="line">            .filter(StringUtils::hasText)</span><br><span class="line">            .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">    basePackages.addAll(</span><br><span class="line">        Arrays.stream(annoAttrs.getClassArray(<span class="string">"basePackageClasses"</span>))</span><br><span class="line">            .map(ClassUtils::getPackageName)</span><br><span class="line">            .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">    scanner.registerFilters();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里开始扫描，注册 BeanDefinition (Mapper 接口)</span></span><br><span class="line">    scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看看是怎么注册的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">  Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">super</span>.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">    LOGGER.warn(() -&gt; <span class="string">"No MyBatis mapper was found in '"</span> + Arrays.toString(basePackages) + <span class="string">"' package. Please check your configuration."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    processBeanDefinitions(beanDefinitions);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 实际上这里注册的是 Mapper 接口，使用的是 FactoryBean  MapperFactoryBean</span></span><br><span class="line">  GenericBeanDefinition definition;</span><br><span class="line">  <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">    definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">    String beanClassName = definition.getBeanClassName();</span><br><span class="line">    LOGGER.debug(() -&gt; <span class="string">"Creating MapperFactoryBean with name '"</span> + holder.getBeanName()</span><br><span class="line">        + <span class="string">"' and '"</span> + beanClassName + <span class="string">"' mapperInterface"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the mapper interface is the original class of the bean</span></span><br><span class="line">    <span class="comment">// but, the actual class of the bean is MapperFactoryBean</span></span><br><span class="line">    definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); <span class="comment">// issue #59</span></span><br><span class="line">    <span class="comment">// 这里设置 FactoryBean</span></span><br><span class="line">    definition.setBeanClass(<span class="keyword">this</span>.mapperFactoryBean.getClass());</span><br><span class="line"></span><br><span class="line">    definition.getPropertyValues().add(<span class="string">"addToConfig"</span>, <span class="keyword">this</span>.addToConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面就是设置 SqlSessionFactory 的依赖，通常没有，使用默认的</span></span><br><span class="line">    <span class="keyword">boolean</span> explicitFactoryUsed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionFactoryBeanName)) &#123;</span><br><span class="line">      definition.getPropertyValues().add(<span class="string">"sqlSessionFactory"</span>, <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionFactoryBeanName));</span><br><span class="line">      explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">      definition.getPropertyValues().add(<span class="string">"sqlSessionFactory"</span>, <span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">      explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionTemplateBeanName)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">        LOGGER.warn(() -&gt; <span class="string">"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      definition.getPropertyValues().add(<span class="string">"sqlSessionTemplate"</span>, <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionTemplateBeanName));</span><br><span class="line">      explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionTemplate != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">        LOGGER.warn(() -&gt; <span class="string">"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      definition.getPropertyValues().add(<span class="string">"sqlSessionTemplate"</span>, <span class="keyword">this</span>.sqlSessionTemplate);</span><br><span class="line">      explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有明确指定 SqlSessionFactory ，那就自动依赖</span></span><br><span class="line">    <span class="keyword">if</span> (!explicitFactoryUsed) &#123;</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">"Enabling autowire by type for MapperFactoryBean with name '"</span> + holder.getBeanName() + <span class="string">"'."</span>);</span><br><span class="line">      definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以清楚的看到，使用的还是 FactoryBean<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkDaoConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.checkDaoConfig();</span><br><span class="line"></span><br><span class="line">  notNull(<span class="keyword">this</span>.mapperInterface, <span class="string">"Property 'mapperInterface' is required"</span>);</span><br><span class="line"></span><br><span class="line">  Configuration configuration = getSqlSession().getConfiguration();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.addToConfig &amp;&amp; !configuration.hasMapper(<span class="keyword">this</span>.mapperInterface)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 注册 Mapper（注解有效）</span></span><br><span class="line">      configuration.addMapper(<span class="keyword">this</span>.mapperInterface);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      logger.error(<span class="string">"Error while adding the mapper '"</span> + <span class="keyword">this</span>.mapperInterface + <span class="string">"' to configuration."</span>, e);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// 从 sqlSession 获取</span></span><br><span class="line">  <span class="keyword">return</span> getSqlSession().getMapper(<span class="keyword">this</span>.mapperInterface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个 FactoryBean ，只是在 Configuration 里面注册该接口，然后，获取的时候从 sqlSession 里面获取（还是基于 mybatis 自己的动态代理流程）   </p>
<p>拥有同样功能的类还有 MapperScannerConfigurer<br>这是一个 BeanDefinitionRegistryPostProcessor 接口实现( sprng 的一种扩展方式，注册 BeanDefinition)<br>同样的逻辑，还是使用 ClassPathMapperScanner<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.processPropertyPlaceHolders) &#123;</span><br><span class="line">    processPropertyPlaceHolders();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ClassPathMapperScanner scanner = <span class="keyword">new</span> ClassPathMapperScanner(registry);</span><br><span class="line">  scanner.setAddToConfig(<span class="keyword">this</span>.addToConfig);</span><br><span class="line">  scanner.setAnnotationClass(<span class="keyword">this</span>.annotationClass);</span><br><span class="line">  scanner.setMarkerInterface(<span class="keyword">this</span>.markerInterface);</span><br><span class="line">  scanner.setSqlSessionFactory(<span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">  scanner.setSqlSessionTemplate(<span class="keyword">this</span>.sqlSessionTemplate);</span><br><span class="line">  scanner.setSqlSessionFactoryBeanName(<span class="keyword">this</span>.sqlSessionFactoryBeanName);</span><br><span class="line">  scanner.setSqlSessionTemplateBeanName(<span class="keyword">this</span>.sqlSessionTemplateBeanName);</span><br><span class="line">  scanner.setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">  scanner.setBeanNameGenerator(<span class="keyword">this</span>.nameGenerator);</span><br><span class="line">  scanner.registerFilters();</span><br><span class="line">  scanner.scan(StringUtils.tokenizeToStringArray(<span class="keyword">this</span>.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续，还可以xml形式进行配置（mybatis:scan）<br>通过扩展spring 的xml 解析来实现<br>还是使用的 ClassPathMapperScanner<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个类需要注册 http\://mybatis.org/schema/mybatis-spring=org.mybatis.spring.config.NamespaceHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"scan"</span>, <span class="keyword">new</span> MapperScannerBeanDefinitionParser());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperScannerBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ATTRIBUTE_BASE_PACKAGE = <span class="string">"base-package"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ATTRIBUTE_ANNOTATION = <span class="string">"annotation"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ATTRIBUTE_MARKER_INTERFACE = <span class="string">"marker-interface"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ATTRIBUTE_NAME_GENERATOR = <span class="string">"name-generator"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ATTRIBUTE_TEMPLATE_REF = <span class="string">"template-ref"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ATTRIBUTE_FACTORY_REF = <span class="string">"factory-ref"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * xml 解析流程</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    ClassPathMapperScanner scanner = <span class="keyword">new</span> ClassPathMapperScanner(parserContext.getRegistry());</span><br><span class="line">    ClassLoader classLoader = scanner.getResourceLoader().getClassLoader();</span><br><span class="line">    XmlReaderContext readerContext = parserContext.getReaderContext();</span><br><span class="line">    scanner.setResourceLoader(readerContext.getResourceLoader());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      String annotationClassName = element.getAttribute(ATTRIBUTE_ANNOTATION);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(annotationClassName)) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Class&lt;? extends Annotation&gt; markerInterface = (Class&lt;? extends Annotation&gt;) classLoader.loadClass(annotationClassName);</span><br><span class="line">        scanner.setAnnotationClass(markerInterface);</span><br><span class="line">      &#125;</span><br><span class="line">      String markerInterfaceClassName = element.getAttribute(ATTRIBUTE_MARKER_INTERFACE);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(markerInterfaceClassName)) &#123;</span><br><span class="line">        Class&lt;?&gt; markerInterface = classLoader.loadClass(markerInterfaceClassName);</span><br><span class="line">        scanner.setMarkerInterface(markerInterface);</span><br><span class="line">      &#125;</span><br><span class="line">      String nameGeneratorClassName = element.getAttribute(ATTRIBUTE_NAME_GENERATOR);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(nameGeneratorClassName)) &#123;</span><br><span class="line">        Class&lt;?&gt; nameGeneratorClass = classLoader.loadClass(nameGeneratorClassName);</span><br><span class="line">        BeanNameGenerator nameGenerator = BeanUtils.instantiateClass(nameGeneratorClass, BeanNameGenerator<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        scanner.setBeanNameGenerator(nameGenerator);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      readerContext.error(ex.getMessage(), readerContext.extractSource(element), ex.getCause());</span><br><span class="line">    &#125;</span><br><span class="line">    String sqlSessionTemplateBeanName = element.getAttribute(ATTRIBUTE_TEMPLATE_REF);</span><br><span class="line">    scanner.setSqlSessionTemplateBeanName(sqlSessionTemplateBeanName);</span><br><span class="line">    String sqlSessionFactoryBeanName = element.getAttribute(ATTRIBUTE_FACTORY_REF);</span><br><span class="line">    scanner.setSqlSessionFactoryBeanName(sqlSessionFactoryBeanName);</span><br><span class="line">    scanner.registerFilters();</span><br><span class="line">    String basePackage = element.getAttribute(ATTRIBUTE_BASE_PACKAGE);</span><br><span class="line">    scanner.scan(StringUtils.tokenizeToStringArray(basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们之前看到 MapperFactoryBean 继承 SqlSessionDaoSupport<br>SqlSessionDaoSupport 这个类是用来提供 SqlSession 的<br>继承自 DaoSupport，<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">extends</span> <span class="title">DaoSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> SqlSessionTemplate sqlSessionTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Set MyBatis SqlSessionFactory to be used by this DAO.</span></span><br><span class="line"><span class="comment">   * Will automatically create SqlSessionTemplate for the given SqlSessionFactory.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> sqlSessionFactory a factory of SqlSession</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionTemplate == <span class="keyword">null</span> || sqlSessionFactory != <span class="keyword">this</span>.sqlSessionTemplate.getSqlSessionFactory()) &#123;</span><br><span class="line">      <span class="comment">// 创建 SqlSessionTemplate</span></span><br><span class="line">      <span class="keyword">this</span>.sqlSessionTemplate = createSqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create a SqlSessionTemplate for the given SqlSessionFactory.</span></span><br><span class="line"><span class="comment">   * Only invoked if populating the DAO with a SqlSessionFactory reference!</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;Can be overridden in subclasses to provide a SqlSessionTemplate instance</span></span><br><span class="line"><span class="comment">   * with different configuration, or a custom SqlSessionTemplate subclass.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> sqlSessionFactory the MyBatis SqlSessionFactory to create a SqlSessionTemplate for</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the new SqlSessionTemplate instance</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span> #setSqlSessionFactory</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> SqlSessionTemplate <span class="title">createSqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return the MyBatis SqlSessionFactory used by this DAO.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> a factory of SqlSession</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SqlSessionFactory <span class="title">getSqlSessionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.sqlSessionTemplate != <span class="keyword">null</span> ? <span class="keyword">this</span>.sqlSessionTemplate.getSqlSessionFactory() : <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Set the SqlSessionTemplate for this DAO explicitly,</span></span><br><span class="line"><span class="comment">   * as an alternative to specifying a SqlSessionFactory.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> sqlSessionTemplate a template of SqlSession</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span> #setSqlSessionFactory</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSessionTemplate</span><span class="params">(SqlSessionTemplate sqlSessionTemplate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sqlSessionTemplate = sqlSessionTemplate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Users should use this method to get a SqlSession to call its statement methods</span></span><br><span class="line"><span class="comment">   * This is SqlSession is managed by spring. Users should not commit/rollback/close it</span></span><br><span class="line"><span class="comment">   * because it will be automatically done.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> Spring managed thread safe SqlSession</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sqlSessionTemplate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return the SqlSessionTemplate for this DAO,</span></span><br><span class="line"><span class="comment">   * pre-initialized with the SessionFactory or set explicitly.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;&lt;b&gt;Note: The returned SqlSessionTemplate is a shared instance.&lt;/b&gt;</span></span><br><span class="line"><span class="comment">   * You may introspect its configuration, but not modify the configuration</span></span><br><span class="line"><span class="comment">   * (other than from within an &#123;<span class="doctag">@link</span> #initDao&#125; implementation).</span></span><br><span class="line"><span class="comment">   * Consider creating a custom SqlSessionTemplate instance via</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> new SqlSessionTemplate(getSqlSessionFactory())&#125;, in which case</span></span><br><span class="line"><span class="comment">   * you're allowed to customize the settings on the resulting instance.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> a template of SqlSession</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">getSqlSessionTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sqlSessionTemplate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkDaoConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    notNull(<span class="keyword">this</span>.sqlSessionTemplate, <span class="string">"Property 'sqlSessionFactory' or 'sqlSessionTemplate' are required"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，在 setSqlSessionFactory 的时候创建 SqlSessionTemplate，实现了 SqlSession，是线程安全的，而且关联的 spring 的事务管理<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,</span></span></span><br><span class="line"><span class="function"><span class="params">    PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  notNull(sqlSessionFactory, <span class="string">"Property 'sqlSessionFactory' is required"</span>);</span><br><span class="line">  notNull(executorType, <span class="string">"Property 'executorType' is required"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">  <span class="keyword">this</span>.executorType = executorType;</span><br><span class="line">  <span class="keyword">this</span>.exceptionTranslator = exceptionTranslator;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重点在这里，动态代理，代理 SqlSession 接口，使用 SqlSessionInterceptor</span></span><br><span class="line">  <span class="comment">// 下面所有的操作都是代理做的</span></span><br><span class="line">  <span class="keyword">this</span>.sqlSessionProxy = (SqlSession) newProxyInstance(</span><br><span class="line">      SqlSessionFactory<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">      new Class[] &#123; SqlSession.class &#125;,</span><br><span class="line">      <span class="keyword">new</span> SqlSessionInterceptor());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionInterceptor</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 SqlSession 对象，重点在这里</span></span><br><span class="line">    SqlSession sqlSession = getSqlSession(</span><br><span class="line">        SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory,</span><br><span class="line">        SqlSessionTemplate.<span class="keyword">this</span>.executorType,</span><br><span class="line">        SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 调用，没的说</span></span><br><span class="line">      Object result = method.invoke(sqlSession, args);</span><br><span class="line">      <span class="comment">// 判断当前 sqlSession 是否使用了事务（spring 的）</span></span><br><span class="line">      <span class="keyword">if</span> (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory)) &#123;</span><br><span class="line">        <span class="comment">// force commit even on non-dirty sessions because some databases require</span></span><br><span class="line">        <span class="comment">// a commit/rollback before calling close()</span></span><br><span class="line">        <span class="comment">// 使用了，就提交（注意，不是真提交，还得看内部处理，事务是 SpringManagedTransaction 管理的）</span></span><br><span class="line">        sqlSession.commit(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      Throwable unwrapped = unwrapThrowable(t);</span><br><span class="line">      <span class="comment">// 如果是 mybatis 的数据库操作异常</span></span><br><span class="line">      <span class="keyword">if</span> (SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator != <span class="keyword">null</span> &amp;&amp; unwrapped <span class="keyword">instanceof</span> PersistenceException) &#123;</span><br><span class="line">        <span class="comment">// 先关闭连接</span></span><br><span class="line">        <span class="comment">// release the connection to avoid a deadlock if the translator is no loaded. See issue #22</span></span><br><span class="line">        closeSqlSession(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">        <span class="comment">// 设置为null，防止 finally 里面又关一遍</span></span><br><span class="line">        sqlSession = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 包装一下，变成 spring 里面的异常</span></span><br><span class="line">        Throwable translated = SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator.translateExceptionIfPossible((PersistenceException) unwrapped);</span><br><span class="line">        <span class="keyword">if</span> (translated != <span class="keyword">null</span>) &#123;</span><br><span class="line">          unwrapped = translated;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> unwrapped;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 关闭 session</span></span><br><span class="line">      <span class="keyword">if</span> (sqlSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">        closeSqlSession(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 getSqlSession 是重点方法，事务相关<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED);</span><br><span class="line">    notNull(executorType, NO_EXECUTOR_TYPE_SPECIFIED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里 TransactionSynchronizationManager 是 spring 里面的类</span></span><br><span class="line">    <span class="comment">// 从 spring 的事务管理里面获取一个 sqlsession，如果需要，就创建一个</span></span><br><span class="line">    SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);</span><br><span class="line">    <span class="comment">// 获取 session，可能为null，如果不为null，代表改线程前面已经有方法开始使用 session了</span></span><br><span class="line">    SqlSession session = sessionHolder(executorType, holder);</span><br><span class="line">    <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> session;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里创建一个 session 出来</span></span><br><span class="line">    LOGGER.debug(() -&gt; <span class="string">"Creating a new SqlSession"</span>);</span><br><span class="line">    session = sessionFactory.openSession(executorType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册一下（如果没开事务，或者方法没用事务，没啥影响）</span></span><br><span class="line">    registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SqlSession <span class="title">sessionHolder</span><span class="params">(ExecutorType executorType, SqlSessionHolder holder)</span> </span>&#123;</span><br><span class="line">    SqlSession session = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 这里处理事务</span></span><br><span class="line">    <span class="keyword">if</span> (holder != <span class="keyword">null</span> &amp;&amp; holder.isSynchronizedWithTransaction()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (holder.getExecutorType() != executorType) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TransientDataAccessResourceException(<span class="string">"Cannot change the ExecutorType when there is an existing transaction"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 引用计数 +1</span></span><br><span class="line">      holder.requested();</span><br><span class="line"></span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">"Fetched SqlSession ["</span> + holder.getSqlSession() + <span class="string">"] from current transaction"</span>);</span><br><span class="line">      session = holder.getSqlSession();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerSessionHolder</span><span class="params">(SqlSessionFactory sessionFactory, ExecutorType executorType,</span></span></span><br><span class="line"><span class="function"><span class="params">      PersistenceExceptionTranslator exceptionTranslator, SqlSession session)</span> </span>&#123;</span><br><span class="line">    SqlSessionHolder holder;</span><br><span class="line">    <span class="comment">// 看是否有事务</span></span><br><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">      Environment environment = sessionFactory.getConfiguration().getEnvironment();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (environment.getTransactionFactory() <span class="keyword">instanceof</span> SpringManagedTransactionFactory) &#123;</span><br><span class="line">        <span class="comment">// 如果是 SpringManagedTransactionFactory （mybatis 默认的事务管理器）</span></span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">"Registering transaction synchronization for SqlSession ["</span> + session + <span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// holder 继承 ResourceHolderSupport，自身没啥屁用，主要是要跟 spring 集成</span></span><br><span class="line">        holder = <span class="keyword">new</span> SqlSessionHolder(session, executorType, exceptionTranslator);</span><br><span class="line">        <span class="comment">// 就是添加到线程上下文里面，一个 sessionFactory （数据源） 对应一个key</span></span><br><span class="line">        TransactionSynchronizationManager.bindResource(sessionFactory, holder);</span><br><span class="line">        <span class="comment">// 这个注册事务适配器，这里是关键</span></span><br><span class="line">        TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> SqlSessionSynchronization(holder, sessionFactory));</span><br><span class="line">        <span class="comment">// 标记为有事务</span></span><br><span class="line">        holder.setSynchronizedWithTransaction(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 应用计数 +1</span></span><br><span class="line">        holder.requested();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (TransactionSynchronizationManager.getResource(environment.getDataSource()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 没使用事务，啥都不做</span></span><br><span class="line">          LOGGER.debug(() -&gt; <span class="string">"SqlSession ["</span> + session + <span class="string">"] was not registered for synchronization because DataSource is not transactional"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 也就是说，必须要是 SpringManagedTransactionFactory</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> TransientDataAccessResourceException(</span><br><span class="line">              <span class="string">"SqlSessionFactory must be using a SpringManagedTransactionFactory in order to use Spring transaction synchronization"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">"SqlSession ["</span> + session + <span class="string">"] was not registered for synchronization because synchronization is not active"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeSqlSession</span><span class="params">(SqlSession session, SqlSessionFactory sessionFactory)</span> </span>&#123;</span><br><span class="line">    notNull(session, NO_SQL_SESSION_SPECIFIED);</span><br><span class="line">    notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED);</span><br><span class="line"></span><br><span class="line">    SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);</span><br><span class="line">    <span class="keyword">if</span> ((holder != <span class="keyword">null</span>) &amp;&amp; (holder.getSqlSession() == session)) &#123;</span><br><span class="line">      <span class="comment">// 事务处理，released，也就是引用计数 -1</span></span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">"Releasing transactional SqlSession ["</span> + session + <span class="string">"]"</span>);</span><br><span class="line">      holder.released();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没事务，直接关闭</span></span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">"Closing non transactional SqlSession ["</span> + session + <span class="string">"]"</span>);</span><br><span class="line">      session.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里面 SqlSessionSynchronization 注册了事务回调<br>列一下里面的相关方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.holderActive) &#123;</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">"Transaction synchronization suspending SqlSession ["</span> + <span class="keyword">this</span>.holder.getSqlSession() + <span class="string">"]"</span>);</span><br><span class="line">        <span class="comment">// unbindResource 就是线程上下文里面移除对应的key的内容</span></span><br><span class="line">        TransactionSynchronizationManager.unbindResource(<span class="keyword">this</span>.sessionFactory);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.holderActive) &#123;</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">"Transaction synchronization resuming SqlSession ["</span> + <span class="keyword">this</span>.holder.getSqlSession() + <span class="string">"]"</span>);</span><br><span class="line">        TransactionSynchronizationManager.bindResource(<span class="keyword">this</span>.sessionFactory, <span class="keyword">this</span>.holder);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeCommit</span><span class="params">(<span class="keyword">boolean</span> readOnly)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Connection commit or rollback will be handled by ConnectionSynchronization or</span></span><br><span class="line">      <span class="comment">// DataSourceTransactionManager.</span></span><br><span class="line">      <span class="comment">// But, do cleanup the SqlSession / Executor, including flushing BATCH statements so</span></span><br><span class="line">      <span class="comment">// they are actually executed.</span></span><br><span class="line">      <span class="comment">// SpringManagedTransaction will no-op the commit over the jdbc connection</span></span><br><span class="line">      <span class="comment">// TODO This updates 2nd level caches but the tx may be rolledback later on!</span></span><br><span class="line">      <span class="comment">// 只有事务开启才处理</span></span><br><span class="line">      <span class="keyword">if</span> (TransactionSynchronizationManager.isActualTransactionActive()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          LOGGER.debug(() -&gt; <span class="string">"Transaction synchronization committing SqlSession ["</span> + <span class="keyword">this</span>.holder.getSqlSession() + <span class="string">"]"</span>);</span><br><span class="line">          <span class="comment">// 事务提交（还是得看 具体的事务，这里只是触发提交）</span></span><br><span class="line">          <span class="keyword">this</span>.holder.getSqlSession().commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PersistenceException p) &#123;</span><br><span class="line">          <span class="comment">// 异常处理</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.holder.getPersistenceExceptionTranslator() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            DataAccessException translated = <span class="keyword">this</span>.holder</span><br><span class="line">                .getPersistenceExceptionTranslator()</span><br><span class="line">                .translateExceptionIfPossible(p);</span><br><span class="line">            <span class="keyword">if</span> (translated != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> translated;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">throw</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Issue #18 Close SqlSession and deregister it now</span></span><br><span class="line">      <span class="comment">// because afterCompletion may be called from a different thread</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.holder.isOpen()) &#123;</span><br><span class="line">        <span class="comment">// 如果引用计数 == 0 了，可以关闭 session 了</span></span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">"Transaction synchronization deregistering SqlSession ["</span> + <span class="keyword">this</span>.holder.getSqlSession() + <span class="string">"]"</span>);</span><br><span class="line">        <span class="comment">// 移除</span></span><br><span class="line">        TransactionSynchronizationManager.unbindResource(sessionFactory);</span><br><span class="line">        <span class="keyword">this</span>.holderActive = <span class="keyword">false</span>;</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">"Transaction synchronization closing SqlSession ["</span> + <span class="keyword">this</span>.holder.getSqlSession() + <span class="string">"]"</span>);</span><br><span class="line">        <span class="keyword">this</span>.holder.getSqlSession().close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(<span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.holderActive) &#123;</span><br><span class="line">        <span class="comment">// afterCompletion may have been called from a different thread</span></span><br><span class="line">        <span class="comment">// so avoid failing if there is nothing in this one</span></span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">"Transaction synchronization deregistering SqlSession ["</span> + <span class="keyword">this</span>.holder.getSqlSession() + <span class="string">"]"</span>);</span><br><span class="line">        TransactionSynchronizationManager.unbindResourceIfPossible(sessionFactory);</span><br><span class="line">        <span class="keyword">this</span>.holderActive = <span class="keyword">false</span>;</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">"Transaction synchronization closing SqlSession ["</span> + <span class="keyword">this</span>.holder.getSqlSession() + <span class="string">"]"</span>);</span><br><span class="line">        <span class="keyword">this</span>.holder.getSqlSession().close();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.holder.reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>最后瞅瞅事务相关类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 spring 的事务时候用的 事务管理工程</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> SpringManagedTransaction&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hunter Presnall</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringManagedTransactionFactory</span> <span class="keyword">implements</span> <span class="title">TransactionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Transaction <span class="title">newTransaction</span><span class="params">(DataSource dataSource, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SpringManagedTransaction(dataSource);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Transaction <span class="title">newTransaction</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"New Spring transactions require a DataSource"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties props)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// not needed in this version</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务管理</span></span><br><span class="line"><span class="comment"> * 重点在于 获取连接 和 释放连接 调用 DataSourceUtils 的方法，这样就可以将事务托管给 spring了？</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> SpringManagedTransaction&#125; handles the lifecycle of a JDBC connection.</span></span><br><span class="line"><span class="comment"> * It retrieves a connection from Spring's transaction manager and returns it back to it</span></span><br><span class="line"><span class="comment"> * when it is no longer needed.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If Spring's transaction handling is active it will no-op all commit/rollback/close calls</span></span><br><span class="line"><span class="comment"> * assuming that the Spring transaction manager will do the job.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If it is not it will behave like &#123;<span class="doctag">@code</span> JdbcTransaction&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hunter Presnall</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringManagedTransaction</span> <span class="keyword">implements</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SpringManagedTransaction<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Connection connection;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isConnectionTransactional;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> autoCommit;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SpringManagedTransaction</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    notNull(dataSource, <span class="string">"No DataSource specified"</span>);</span><br><span class="line">    <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">      openConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.connection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Gets a connection from Spring transaction manager and discovers if this</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> Transaction&#125; should manage connection or let it to Spring.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * It also reads autocommit setting because when using Spring Transaction MyBatis</span></span><br><span class="line"><span class="comment">   * thinks that autocommit is always false and will always call commit/rollback</span></span><br><span class="line"><span class="comment">   * so we need to no-op that calls.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.connection = DataSourceUtils.getConnection(<span class="keyword">this</span>.dataSource);</span><br><span class="line">    <span class="keyword">this</span>.autoCommit = <span class="keyword">this</span>.connection.getAutoCommit();</span><br><span class="line">    <span class="keyword">this</span>.isConnectionTransactional = DataSourceUtils.isConnectionTransactional(<span class="keyword">this</span>.connection, <span class="keyword">this</span>.dataSource);</span><br><span class="line"></span><br><span class="line">    LOGGER.debug(() -&gt;</span><br><span class="line">        <span class="string">"JDBC Connection ["</span></span><br><span class="line">            + <span class="keyword">this</span>.connection</span><br><span class="line">            + <span class="string">"] will"</span></span><br><span class="line">            + (<span class="keyword">this</span>.isConnectionTransactional ? <span class="string">" "</span> : <span class="string">" not "</span>)</span><br><span class="line">            + <span class="string">"be managed by Spring"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.connection != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.isConnectionTransactional &amp;&amp; !<span class="keyword">this</span>.autoCommit) &#123;</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">"Committing JDBC Connection ["</span> + <span class="keyword">this</span>.connection + <span class="string">"]"</span>);</span><br><span class="line">      <span class="keyword">this</span>.connection.commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.connection != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.isConnectionTransactional &amp;&amp; !<span class="keyword">this</span>.autoCommit) &#123;</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">"Rolling back JDBC Connection ["</span> + <span class="keyword">this</span>.connection + <span class="string">"]"</span>);</span><br><span class="line">      <span class="keyword">this</span>.connection.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    DataSourceUtils.releaseConnection(<span class="keyword">this</span>.connection, <span class="keyword">this</span>.dataSource);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">getTimeout</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ConnectionHolder holder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);</span><br><span class="line">    <span class="keyword">if</span> (holder != <span class="keyword">null</span> &amp;&amp; holder.hasTimeout()) &#123;</span><br><span class="line">      <span class="keyword">return</span> holder.getTimeToLiveInSeconds();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis 执行分析</title>
    <url>/2019/09/09/mybatis-%E6%89%A7%E8%A1%8C%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>sql 执行时通过 SqlSession 来操作的，而 SqlSession 是通过 SqlSessionFactory 获取的。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Blog blog = (Blog) session.selectOne(<span class="string">"org.mybatis.example.BlogMapper.selectBlog"</span>, <span class="number">101</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  session.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  Blog blog = mapper.selectBlog(<span class="number">101</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="openSession"><a href="#openSession" class="headerlink" title="openSession"></a>openSession</h2><p>我们已经知道，内部使用的是默认的 DefaultSqlSessionFactory 实现<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// openSession 方法，主要调用的是这个（在与 spring 集成的时候，实际业务开发不直接用 SqlSession）</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> openSessionFromConnection(configuration.getDefaultExecutorType(), connection);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>有从数据源获取和直接使用连接获取。<br>其中 executorType<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ExecutorType &#123;</span><br><span class="line">  SIMPLE, REUSE, BATCH</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对应的是不同的 Executor 实现，默认的是 Simple， REUSE 代表服用 Statement（这里的 Statement 是 JDBC 里面的），只要连接没断开， BATCH 代表批处理  </p>
<p>具体分析 <code>openSessionFromDataSource</code> 方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 数据源 获取</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 环境配置(事务和数据源)</span></span><br><span class="line">      <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">      <span class="comment">// 获取事务工厂，如果没有配置就用默认的</span></span><br><span class="line">      <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      <span class="comment">// 新建事务类（管理事务的 Transaction ）</span></span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      <span class="comment">// 构造执行器（根据 type 分为 batch，reuse，simple）</span></span><br><span class="line">      <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">      <span class="comment">// 构造默认的 SqlSession 实现</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的 <code>TransactionIsolationLevel</code> 代表事务等级<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> TransactionIsolationLevel &#123;</span><br><span class="line">  NONE(Connection.TRANSACTION_NONE),</span><br><span class="line">  READ_COMMITTED(Connection.TRANSACTION_READ_COMMITTED),</span><br><span class="line">  READ_UNCOMMITTED(Connection.TRANSACTION_READ_UNCOMMITTED),</span><br><span class="line">  REPEATABLE_READ(Connection.TRANSACTION_REPEATABLE_READ),</span><br><span class="line">  SERIALIZABLE(Connection.TRANSACTION_SERIALIZABLE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">TransactionIsolationLevel</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.level = level;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里补充一下事务等级的含义  </p>
<ol>
<li>READ-UNCOMMITED(读取未提交内容)</li>
</ol>
<p>看名字就知道了，所以事务都可以看到其他未提交事务的执行结果，此隔离级别很少使用。</p>
<ol>
<li>READ-COMMITED（读取提交内容）</li>
</ol>
<p>这个大多数数据库系统默认的隔离级别，但不是MySQL默认的隔离级别。<br>定义：一个事务从开始到提交前所做的任何修改都是不可见的，事务只能看到已经提交事务所做的改变。<br>会有不可重复读的问题。<br>也就是一个事务同一条查询语句查询了两次，在这两次查询期间，有其他事务修改了这些数据，所以，这两次查询结果在同一个事务中是不一样的。</p>
<ol>
<li>REPEATABLE-READ(可重复读)</li>
</ol>
<p>这是MySQL的默认事务隔离级别。能确保同一事务的多个实例在缤纷发读取数据时，会看到同样的数据行。<br>但是会有幻读的问题。<br>在一次事务的两次查询中数据笔数不一致。<br>第一个事务对表的全部数据进行修改，同事第二个事务插入了一行新的数据，那么就会发生第一个事务结束后发现表中还有没有修改的数据行。</p>
<ol>
<li>Seraializable(可串行化)</li>
</ol>
<p>这是最高隔离界别，通过强制事务排序，使之不可能互相冲突，从而解决幻读，简言之，就是在每个读取的数据行上加上共享锁实现，这个级别可能会导致大量超时现象和锁竞争。  </p>
<p>再来看代码</p>
<ol>
<li><p>先从环境 Environment 里面获取配置的事务工厂 TransactionFactory，默认是 ManagedTransactionFactory<br>也就是交给外部容器管理，这种模式下，事务是不会提交的。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取事物管理实现（之所以有这个，是为了方便与其他容器集成）</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> TransactionFactory <span class="title">getTransactionFactoryFromEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (environment == <span class="keyword">null</span> || environment.getTransactionFactory() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ManagedTransactionFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> environment.getTransactionFactory();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建事务管理类 Transaction<br>这里以 ManagedTransactionFactory 为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Transaction <span class="title">newTransaction</span><span class="params">(DataSource ds, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Silently ignores autocommit and isolation level, as managed transactions are entirely</span></span><br><span class="line">    <span class="comment">// controlled by an external manager.  It's silently ignored so that</span></span><br><span class="line">    <span class="comment">// code remains portable between managed and unmanaged configurations.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ManagedTransaction(ds, level, closeConnection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ManagedTransaction</span><span class="params">(DataSource ds, TransactionIsolationLevel level, <span class="keyword">boolean</span> closeConnection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = ds;</span><br><span class="line">    <span class="keyword">this</span>.level = level;</span><br><span class="line">    <span class="keyword">this</span>.closeConnection = closeConnection;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建执行器 Executor, 不特殊配置默认是 SimpleExecutor，如果使用了二级缓存，会用 CachingExecutor 装饰，另外，扩展插件也会在这里添加    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们后面详细分析 <code>executor = (Executor) interceptorChain.pluginAll(executor);</code> 这一行   </p>
</li>
<li><p>构建 SqlSession 实例 DefaultSqlSession   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> autoCommit;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> dirty;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Cursor&lt;?&gt;&gt; cursorList;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSession</span><span class="params">(Configuration configuration, Executor executor, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.autoCommit = autoCommit;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>获取到 SqlSession 实例后，就可以调用 selectList （selectOne 是 selectList 的特例），游标查询通常也用的少，增删改都是 update 操作。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Popular vote was to return null on 0 results and throw exception on too many.</span></span><br><span class="line">    List&lt;T&gt; list = <span class="keyword">this</span>.&lt;T&gt;selectList(statement, parameter);</span><br><span class="line">    <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TooManyResultsException(<span class="string">"Expected one result (or null) to be returned by selectOne(), but found: "</span> + list.size());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取对应的 MappedStatement ，就是根据key（namespace） 对应的 sql 已经其他相关信息</span></span><br><span class="line">      <span class="comment">// 这里的 MappedStatement 是有 xml 定义的</span></span><br><span class="line">      MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">      <span class="comment">// 然后执行，用 map 包装集合类（collection，list，array）</span></span><br><span class="line">      <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * insert update delete 最终执行的地方</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> statement Unique identifier matching the statement to execute.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> parameter A parameter object to pass to the statement.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      dirty = <span class="keyword">true</span>;</span><br><span class="line">      MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">      <span class="keyword">return</span> executor.update(ms, wrapCollection(parameter));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error updating database.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 这里是查询语句+自定义处理返回的 查询实现</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> statement Unique identifier matching the statement to use.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> parameter</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rowBounds RowBound instance to limit the query results</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> handler ResultHandler that will handle each retrieved row</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">      executor.query(ms, wrapCollection(parameter), rowBounds, handler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中重点是 selectList 和 update 参数都是 statement（namespace.id） 加上给的sql参数<br>可以看到，实际的执行时 executor。这个 executor 是构造 SqlSession 的时候创建的，默认 SimpleExecutor，可能会被 CacheExecutor 装饰，作用就是查询添加缓存，<br>增删改删除缓存，这是默认行为，可以修改。<br>我们先不看缓存  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取sql</span></span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">    <span class="comment">// cache key</span></span><br><span class="line">    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 记录执行信息</span></span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing a query"</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      queryStack++;</span><br><span class="line">      <span class="comment">// 如果有自定义 resultHandler ，那就走不了缓存了（一级缓存）</span></span><br><span class="line">      list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里是处理 CALLABLE 存储过程的，一般用不着</span></span><br><span class="line">        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存没取到，就从数据库里面获取</span></span><br><span class="line">        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      queryStack--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 需要延时加载的，全部加载</span></span><br><span class="line">      <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">        deferredLoad.load();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// issue #601</span></span><br><span class="line">      deferredLoads.clear();</span><br><span class="line">      <span class="comment">// 如果缓存是依次 statement 的，那就清空缓存</span></span><br><span class="line">      <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">        <span class="comment">// issue #482</span></span><br><span class="line">        clearLocalCache();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing an update"</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">    <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里面也有缓存，这里是一级缓存，重点方法是 <code>queryFromDatabase</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="comment">// 先在缓存里面丢一个占位符，防止缓存穿透</span></span><br><span class="line">    localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 执行查询,子类实现</span></span><br><span class="line">      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 删除占位符</span></span><br><span class="line">      localCache.removeObject(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加实际缓存(为啥不直接put吧之前的顶掉。。)</span></span><br><span class="line">    localCache.putObject(key, list);</span><br><span class="line">    <span class="comment">// 如果是存储过程，缓存参数</span></span><br><span class="line">    <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">      localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>doQuery</code> <code>doUpdate</code> 方法是对应子类实现的，由于默认是 SimpleExecutor，我们看这个实现<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    <span class="comment">// 大部分内部对象的构造，都是通过 Configuration，构造的时候，会把插件链添加进去。这里构造 StatementHandler</span></span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameter, RowBounds.DEFAULT, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 预处理</span></span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="comment">// 执行，可以看到，操作封装在 StatementHandler 里面了</span></span><br><span class="line">    <span class="keyword">return</span> handler.update(stmt);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="comment">// 跟 doUpdate 唯一不同的就是这里了</span></span><br><span class="line">    <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt;</span><br><span class="line">  <span class="comment">// 调用父类的getConnection，如果允许debug日志打印，拿到的是代理</span></span><br><span class="line">  Connection connection = getConnection(statementLog);</span><br><span class="line">  <span class="comment">// prepare 预处理</span></span><br><span class="line">  stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">  <span class="comment">// 参数设置</span></span><br><span class="line">  handler.parameterize(stmt);</span><br><span class="line">  <span class="comment">// 返回</span></span><br><span class="line">  <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这里可以看到，又调用了 StatementHandler 来处理所有sql，这个又是 configuration 创建的，我们看一下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">  <span class="comment">// 这里就是扩展了，使用插件扩展，主要扩展接口是 Interceptor ，被代理的是 StatementHandler 的实现类</span></span><br><span class="line">  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">  <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StatementHandler delegate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> STATEMENT:</span><br><span class="line">      delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PREPARED:</span><br><span class="line">      delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CALLABLE:</span><br><span class="line">      delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Unknown statement type: "</span> + ms.getStatementType());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的 RoutingStatementHandler 只是简单的代理，根据类型来选择不同的实现，默认的 PREPARED，也就是我们直接使用 JDBC 的时候的 PreparedStatment<br>我们之前看到的 handler 的使用流程是 </p>
<ol>
<li>prepare</li>
<li>parameterize</li>
<li>query 或者 update    </li>
</ol>
<p>我们看看默认的选择实现<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 Statement ，以及设置一些参数</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Statement <span class="title">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().sql(boundSql.getSql());</span><br><span class="line">  Statement statement = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 生成 Statement 子类实现</span></span><br><span class="line">    statement = instantiateStatement(connection);</span><br><span class="line">    <span class="comment">// 设置查询超时时间</span></span><br><span class="line">    setStatementTimeout(statement, transactionTimeout);</span><br><span class="line">    <span class="comment">// 设置每次去数据库获取数据的大小（当一次获取过多的数据时候，可能会内存溢出，设置这个参数，在获取结果集的时候循环去取）</span></span><br><span class="line">    setFetchSize(statement);</span><br><span class="line">    <span class="keyword">return</span> statement;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    closeStatement(statement);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    closeStatement(statement);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Error preparing statement.  Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>prepare 是基类的方法，留一个 instantiateStatement 子类实现，也就是创建不同的 Statement，基类统一设置参数<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  String sql = boundSql.getSql();</span><br><span class="line">  <span class="comment">// 这里生成 prepareStatement，对自动生成（自增字段等）的值进行设置</span></span><br><span class="line">  <span class="keyword">if</span> (mappedStatement.getKeyGenerator() <span class="keyword">instanceof</span> Jdbc3KeyGenerator) &#123;</span><br><span class="line">    String[] keyColumnNames = mappedStatement.getKeyColumns();</span><br><span class="line">    <span class="keyword">if</span> (keyColumnNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果没有指明生成的字段名，那么就要设置可检索</span></span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果设置了字段名，那么直接让JDBC 带出来</span></span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql, keyColumnNames);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappedStatement.getResultSetType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置结果集的滑动方向（单向，双向），设置结果集只读</span></span><br><span class="line">    <span class="keyword">return</span> connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 啥都没配置，那就是默认</span></span><br><span class="line">    <span class="keyword">return</span> connection.prepareStatement(sql);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是默认的 PreparedStatementHandler 实现。在这里，我们终于看到了 JDBC 的东西了<br>然后是 parameterize<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 设置参数类 DefaultParameterHandler</span></span><br><span class="line">  parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的 parameterHandler 是构造的时候(基类)创建的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">BaseStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.configuration = mappedStatement.getConfiguration();</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="keyword">this</span>.mappedStatement = mappedStatement;</span><br><span class="line">    <span class="keyword">this</span>.rowBounds = rowBounds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.typeHandlerRegistry = configuration.getTypeHandlerRegistry();</span><br><span class="line">    <span class="keyword">this</span>.objectFactory = configuration.getObjectFactory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (boundSql == <span class="keyword">null</span>) &#123; <span class="comment">// issue #435, get the key before calculating the statement</span></span><br><span class="line">      <span class="comment">// 生成字段，执行sql之前处理</span></span><br><span class="line">      generateKeys(parameterObject);</span><br><span class="line">      <span class="comment">//  statementHandler 每次都是 new 的，这里每次重新获取 sql，里面涉及到解析过程（动态sql可能跟参数相关）</span></span><br><span class="line">      boundSql = mappedStatement.getBoundSql(parameterObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sql</span></span><br><span class="line">    <span class="keyword">this</span>.boundSql = boundSql;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数处理类</span></span><br><span class="line">    <span class="keyword">this</span>.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    <span class="comment">// 结果处理类</span></span><br><span class="line">    <span class="keyword">this</span>.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    <span class="keyword">return</span> parameterHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">createParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">      ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">    <span class="keyword">return</span> resultSetHandler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>ParameterHandler 的作用是设置参数。使用传的参数和系统默认的参数，加上类型转换<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数设置</span></span><br><span class="line">    ErrorContext.instance().activity(<span class="string">"setting parameters"</span>).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">    <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">        ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">        <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">          Object value;</span><br><span class="line">          String propertyName = parameterMapping.getProperty();</span><br><span class="line">          <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; <span class="comment">// issue #448 ask first for additional params</span></span><br><span class="line">            value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            value = <span class="keyword">null</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">            value = parameterObject;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">            <span class="comment">// 重点在这里，从参数对象里面获取值</span></span><br><span class="line">            value = metaObject.getValue(propertyName);</span><br><span class="line">          &#125;</span><br><span class="line">          TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">          JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">          <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里类型转换</span></span><br><span class="line">            typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (TypeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"Could not set parameters for mapping: "</span> + parameterMapping + <span class="string">". Cause: "</span> + e, e);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"Could not set parameters for mapping: "</span> + parameterMapping + <span class="string">". Cause: "</span> + e, e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，就是 query 和 update 了<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">// 无论是 更新 还行查询，都执行 execute，然后处理结果集</span></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="comment">// 结果集处理类 DefaultResultSetHandler</span></span><br><span class="line">  <span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="keyword">int</span> rows = ps.getUpdateCount();</span><br><span class="line">  <span class="comment">// 更新操作可能需要获取数据库自动生成的字段值（insert 自增）</span></span><br><span class="line">  Object parameterObject = boundSql.getParameterObject();</span><br><span class="line">  KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();</span><br><span class="line">  keyGenerator.processAfter(executor, mappedStatement, ps, parameterObject);</span><br><span class="line">  <span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查询后字段映射到对象，resultSetHandler 根据对象类型或者 ResultMap，老复杂了。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析过程老复杂了</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// HANDLE RESULT SETS</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().activity(<span class="string">"handling results"</span>).object(mappedStatement.getId());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> List&lt;Object&gt; multipleResults = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resultSetCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 包装一下</span></span><br><span class="line">    ResultSetWrapper rsw = getFirstResultSet(stmt);</span><br><span class="line">    <span class="comment">// 获取 resultMap 可能有内联的</span></span><br><span class="line">    List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span><br><span class="line">    <span class="keyword">int</span> resultMapCount = resultMaps.size();</span><br><span class="line">    <span class="comment">// 验证，数量</span></span><br><span class="line">    validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line">    <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">      ResultMap resultMap = resultMaps.get(resultSetCount);</span><br><span class="line">      handleResultSet(rsw, resultMap, multipleResults, <span class="keyword">null</span>);</span><br><span class="line">      rsw = getNextResultSet(stmt);</span><br><span class="line">      cleanUpAfterHandlingResultSet();</span><br><span class="line">      resultSetCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] resultSets = mappedStatement.getResultSets();</span><br><span class="line">    <span class="keyword">if</span> (resultSets != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">        ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">        <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">          String nestedResultMapId = parentMapping.getNestedResultMapId();</span><br><span class="line">          ResultMap resultMap = configuration.getResultMap(nestedResultMapId);</span><br><span class="line">          handleResultSet(rsw, resultMap, <span class="keyword">null</span>, parentMapping);</span><br><span class="line">        &#125;</span><br><span class="line">        rsw = getNextResultSet(stmt);</span><br><span class="line">        cleanUpAfterHandlingResultSet();</span><br><span class="line">        resultSetCount++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> collapseSingleResultList(multipleResults);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面就是 执行的大体流程了   </p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis启动</title>
    <url>/2019/09/09/mybatis%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p>Mybatis 启动流程解析  </p>
<p><a href="https://blog.csdn.net/luanlouis/article/details/40422941" target="_blank" rel="noopener">mybatis分析</a><br>上面这篇文章的分析挺好的（主要是图画的好，不会画图，很尴尬，盗几张图）。  </p>
<img src="/2019/09/09/mybatis%E5%90%AF%E5%8A%A8/mybatis-total.png" class="" title="This is an example image">
<p>从MyBatis代码实现的角度来看，MyBatis的主要的核心部件有以下几个：</p>
<ul>
<li>SqlSessionFactory    SqlSession 工厂，全局唯一（单库情况）</li>
<li>Configuration        MyBatis所有的配置信息都维持在Configuration对象之中。</li>
<li>SqlSession            作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能</li>
<li>Executor              MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护</li>
<li>StatementHandler   封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合。</li>
<li>ParameterHandler   负责对用户传递的参数转换成JDBC Statement 所需要的参数，</li>
<li>ResultSetHandler    负责将JDBC返回的ResultSet结果集对象转换成List类型的集合；</li>
<li>TypeHandler          负责java数据类型和jdbc数据类型之间的映射和转换</li>
<li>MappedStatement   MappedStatement维护了一条<select|update|delete|insert>节点的封装， </li>
<li>SqlSource            负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回</li>
<li>BoundSql             表示动态生成的SQL语句以及相应的参数信息</li>
</ul>
<h2 id="xml启动"><a href="#xml启动" class="headerlink" title="xml启动"></a>xml启动</h2><p>mybatis 的启动单独使用时通过一个核心配置xml + n个mapper.xml 的<br>与 springboot 集成的时候，通常只剩下 n个mapper.xml 了（不用xml也行，但是通常还是会使用xml来定义复杂一点的语句）。<br>我们还是从xml分析   </p>
<p><strong>基础概念</strong></p>
<ol>
<li>SqlSessionFactory<br>SqlSession 工厂，全局唯一（单数据源的情况下），启动实际上就是构建 SqlSessionFactory（但是配置信息全部在 Configuration）</li>
<li>SqlSession<br>跟数据库交互的操作都是基于这个类（即使是 Dao 接口，也是 getMapper 获取到的动态代理）</li>
<li>Configuration<br>核心配置类，所有 mybatis 相关的配置和解析出来的信息都在这里</li>
</ol>
<p><strong>入门</strong><br>使用xml<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String resource = <span class="string">"org/mybatis/example/mybatis-config.xml"</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure></p>
<p>不使用xml<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();</span><br><span class="line">TransactionFactory transactionFactory = <span class="keyword">new</span> JdbcTransactionFactory();</span><br><span class="line">Environment environment = <span class="keyword">new</span> Environment(<span class="string">"development"</span>, transactionFactory, dataSource);</span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration(environment);</span><br><span class="line">configuration.addMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(configuration);</span><br></pre></td></tr></table></figure></p>
<p>上面就是启动，获取 SqlSessionFactory 实例后就可以继续获取 SqlSession 进行数据操作了<br><strong>数据操作</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Blog blog = (Blog) session.selectOne(<span class="string">"org.mybatis.example.BlogMapper.selectBlog"</span>, <span class="number">101</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  session.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  Blog blog = mapper.selectBlog(<span class="number">101</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面两种操作方式，通常使用的是第二种，并且这部分操作都会进行封装（跟spring 集成的时候），在业务里面直接获取 <code>Dao</code> 接口进行操作（不需要实现类）. </p>
<p>入口分析从 SqlSessionFactoryBuilder 开始</p>
<h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Reader reader, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(reader, environment, properties);</span><br><span class="line">      <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        reader.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>重点就是这个方法，还有一个重载方法，参数类型是 InputStream，根据 api 构建，就可以猜到 XMLConfigBuilder 经过 parse 后，就是 Configuration 实例了</p>
<p>获取 Configuration 实例后 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建 SqlSessionFactory ，只是将 Configuration 对象传过来的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSessionFactory</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 SqlSessionFactory 的实现就是 DefaultSqlSessionFactory  </p>
<p>接下来我们看看解析细节</p>
<h3 id="XMLConfigBuilder"><a href="#XMLConfigBuilder" class="headerlink" title="XMLConfigBuilder"></a>XMLConfigBuilder</h3><p>这里的就是就是核心配置文件<br>示例<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">  "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/example/BlogMapper.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当parse 完成后，返回 configuration，这个类是核心类，有所有的信息</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Each XMLConfigBuilder can only be used once."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    parsed = <span class="keyword">true</span>;</span><br><span class="line">    parseConfiguration(parser.evalNode(<span class="string">"/configuration"</span>));</span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们不去细看xml解析语法（在构造这个实例的时候就已经解析成一个 Dom 对象了）<br>这里重要的是 <code>parseConfiguration(parser.evalNode(&quot;/configuration&quot;));</code> ,直接就能猜到是解析 configuration 节点    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析 xml 配置文件</span></span><br><span class="line">  <span class="comment">// 解析完成后，所有的信息都在 Configuration 对象上</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 解析顺序,所以配置文件的顺序，通常来说也是这样的</span></span><br><span class="line"><span class="comment">       * 1. properties 自定义配置项，resource url 可以设置外置的 properties 文件，也可以在子元素里面设置，配置将用在接下来的解析，也会设置在 configuration 类里面（configuration是核心类，所有的东西最终都在这里）</span></span><br><span class="line"><span class="comment">       * 2. settings 系统配置项，一些开关，全局配置之类的</span></span><br><span class="line"><span class="comment">       * 3. typeAliases</span></span><br><span class="line"><span class="comment">       * 4. plugins</span></span><br><span class="line"><span class="comment">       * 5. objectFactory</span></span><br><span class="line"><span class="comment">       * 6. objectWrapperFactory</span></span><br><span class="line"><span class="comment">       * 7. reflectorFactory</span></span><br><span class="line"><span class="comment">       * 8. environments</span></span><br><span class="line"><span class="comment">       * 9. databaseIdProvider</span></span><br><span class="line"><span class="comment">       * 10. typeHandlers</span></span><br><span class="line"><span class="comment">       * 11. mappers</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">//issue #117 read properties first</span></span><br><span class="line">      <span class="comment">// 解析 properties</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;properties resource="org/mybatis/example/config.properties"&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;property name="username" value="dev_user"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;property name="password" value="F2Fa3!33TYyg"/&gt;</span></span><br><span class="line"><span class="comment">       * &lt;/properties&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      propertiesElement(root.evalNode(<span class="string">"properties"</span>));</span><br><span class="line">      <span class="comment">// 解析settings</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;settings&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;setting name="cacheEnabled" value="true"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;setting name="lazyLoadingEnabled" value="true"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;setting name="multipleResultSetsEnabled" value="true"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;setting name="useColumnLabel" value="true"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;setting name="useGeneratedKeys" value="false"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;setting name="autoMappingBehavior" value="PARTIAL"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;setting name="autoMappingUnknownColumnBehavior" value="WARNING"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;setting name="defaultExecutorType" value="SIMPLE"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;setting name="defaultStatementTimeout" value="25"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;setting name="defaultFetchSize" value="100"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;setting name="safeRowBoundsEnabled" value="false"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;setting name="mapUnderscoreToCamelCase" value="false"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;setting name="localCacheScope" value="SESSION"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;setting name="jdbcTypeForNull" value="OTHER"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/&gt;</span></span><br><span class="line"><span class="comment">       * &lt;/settings&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      Properties settings = settingsAsProperties(root.evalNode(<span class="string">"settings"</span>));</span><br><span class="line">      <span class="comment">// 看看 settings 里面是否设置类 Vfs 实现类（大部分不需要管，只是部署在特殊的容器里面可能需要扩展，VFS 就是在不同容器里面获取资源的方式和路径不同）</span></span><br><span class="line">      loadCustomVfs(settings);</span><br><span class="line">      <span class="comment">// 别名设置，这个经常使用，用简单类名当做全类名的别名</span></span><br><span class="line">      <span class="comment">// 可以直接指定 package   &lt;package name="domain.blog"/&gt;</span></span><br><span class="line">      <span class="comment">// 也可以一个一个指定 &lt;typeAlias alias="Tag" type="domain.blog.Tag"/&gt;</span></span><br><span class="line">      typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br><span class="line">      <span class="comment">// 解析插件，插件是用来扩展 mybatis 的地方，比如分页插件等</span></span><br><span class="line">      <span class="comment">// 注册的插件添加到 configuration 上，注意，这里的 property 不能用上面的 properties 里面定义的</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;plugins&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;plugin interceptor="org.mybatis.example.ExamplePlugin"&gt;</span></span><br><span class="line"><span class="comment">       *     &lt;property name="someProperty" value="100"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;/plugin&gt;</span></span><br><span class="line"><span class="comment">       * &lt;/plugins&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      pluginElement(root.evalNode(<span class="string">"plugins"</span>));</span><br><span class="line">      <span class="comment">// 解析objectFactory</span></span><br><span class="line">      <span class="comment">// MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。</span></span><br><span class="line">      <span class="comment">// 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化。</span></span><br><span class="line">      <span class="comment">// 如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;objectFactory type="org.mybatis.example.ExampleObjectFactory"&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;property name="someProperty" value="100"/&gt;</span></span><br><span class="line"><span class="comment">       * &lt;/objectFactory&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line">      <span class="comment">// 解析 objectWrapperFactory</span></span><br><span class="line">      <span class="comment">// 这个类就是用来包装和判断对象是否包装过，默认是没有包装的，后面看看这里有在那里</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;objectWrapperFactory type="org..."&gt;&lt;/objectWrapperFactory&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line">      <span class="comment">// 解析 reflectorFactory</span></span><br><span class="line">      <span class="comment">// 就是用来包装 Class 对象，方便反射调用，默认即可</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;reflectorFactory type="org..."&gt;&lt;/reflectorFactory&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      reflectorFactoryElement(root.evalNode(<span class="string">"reflectorFactory"</span>));</span><br><span class="line">      <span class="comment">// 这里设置 settings ，没有就取默认值</span></span><br><span class="line">      settingsElement(settings);</span><br><span class="line">      <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">      <span class="comment">// 解析 environments</span></span><br><span class="line">      <span class="comment">// 这里配置事物，数据源</span></span><br><span class="line">      <span class="comment">// property 可以直接填直接值，可以使用上面properties 加载的</span></span><br><span class="line">      <span class="comment">// 注意，可以使用多个 environment，用在不同环境，但是只有 default 指定的环境生效</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;environments default="development"&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;environment id="development"&gt;</span></span><br><span class="line"><span class="comment">       *     &lt;transactionManager type="JDBC"&gt;</span></span><br><span class="line"><span class="comment">       *       &lt;property name="..." value="..."/&gt;</span></span><br><span class="line"><span class="comment">       *     &lt;/transactionManager&gt;</span></span><br><span class="line"><span class="comment">       *     &lt;dataSource type="POOLED"&gt;</span></span><br><span class="line"><span class="comment">       *       &lt;property name="driver" value="$&#123;driver&#125;"/&gt;</span></span><br><span class="line"><span class="comment">       *       &lt;property name="url" value="$&#123;url&#125;"/&gt;</span></span><br><span class="line"><span class="comment">       *       &lt;property name="username" value="$&#123;username&#125;"/&gt;</span></span><br><span class="line"><span class="comment">       *       &lt;property name="password" value="$&#123;password&#125;"/&gt;</span></span><br><span class="line"><span class="comment">       *     &lt;/dataSource&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;/environment&gt;</span></span><br><span class="line"><span class="comment">       * &lt;/environments&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br><span class="line">      <span class="comment">// 解析 databaseIdProvider</span></span><br><span class="line">      <span class="comment">//MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性。</span></span><br><span class="line">      <span class="comment">// MyBatis 会加载不带 databaseId 属性和带有匹配当前数据库 databaseId 属性的所有语句。</span></span><br><span class="line">      <span class="comment">// 如果同时找到带有 databaseId 和不带 databaseId 的相同语句，则后者会被舍弃</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;databaseIdProvider type="DB_VENDOR"&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;property name="SQL Server" value="sqlserver"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;property name="DB2" value="db2"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;property name="Oracle" value="oracle" /&gt;</span></span><br><span class="line"><span class="comment">       * &lt;/databaseIdProvider&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br><span class="line">      <span class="comment">// 类型处理</span></span><br><span class="line">      <span class="comment">// 可以一个一个指定，也可以指定一个package</span></span><br><span class="line">      <span class="comment">// 要有 注解标记 @MappedJdbcTypes(JdbcType.VARCHAR)</span></span><br><span class="line">      <span class="comment">// 这里是 java 类型和 数据库类型转换的类</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *&lt;typeHandlers&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;package name="org.mybatis.example"/&gt;</span></span><br><span class="line"><span class="comment">       * &lt;/typeHandlers&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;typeHandlers&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;typeHandler handler="org.mybatis.example.ExampleTypeHandler"/&gt;</span></span><br><span class="line"><span class="comment">       * &lt;/typeHandlers&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br><span class="line">      <span class="comment">// 解析 mappers</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。</span></span><br><span class="line"><span class="comment">       * Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。</span></span><br><span class="line"><span class="comment">       * 你可以使用相对于类路径的资源引用， 或完全限定资源定位符</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;!-- 使用相对于类路径的资源引用 --&gt;</span></span><br><span class="line"><span class="comment">       * &lt;mappers&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;mapper resource="org/mybatis/builder/AuthorMapper.xml"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;mapper resource="org/mybatis/builder/BlogMapper.xml"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;mapper resource="org/mybatis/builder/PostMapper.xml"/&gt;</span></span><br><span class="line"><span class="comment">       * &lt;/mappers&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;!-- 使用完全限定资源定位符（URL） --&gt;</span></span><br><span class="line"><span class="comment">       * &lt;mappers&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;mapper url="file:///var/mappers/AuthorMapper.xml"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;mapper url="file:///var/mappers/BlogMapper.xml"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;mapper url="file:///var/mappers/PostMapper.xml"/&gt;</span></span><br><span class="line"><span class="comment">       * &lt;/mappers&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;</span></span><br><span class="line"><span class="comment">       * &lt;mappers&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;mapper class="org.mybatis.builder.AuthorMapper"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;mapper class="org.mybatis.builder.BlogMapper"/&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;mapper class="org.mybatis.builder.PostMapper"/&gt;</span></span><br><span class="line"><span class="comment">       * &lt;/mappers&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;</span></span><br><span class="line"><span class="comment">       * &lt;mappers&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;package name="org.mybatis.builder"/&gt;</span></span><br><span class="line"><span class="comment">       * &lt;/mappers&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这上面已经有注释了，除了解析 mappers 里面还要做特别处理外，其他的解析都不复杂，不继续向下看。<br>这里面，我们用的多的就是 别名，类型处理，全局设置，自定义配置，环境（事务管理和数据源配置），如果多数据库支持那么可以使用数据库标识（databaseId），如果需要做扩展（分页）可以注册<br>插件（插件的实现原理我们后面具体分析）。<br>所有的解析都是将xml配置信息丢到 Configuration 实例里面。    </p>
<p>接下来我们具体讲一下 mappers 的解析（sql 执行相关）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">          <span class="comment">// package 的直接 Mapper</span></span><br><span class="line">          String mapperPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">          configuration.addMappers(mapperPackage);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          String resource = child.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">          String url = child.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">          String mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</span><br><span class="line">          <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析 mapper 的 xml</span></span><br><span class="line">            ErrorContext.instance().resource(resource);</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">            mapperParser.parse();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 同上，不过是根据url获取</span></span><br><span class="line">            ErrorContext.instance().resource(url);</span><br><span class="line">            InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">            XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">            mapperParser.parse();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 定义的接口，那就直接 addMapper</span></span><br><span class="line">            Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">            configuration.addMapper(mapperInterface);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"A mapper element may only specify a url, resource or class, but not more than one."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>mappers 里面我们可以直接指定包名（该包下的接口注册），单接口注册（class），或者 mapper.xml 文件路径（即使注册了接口，我们通常还是会写这个文件，注册接口后<br>mybatis也会默认找一下同名mapper.xml 文件）<br>其实这里主要分为 xml 解析 和 接口注册，我们先看xml解析过程（不详细分析）<br>顺带说一句 <code>ErrorContext</code> 这个类是记录解析或者执行的信息，等出席异常的时候方便定为问题。    </p>
<p><strong>xml</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造时候的 xml 解析，忽略，只要知道要进行xml格式检查以及最终的 dom 节点就行了。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">XMLMapperBuilder</span><span class="params">(InputStream inputStream, Configuration configuration, String resource, Map&lt;String, XNode&gt; sqlFragments)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> XPathParser(inputStream, <span class="keyword">true</span>, configuration.getVariables(), <span class="keyword">new</span> XMLMapperEntityResolver()),</span><br><span class="line">        configuration, resource, sqlFragments);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">XMLMapperBuilder</span><span class="params">(XPathParser parser, Configuration configuration, String resource, Map&lt;String, XNode&gt; sqlFragments)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(configuration);</span><br><span class="line">    <span class="keyword">this</span>.builderAssistant = <span class="keyword">new</span> MapperBuilderAssistant(configuration, resource);</span><br><span class="line">    <span class="keyword">this</span>.parser = parser;</span><br><span class="line">    <span class="keyword">this</span>.sqlFragments = sqlFragments;</span><br><span class="line">    <span class="keyword">this</span>.resource = resource;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">      <span class="comment">// 解析 xml</span></span><br><span class="line">      configurationElement(parser.evalNode(<span class="string">"/mapper"</span>));</span><br><span class="line">      <span class="comment">// 标记为已经解析过的资源</span></span><br><span class="line">      configuration.addLoadedResource(resource);</span><br><span class="line">      <span class="comment">// 这里尝试根据 namespace 找到对应接口，注册 Mapper，所以，namespace 建议跟对应接口名保持一致，id 跟方法名保持一致</span></span><br><span class="line">      bindMapperForNamespace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parsePendingResultMaps();</span><br><span class="line">    parsePendingCacheRefs();</span><br><span class="line">    parsePendingStatements();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>解析的时候先解析xml，如果已经解析过了忽略<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// namespace</span></span><br><span class="line">    String namespace = context.getStringAttribute(<span class="string">"namespace"</span>);</span><br><span class="line">    <span class="keyword">if</span> (namespace == <span class="keyword">null</span> || namespace.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Mapper's namespace cannot be empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置当前 namespace</span></span><br><span class="line">    builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">    <span class="comment">// 解析对应标签</span></span><br><span class="line">    <span class="comment">// 公用一个缓存对象的标签</span></span><br><span class="line">    cacheRefElement(context.evalNode(<span class="string">"cache-ref"</span>));</span><br><span class="line">    <span class="comment">// mapper 的缓存设置</span></span><br><span class="line">    cacheElement(context.evalNode(<span class="string">"cache"</span>));</span><br><span class="line">    <span class="comment">// 参数map，这个可能以后会废弃，就不看了</span></span><br><span class="line">    parameterMapElement(context.evalNodes(<span class="string">"/mapper/parameterMap"</span>));</span><br><span class="line">    <span class="comment">// 结果集map，这个经常用到，特别是自定义返回</span></span><br><span class="line">    resultMapElements(context.evalNodes(<span class="string">"/mapper/resultMap"</span>));</span><br><span class="line">    <span class="comment">// sql 标签，公用的sql语句</span></span><br><span class="line">    sqlElement(context.evalNodes(<span class="string">"/mapper/sql"</span>));</span><br><span class="line">    <span class="comment">// 增删改查语句</span></span><br><span class="line">    buildStatementFromContext(context.evalNodes(<span class="string">"select|insert|update|delete"</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing Mapper XML. The XML location is '"</span> + resource + <span class="string">"'. Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>缓存相关的2个解析很简单<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheRefElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 先配置类添加这个配置</span></span><br><span class="line">      configuration.addCacheRef(builderAssistant.getCurrentNamespace(), context.getStringAttribute(<span class="string">"namespace"</span>));</span><br><span class="line">      CacheRefResolver cacheRefResolver = <span class="keyword">new</span> CacheRefResolver(builderAssistant, context.getStringAttribute(<span class="string">"namespace"</span>));</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的解析，只是看看引用的namespace 在前面解析没（就是有对应namespace的缓存配置不），如果没解析那就添加一些未解析，等后面解析</span></span><br><span class="line">        cacheRefResolver.resolveCacheRef();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">        configuration.addIncompleteCacheRef(cacheRefResolver);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// type 可以是别名（内建的cache），也可以是cache类全名（自定义cache可以用）</span></span><br><span class="line">      String type = context.getStringAttribute(<span class="string">"type"</span>, <span class="string">"PERPETUAL"</span>);</span><br><span class="line">      <span class="comment">// 根据别名获取class，如果存在，就返回对应 class，如果不存在，就加载类名</span></span><br><span class="line">      Class&lt;? extends Cache&gt; typeClass = typeAliasRegistry.resolveAlias(type);</span><br><span class="line">      <span class="comment">// 回收策略,这里的 Cache 是对上面的包装</span></span><br><span class="line">      String eviction = context.getStringAttribute(<span class="string">"eviction"</span>, <span class="string">"LRU"</span>);</span><br><span class="line">      Class&lt;? extends Cache&gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);</span><br><span class="line">      <span class="comment">// 刷新间隔</span></span><br><span class="line">      Long flushInterval = context.getLongAttribute(<span class="string">"flushInterval"</span>);</span><br><span class="line">      <span class="comment">// 对象数量</span></span><br><span class="line">      Integer size = context.getIntAttribute(<span class="string">"size"</span>);</span><br><span class="line">      <span class="comment">// 只读</span></span><br><span class="line">      <span class="keyword">boolean</span> readWrite = !context.getBooleanAttribute(<span class="string">"readOnly"</span>, <span class="keyword">false</span>);</span><br><span class="line">      <span class="comment">// 阻塞</span></span><br><span class="line">      <span class="keyword">boolean</span> blocking = context.getBooleanAttribute(<span class="string">"blocking"</span>, <span class="keyword">false</span>);</span><br><span class="line">      <span class="comment">// 其他自定义属性</span></span><br><span class="line">      Properties props = context.getChildrenAsProperties();</span><br><span class="line">      <span class="comment">// 添加缓存实例到 配置中</span></span><br><span class="line">      builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>所谓 cacheRef 代表使用另一个mapper 里面的缓存配置（公用一个）<br>cache 表示本mapper 使用的配置（所以，当开启了二级缓存的时候，对应mapper里面也要配置才起作用）   </p>
<p>parameterMap 标签用的比较少，就不看了<br>sql 标签是用来写公用sql 的（譬如表里面的字段名）<br>resultMap 定义返回映射（常用，特别是复杂映射）<br>然后就是增删改查解析    </p>
<p>resultMap 解析出来的是 ResultMapping list，其中每一个字段的映射都对应一个 ResultMapping 实例，如果有嵌套，那么 ResultMapping 是有组合的<br>具体解析过程就不看了，解析小复杂，过于细节，跳过。  </p>
<p>sql 标签，解析出来的是可以共用的 sql 片段，比较简单，跳过<br>重点在实际sql解析 增删改查<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (configuration.getDatabaseId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      buildStatementFromContext(list, configuration.getDatabaseId());</span><br><span class="line">    &#125;</span><br><span class="line">    buildStatementFromContext(list, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode context : list) &#123;</span><br><span class="line">      <span class="keyword">final</span> XMLStatementBuilder statementParser = <span class="keyword">new</span> XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        statementParser.parseStatementNode();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">        configuration.addIncompleteStatement(statementParser);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseStatementNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String id = context.getStringAttribute(<span class="string">"id"</span>);</span><br><span class="line">    String databaseId = context.getStringAttribute(<span class="string">"databaseId"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库不匹配，不解析</span></span><br><span class="line">    <span class="keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="keyword">this</span>.requiredDatabaseId)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析属性</span></span><br><span class="line">    Integer fetchSize = context.getIntAttribute(<span class="string">"fetchSize"</span>);</span><br><span class="line">    Integer timeout = context.getIntAttribute(<span class="string">"timeout"</span>);</span><br><span class="line">    String parameterMap = context.getStringAttribute(<span class="string">"parameterMap"</span>);</span><br><span class="line">    String parameterType = context.getStringAttribute(<span class="string">"parameterType"</span>);</span><br><span class="line">    Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line">    String resultMap = context.getStringAttribute(<span class="string">"resultMap"</span>);</span><br><span class="line">    String resultType = context.getStringAttribute(<span class="string">"resultType"</span>);</span><br><span class="line">    String lang = context.getStringAttribute(<span class="string">"lang"</span>);</span><br><span class="line">    LanguageDriver langDriver = getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">    String resultSetType = context.getStringAttribute(<span class="string">"resultSetType"</span>);</span><br><span class="line">    StatementType statementType = StatementType.valueOf(context.getStringAttribute(<span class="string">"statementType"</span>, StatementType.PREPARED.toString()));</span><br><span class="line">    ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);</span><br><span class="line"></span><br><span class="line">    String nodeName = context.getNode().getNodeName();</span><br><span class="line">    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">    <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">    <span class="keyword">boolean</span> flushCache = context.getBooleanAttribute(<span class="string">"flushCache"</span>, !isSelect);</span><br><span class="line">    <span class="keyword">boolean</span> useCache = context.getBooleanAttribute(<span class="string">"useCache"</span>, isSelect);</span><br><span class="line">    <span class="keyword">boolean</span> resultOrdered = context.getBooleanAttribute(<span class="string">"resultOrdered"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Include Fragments before parsing</span></span><br><span class="line">    XMLIncludeTransformer includeParser = <span class="keyword">new</span> XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line">    includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse selectKey after includes and remove them.</span></span><br><span class="line">    processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里默认的是 Xml langDriver 获取 sqlSource</span></span><br><span class="line">    <span class="comment">// Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed)</span></span><br><span class="line">    SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line">    String resultSets = context.getStringAttribute(<span class="string">"resultSets"</span>);</span><br><span class="line">    String keyProperty = context.getStringAttribute(<span class="string">"keyProperty"</span>);</span><br><span class="line">    String keyColumn = context.getStringAttribute(<span class="string">"keyColumn"</span>);</span><br><span class="line">    KeyGenerator keyGenerator;</span><br><span class="line">    String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">      keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      keyGenerator = context.getBooleanAttribute(<span class="string">"useGeneratedKeys"</span>,</span><br><span class="line">          configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">          ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析出来的是 MappedStatement ，key 是 namespace</span></span><br><span class="line">    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">        resultSetTypeEnum, flushCache, useCache, resultOrdered, </span><br><span class="line">        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">  &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">不深入分析细节，观察整个流程    </span><br><span class="line"></span><br><span class="line">解析了看看 Mapper 的注册（接口）    </span><br><span class="line"></span><br><span class="line">**接口**</span><br><span class="line">```java</span><br><span class="line"><span class="comment">// 定义的接口，那就直接 addMapper</span></span><br><span class="line">Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">configuration.addMapper(mapperInterface);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    mapperRegistry.addMapper(type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasMapper(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is already known to the MapperRegistry."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory&lt;T&gt;(type));</span><br><span class="line">        <span class="comment">// It's important that the type is added before the parser is run</span></span><br><span class="line">        <span class="comment">// otherwise the binding may automatically be attempted by the</span></span><br><span class="line">        <span class="comment">// mapper parser. If the type is already known, it won't try.</span></span><br><span class="line">        MapperAnnotationBuilder parser = <span class="keyword">new</span> MapperAnnotationBuilder(config, type);</span><br><span class="line">        parser.parse();</span><br><span class="line">        loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">          knownMappers.remove(type);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，只能注册接口，不能重复注册，添加的是 MapperProxyFactory，到 getMapper 的时候返回的是代理，这个后面分析。<br>然后解析 MapperAnnotationBuilder，解析还是解析 SqlSource 和 相关属性的解析  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注解解析</span></span><br><span class="line">    String resource = type.toString();</span><br><span class="line">    <span class="comment">// 如果对应接口的xml资源未解析（同名。xml，非必须），先去解析</span></span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">      <span class="comment">// 加载xml,可能没这个资源，无所谓</span></span><br><span class="line">      loadXmlResource();</span><br><span class="line">      <span class="comment">// 设置为已经加载的资源</span></span><br><span class="line">      configuration.addLoadedResource(resource);</span><br><span class="line">      <span class="comment">// 设置当前解析的 namespace</span></span><br><span class="line">      assistant.setCurrentNamespace(type.getName());</span><br><span class="line">      <span class="comment">// 解析缓存注解配置 @CacheNamespace</span></span><br><span class="line">      parseCache();</span><br><span class="line">      <span class="comment">// 解析共享缓存注解配置 @CacheNamespaceRef</span></span><br><span class="line">      parseCacheRef();</span><br><span class="line">      <span class="comment">// 每个方法单独解析</span></span><br><span class="line">      Method[] methods = type.getMethods();</span><br><span class="line">      <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// issue #237</span></span><br><span class="line">          <span class="comment">// 泛型擦除的原因，要过滤掉桥接方法</span></span><br><span class="line">          <span class="comment">// 什么是泛型擦除，就是 &lt;T&gt; 如果指定泛型 String，实际上会有两个方法 一个 Object 一个 String ，Object 那个方法就是桥接方法</span></span><br><span class="line">          <span class="keyword">if</span> (!method.isBridge()) &#123;</span><br><span class="line">            <span class="comment">// 解析方法上的注解了</span></span><br><span class="line">            parseStatement(method);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">          configuration.addIncompleteMethod(<span class="keyword">new</span> MethodResolver(<span class="keyword">this</span>, method));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parsePendingMethods();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parseStatement</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取参数类型, RowBounds ResultHandler 相当于系统参数，排除这两个类型的参数，如果是多参数，那么就是内部的 ParamMap 包装，否则就是该参数类型</span></span><br><span class="line">    Class&lt;?&gt; parameterTypeClass = getParameterType(method);</span><br><span class="line">    <span class="comment">// 这个通常不会该，默认就是 xml  PS：什么是 LanguageDriver，mybatis 的本质就是将sql写在文本，然后加载成 SqlSource，默认是写在xml，也可以写 Velocity 模板，或者原生 sql</span></span><br><span class="line">    LanguageDriver languageDriver = getLanguageDriver(method);</span><br><span class="line">    <span class="comment">// 这里就是解析 Sql 了，通过解析注解</span></span><br><span class="line">    SqlSource sqlSource = getSqlSourceFromAnnotations(method, parameterTypeClass, languageDriver);</span><br><span class="line">    <span class="keyword">if</span> (sqlSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 设置参数（系统参数）</span></span><br><span class="line">      Options options = method.getAnnotation(Options<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">final</span> String mappedStatementId = type.getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">      Integer fetchSize = <span class="keyword">null</span>;</span><br><span class="line">      Integer timeout = <span class="keyword">null</span>;</span><br><span class="line">      StatementType statementType = StatementType.PREPARED;</span><br><span class="line">      ResultSetType resultSetType = ResultSetType.FORWARD_ONLY;</span><br><span class="line">      SqlCommandType sqlCommandType = getSqlCommandType(method);</span><br><span class="line">      <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">      <span class="keyword">boolean</span> flushCache = !isSelect;</span><br><span class="line">      <span class="keyword">boolean</span> useCache = isSelect;</span><br><span class="line"></span><br><span class="line">      KeyGenerator keyGenerator;</span><br><span class="line">      String keyProperty = <span class="keyword">null</span>;</span><br><span class="line">      String keyColumn = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (SqlCommandType.INSERT.equals(sqlCommandType) || SqlCommandType.UPDATE.equals(sqlCommandType)) &#123;</span><br><span class="line">        <span class="comment">// first check for SelectKey annotation - that overrides everything else</span></span><br><span class="line">        <span class="comment">// 字段生成</span></span><br><span class="line">        SelectKey selectKey = method.getAnnotation(SelectKey<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (selectKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">          keyGenerator = handleSelectKeyAnnotation(selectKey, mappedStatementId, getParameterType(method), languageDriver);</span><br><span class="line">          keyProperty = selectKey.keyProperty();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options == <span class="keyword">null</span>) &#123;</span><br><span class="line">          keyGenerator = configuration.isUseGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          keyGenerator = options.useGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">          keyProperty = options.keyProperty();</span><br><span class="line">          keyColumn = options.keyColumn();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        keyGenerator = NoKeyGenerator.INSTANCE;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置参数</span></span><br><span class="line">      <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FlushCachePolicy.TRUE.equals(options.flushCache())) &#123;</span><br><span class="line">          flushCache = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (FlushCachePolicy.FALSE.equals(options.flushCache())) &#123;</span><br><span class="line">          flushCache = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        useCache = options.useCache();</span><br><span class="line">        fetchSize = options.fetchSize() &gt; -<span class="number">1</span> || options.fetchSize() == Integer.MIN_VALUE ? options.fetchSize() : <span class="keyword">null</span>; <span class="comment">//issue #348</span></span><br><span class="line">        timeout = options.timeout() &gt; -<span class="number">1</span> ? options.timeout() : <span class="keyword">null</span>;</span><br><span class="line">        statementType = options.statementType();</span><br><span class="line">        resultSetType = options.resultSetType();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      String resultMapId = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// resultMap</span></span><br><span class="line">      ResultMap resultMapAnnotation = method.getAnnotation(ResultMap<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span> (resultMapAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String[] resultMaps = resultMapAnnotation.value();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (String resultMap : resultMaps) &#123;</span><br><span class="line">          <span class="keyword">if</span> (sb.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">","</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          sb.append(resultMap);</span><br><span class="line">        &#125;</span><br><span class="line">        resultMapId = sb.toString();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSelect) &#123;</span><br><span class="line">        <span class="comment">// 生成 resultMap</span></span><br><span class="line">        resultMapId = parseResultMap(method);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      assistant.addMappedStatement(</span><br><span class="line">          mappedStatementId,</span><br><span class="line">          sqlSource,</span><br><span class="line">          statementType,</span><br><span class="line">          sqlCommandType,</span><br><span class="line">          fetchSize,</span><br><span class="line">          timeout,</span><br><span class="line">          <span class="comment">// ParameterMapID</span></span><br><span class="line">          <span class="keyword">null</span>,</span><br><span class="line">          parameterTypeClass,</span><br><span class="line">          resultMapId,</span><br><span class="line">          getReturnType(method),</span><br><span class="line">          resultSetType,</span><br><span class="line">          flushCache,</span><br><span class="line">          useCache,</span><br><span class="line">          <span class="comment">// TODO gcode issue #577</span></span><br><span class="line">          <span class="keyword">false</span>,</span><br><span class="line">          keyGenerator,</span><br><span class="line">          keyProperty,</span><br><span class="line">          keyColumn,</span><br><span class="line">          <span class="comment">// DatabaseID</span></span><br><span class="line">          <span class="keyword">null</span>,</span><br><span class="line">          languageDriver,</span><br><span class="line">          <span class="comment">// ResultSets</span></span><br><span class="line">          options != <span class="keyword">null</span> ? nullOrEmpty(options.resultSets()) : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>注意一点，就是无论 xml 还是 注解，解析完成后都会有一个 MapperedStatement 对象（里面包含 SqlSource，代表定义的sql原始信息）  </p>
<p>这里其实就解析完成了，理一理流程    </p>
<ol>
<li>SqlSessionFactoryBuilder 使用 Congiguration 构建</li>
<li>解析核心配置，设置到 Configuration 实例上（自定义配置，全局配置，别名，扩展配置，对象工厂，反射工厂，环境，数据库标识，类型处理，mappers）</li>
<li>解析mappers获得 MappedStatement 对象，里面包含 SqlSource 对象和其他一些配置信息</li>
<li>注册 Mapper 接口，注册使用的是 MapperProxyFactory，还是会解析 MappedStatement 对象（每个方法上的注解），同时解析同名 mapper.xml 文件    </li>
</ol>
<p>其中 SqlSource 对象是根据 LanguageDriver 创建的，默认的是 XMLLanguageDriver 实现，通常这个也不会去修改  </p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 参数</title>
    <url>/2019/09/07/JVM-%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h2 id="Trace-跟踪参数"><a href="#Trace-跟踪参数" class="headerlink" title="Trace 跟踪参数"></a>Trace 跟踪参数</h2><h3 id="XX-PrintGC"><a href="#XX-PrintGC" class="headerlink" title="-XX:+PrintGC"></a>-XX:+PrintGC</h3><p>打印GC 的简要信息<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: <span class="number">975</span>K-&gt;<span class="number">480</span>K(<span class="number">1536</span>K)] <span class="number">14287</span>K-&gt;<span class="number">14016</span>K(<span class="number">15360</span>K), <span class="number">0.0067338</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs]</span><br></pre></td></tr></table></figure></p>
<h3 id="XX-PrintGCTimeStamps"><a href="#XX-PrintGCTimeStamps" class="headerlink" title="-XX:+PrintGCTimeStamps"></a>-XX:+PrintGCTimeStamps</h3><p>打印 GC 发生的时间戳</p>
<h3 id="XX-PrintGCDetails"><a href="#XX-PrintGCDetails" class="headerlink" title="-XX:+PrintGCDetails"></a>-XX:+PrintGCDetails</h3><p>程序运行结束后，打印GC的日志<br>PSYongGen 新生代 包含下面三个<br>eden 对象出生的地方<br>from 幸存 from to 两个对等<br>to<br>ParOldGen 老年代<br>元空间<br>Metaspace<br>JDK 好像没有永久代了<br>JDK 8开始把类的元数据放到本地化的堆内存(native heap)中，这一块区域就叫Metaspace，中文名叫元空间。<br>新增参数<br>-XX:MetaspaceSize是分配给类元数据空间（以字节计）的初始大小(Oracle逻辑存储上的初始高水位，the initial high-water-mark )，此值为估计值。MetaspaceSize的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。<br>-XX:MaxMetaspaceSize是分配给类元数据空间的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。<br>-XX:MinMetaspaceFreeRatio表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最小比例，不够就会导致垃圾回收。<br>-XX:MaxMetaspaceFreeRatio表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最大比例，不够就会导致垃圾回收。<br>后面括号里面<br>分别为 低边界， 当前边界， 最高边界<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen total <span class="number">1536</span>K, used <span class="number">31</span>K [<span class="number">0x00000000ff980000</span>, <span class="number">0x00000000ffb80000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space <span class="number">1024</span>K, <span class="number">3</span>% used [<span class="number">0x00000000ff980000</span>,<span class="number">0x00000000ff987c68</span>,<span class="number">0x00000000ffa80000</span>)</span><br><span class="line">  from space <span class="number">512</span>K, <span class="number">0</span>% used [<span class="number">0x00000000ffa80000</span>,<span class="number">0x00000000ffa80000</span>,<span class="number">0x00000000ffb00000</span>)</span><br><span class="line">  to space <span class="number">512</span>K, <span class="number">0</span>% used [<span class="number">0x00000000ffb00000</span>,<span class="number">0x00000000ffb00000</span>,<span class="number">0x00000000ffb80000</span>)</span><br><span class="line"> ParOldGen total <span class="number">10240</span>K, used <span class="number">8863</span>K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff980000</span>) </span><br><span class="line">  object space <span class="number">10240</span>K, <span class="number">86</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff4a7e68</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line"> Metaspace used <span class="number">2690</span>K, capacity <span class="number">4486</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span> <span class="title">used</span> 297<span class="title">K</span>, <span class="title">capacity</span> 386<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="Xloggc-log-gc-log"><a href="#Xloggc-log-gc-log" class="headerlink" title="-Xloggc:log/gc.log"></a>-Xloggc:log/gc.log</h3><p>指定 GC log 的位置，以文件输出<br>注意一点，上级目录要存在</p>
<h3 id="XX-PrintHeapAtGC"><a href="#XX-PrintHeapAtGC" class="headerlink" title="-XX:+PrintHeapAtGC"></a>-XX:+PrintHeapAtGC</h3><p>每一次GC后，打印堆信息（GC 前后）<br>开发调试的时候可以用一下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;Heap before GC invocations=<span class="number">1</span> (full <span class="number">0</span>):</span><br><span class="line"> PSYoungGen total <span class="number">1536</span>K, used <span class="number">975</span>K [<span class="number">0x00000000ff980000</span>, <span class="number">0x00000000ffb80000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space <span class="number">1024</span>K, <span class="number">95</span>% used [<span class="number">0x00000000ff980000</span>,<span class="number">0x00000000ffa73c20</span>,<span class="number">0x00000000ffa80000</span>)</span><br><span class="line">  from space <span class="number">512</span>K, <span class="number">0</span>% used [<span class="number">0x00000000ffb00000</span>,<span class="number">0x00000000ffb00000</span>,<span class="number">0x00000000ffb80000</span>)</span><br><span class="line">  to space <span class="number">512</span>K, <span class="number">0</span>% used [<span class="number">0x00000000ffa80000</span>,<span class="number">0x00000000ffa80000</span>,<span class="number">0x00000000ffb00000</span>)</span><br><span class="line"> ParOldGen total <span class="number">13824</span>K, used <span class="number">13312</span>K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff980000</span>, <span class="number">0x00000000ff980000</span>)</span><br><span class="line">  object space <span class="number">13824</span>K, <span class="number">96</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff9000d0</span>,<span class="number">0x00000000ff980000</span>)</span><br><span class="line"> Metaspace used <span class="number">2682</span>K, capacity <span class="number">4486</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span> <span class="title">used</span> 296<span class="title">K</span>, <span class="title">capacity</span> 386<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line">0.116: [GC (Allocation Failure) 14287K-&gt;14008K(15360K), 0.0011068 secs]</span><br><span class="line">Heap after GC invocations=<span class="number">1</span> (full <span class="number">0</span>):</span><br><span class="line"> PSYoungGen total <span class="number">1536</span>K, used <span class="number">496</span>K [<span class="number">0x00000000ff980000</span>, <span class="number">0x00000000ffb80000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space <span class="number">1024</span>K, <span class="number">0</span>% used [<span class="number">0x00000000ff980000</span>,<span class="number">0x00000000ff980000</span>,<span class="number">0x00000000ffa80000</span>)</span><br><span class="line">  from space <span class="number">512</span>K, <span class="number">96</span>% used [<span class="number">0x00000000ffa80000</span>,<span class="number">0x00000000ffafc040</span>,<span class="number">0x00000000ffb00000</span>)</span><br><span class="line">  to space <span class="number">512</span>K, <span class="number">0</span>% used [<span class="number">0x00000000ffb00000</span>,<span class="number">0x00000000ffb00000</span>,<span class="number">0x00000000ffb80000</span>)</span><br><span class="line"> ParOldGen total <span class="number">13824</span>K, used <span class="number">13512</span>K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff980000</span>, <span class="number">0x00000000ff980000</span>)</span><br><span class="line">  object space <span class="number">13824</span>K, <span class="number">97</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff9320d0</span>,<span class="number">0x00000000ff980000</span>)</span><br><span class="line"> Metaspace used <span class="number">2682</span>K, capacity <span class="number">4486</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span> <span class="title">used</span> 296<span class="title">K</span>, <span class="title">capacity</span> 386<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="XX-TraceClassLoading"><a href="#XX-TraceClassLoading" class="headerlink" title="-XX:+TraceClassLoading"></a>-XX:+TraceClassLoading</h3><p>监控加载的类，每一个类加载都记录<br>同样，在跟踪调试的时候可以用一下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Opened C:\Program Files\Java\jre1<span class="number">.8</span><span class="number">.0_161</span>\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.Object from C:\Program Files\Java\jre1<span class="number">.8</span><span class="number">.0_161</span>\lib\rt.jar]</span><br><span class="line">[Loaded java.io.Serializable from C:\Program Files\Java\jre1<span class="number">.8</span><span class="number">.0_161</span>\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.Comparable from C:\Program Files\Java\jre1<span class="number">.8</span><span class="number">.0_161</span>\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.CharSequence from C:\Program Files\Java\jre1<span class="number">.8</span><span class="number">.0_161</span>\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.String from C:\Program Files\Java\jre1<span class="number">.8</span><span class="number">.0_161</span>\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.reflect.AnnotatedElement from C:\Program Files\Java\jre1<span class="number">.8</span><span class="number">.0_161</span>\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.reflect.GenericDeclaration from C:\Program Files\Java\jre1<span class="number">.8</span><span class="number">.0_161</span>\</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h3 id="XX-PrintClassHistogram"><a href="#XX-PrintClassHistogram" class="headerlink" title="-XX:+PrintClassHistogram"></a>-XX:+PrintClassHistogram</h3><p>控制台在运行的时候，按 Ctrl + Break 打印类的信息<br>windows 上好像按不出来<br>就是打印每个类实例的数量，使用空间</p>
<h2 id="堆分配参数"><a href="#堆分配参数" class="headerlink" title="堆分配参数"></a>堆分配参数</h2><h3 id="Xmx-Xms"><a href="#Xmx-Xms" class="headerlink" title="-Xmx -Xms"></a>-Xmx -Xms</h3><p>指定最大堆和最小堆<br>-Xmx20m -Xms5m</p>
<h3 id="Xmn"><a href="#Xmn" class="headerlink" title="-Xmn"></a>-Xmn</h3><p>设置新生代大小<br>-Xmn2m<br>一个 eden 加上两个 survivor 为 2m<br>设置新生代为 2m<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PS E:\study\java\jvm\jvm01&gt; java -Xmx20m -Xms20m -Xmn2m -XX:+PrintGCDetails TestGC</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: <span class="number">974</span>K-&gt;<span class="number">504</span>K(<span class="number">1536</span>K)] <span class="number">18383</span>K-&gt;<span class="number">18160</span>K(<span class="number">19968</span>K), <span class="number">0.0016176</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: <span class="number">504</span>K-&gt;<span class="number">496</span>K(<span class="number">1536</span>K)] <span class="number">18160</span>K-&gt;<span class="number">18160</span>K(<span class="number">19968</span>K), <span class="number">0.0009107</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 496K-&gt;0<span class="title">K</span><span class="params">(<span class="number">1536</span>K)</span>] [ParOldGen: 17664K-&gt;1695<span class="title">K</span><span class="params">(<span class="number">18432</span>K)</span>] 18160K-&gt;1695<span class="title">K</span><span class="params">(<span class="number">19968</span>K)</span>, [Metaspace: 2683K-&gt;2683<span class="title">K</span><span class="params">(<span class="number">1056768</span>K)</span>], 0.0056298 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs]</span><br><span class="line">end</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen total <span class="number">1536</span>K, used <span class="number">31</span>K [<span class="number">0x00000000ffe00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>) </span><br><span class="line">  eden space <span class="number">1024</span>K, <span class="number">3</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe07c68</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  from space <span class="number">512</span>K, <span class="number">0</span>% used [<span class="number">0x00000000fff80000</span>,<span class="number">0x00000000fff80000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">  to space <span class="number">512</span>K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff80000</span>)</span><br><span class="line"> ParOldGen total <span class="number">18432</span>K, used <span class="number">4767</span>K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ffe00000</span>, <span class="number">0x00000000ffe00000</span>) </span><br><span class="line">  object space <span class="number">18432</span>K, <span class="number">25</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff0a7ef0</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line"> Metaspace used <span class="number">2690</span>K, capacity <span class="number">4486</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span> <span class="title">used</span> 297<span class="title">K</span>, <span class="title">capacity</span> 386<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><br>上面可以看到对象都到老年代去了，因为新生代空间不够<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PS E:\study\java\jvm\jvm01&gt; java -Xmx20m -Xms20m -Xmn15m -XX:+PrintGCDetails TestGC</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: <span class="number">11565</span>K-&gt;<span class="number">1504</span>K(<span class="number">13824</span>K)] <span class="number">11565</span>K-&gt;<span class="number">1736</span>K(<span class="number">18944</span>K), <span class="number">0.0012016</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line">end</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen total <span class="number">13824</span>K, used <span class="number">12107</span>K [<span class="number">0x00000000ff100000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space <span class="number">12288</span>K, <span class="number">86</span>% used [<span class="number">0x00000000ff100000</span>,<span class="number">0x00000000ffb5afb8</span>,<span class="number">0x00000000ffd00000</span>)</span><br><span class="line">  from space <span class="number">1536</span>K, <span class="number">97</span>% used [<span class="number">0x00000000ffd00000</span>,<span class="number">0x00000000ffe78040</span>,<span class="number">0x00000000ffe80000</span>)</span><br><span class="line">  to space <span class="number">1536</span>K, <span class="number">0</span>% used [<span class="number">0x00000000ffe80000</span>,<span class="number">0x00000000ffe80000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen total <span class="number">5120</span>K, used <span class="number">232</span>K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff100000</span>, <span class="number">0x00000000ff100000</span>)</span><br><span class="line">  object space <span class="number">5120</span>K, <span class="number">4</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000fec3a000</span>,<span class="number">0x00000000ff100000</span>)</span><br><span class="line"> Metaspace used <span class="number">2690</span>K, capacity <span class="number">4486</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span> <span class="title">used</span> 297<span class="title">K</span>, <span class="title">capacity</span> 386<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><br>调大新生代后，对象在新生代</p>
<h3 id="XX-NewRatio"><a href="#XX-NewRatio" class="headerlink" title="-XX:NewRatio"></a>-XX:NewRatio</h3><p>新生代(eden + 2s) 和老年代的比值<br>4 标识 新生代：老年代= 1：4，即年轻代占堆的 1/5</p>
<h3 id="XX-SurvivorRatio"><a href="#XX-SurvivorRatio" class="headerlink" title="-XX:SurvivorRatio"></a>-XX:SurvivorRatio</h3><p>设置两个 Survivor 区 和 eden 的比<br>8 标识两个 Survivor:eden = 2：8 即，一个 Survivor 占年轻代的 1/10</p>
<h3 id="XX-HeapDumpOnOutOfMemoryError"><a href="#XX-HeapDumpOnOutOfMemoryError" class="headerlink" title="-XX:+HeapDumpOnOutOfMemoryError"></a>-XX:+HeapDumpOnOutOfMemoryError</h3><p>OOM 的时候导出堆到文件</p>
<h3 id="XX-HeapDumpPath"><a href="#XX-HeapDumpPath" class="headerlink" title="-XX:HeapDumpPath"></a>-XX:HeapDumpPath</h3><p>导出文件路径<br>-XX:HeapDumpPath=logs/a.dump</p>
<h3 id="XX-OnOutOfMemoryError"><a href="#XX-OnOutOfMemoryError" class="headerlink" title="-XX:OnOutOfMemoryError"></a>-XX:OnOutOfMemoryError</h3><p>在 OOM 时候，执行一个脚本<br>-XX:OnOutOfMemoryError=”test.bat %p”<br>可以在 OOM 的时候发送邮件，甚至重启程序<br>外面套引号<br>测试了一下，可以执行脚本，但是 %p 进程没有传进去，在windows 上测试的</p>
<h3 id="堆分配总结"><a href="#堆分配总结" class="headerlink" title="堆分配总结"></a>堆分配总结</h3><p>官方推荐<br>新生代占堆的 3/8<br>幸存代占新生代的 1/10<br>OOM的时候记得 Dump 堆，确保可以排查现场问题</p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>java 泛型</title>
    <url>/2019/09/04/java-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p>用了这么久的 <code>spirng</code> ,以为对 <code>ioc</code> 的原理和实现机制已经非常了解了<br>但是，突然想到泛型的依赖注入是怎么实现的，这就很纠结了，因为普通的依赖注入，自己想一下，实现起来简单，但是涉及到泛型，实现就比较复杂了，需要对 <code>jdk</code> 的 <code>Type</code> 有了解<br>这里举几个例子，看看泛型依赖注入的效果：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ID <span class="title">save</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        System.out.println(t.getClass().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDao</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">Book</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">User</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BaseEnhanceDao&lt;Book&gt; bookBaseDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BaseEnhanceDao&lt;User&gt; userBaseDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bookBaseDao.save(<span class="keyword">new</span> Book());</span><br><span class="line">        System.out.println(<span class="string">"-=-=-= 我是分割线 -=-=-="</span>);</span><br><span class="line">        userBaseDao.save(<span class="keyword">new</span> User());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个常用的，很简单的泛型注入，可以看到 <code>spring</code> 在 <code>MyService</code> 类的字段 <code>BaseEnhanceDao&lt;Book&gt;</code> 跟 <code>BookDao</code> 看做同一个类型，而跟 <code>UserDao</code> 不是同一个类型（如果是，依赖注入就会报错,多个满足条件的 <code>bean</code>,但是他们在原生类型上，是存在继承关系的）<br>如果要我们自己实现，如何判断这两个类型是同一个呢？<br>再扩展一点，上面的只是一个简单的继承体系，一个最终的实现类，他的泛型可能来自 <code>superClass</code> 或者 <code>interface</code> ，而且都可以向上延伸<br>举例<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A1</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A2</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A3</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型顶层类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ab2</span>&lt;<span class="title">T</span>, <span class="title">F</span>, <span class="title">H</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AB3</span>&lt;<span class="title">T</span>, <span class="title">F</span>&gt; <span class="keyword">extends</span> <span class="title">Ab2</span>&lt;<span class="title">T</span>, <span class="title">F</span>, <span class="title">A1</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AB4</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AB3</span>&lt;<span class="title">T</span>, <span class="title">A2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AB5</span> <span class="keyword">extends</span> <span class="title">AB4</span>&lt;<span class="title">A3</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里例子，很明显的看到 <code>AB5</code> 有3个泛型类型都是通过继承来的, 如果 <code>AB5</code> 注册为 <code>bean</code>，他可以代表的类型是 <code>Ab2&lt;A3, A2, A1&gt;</code> , <code>AB3&lt;A3, A2&gt;</code> , <code>AB4&lt;A3&gt;</code> ,如果中间的泛型顺序不对，那么就不是同一个类型  </p>
<p>再来看个接口的例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略 OBJ1,2,3,4</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">I1</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">I2</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">I1</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">OBJ4</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">I3</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">I2</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">OBJ3</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">I4</span>&lt;<span class="title">A</span>&gt; <span class="keyword">extends</span> <span class="title">I3</span>&lt;<span class="title">A</span>, <span class="title">OBJ2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">I5</span> <span class="keyword">extends</span> <span class="title">I4</span>&lt;<span class="title">OBJ1</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Impl1</span> <span class="keyword">implements</span> <span class="title">I5</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Impl2</span> <span class="keyword">extends</span> <span class="title">Impl1</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>无论是 <code>Impl1</code> 还是 <code>Impl2</code> 都应该是类型 <code>I1 I2 I3 I4 I5</code> 类型的（原生类型），如果考虑到泛型，那么泛型的具体类型，数量和顺序也是关键，可以自然的想到，当需要注入一个<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> I1&lt;OBJ1, OBJ2, OBJ3, OBJ4&gt; i1;</span><br></pre></td></tr></table></figure></p>
<p>字段的时候， <code>Impl1</code> <code>Impl2</code> 都是满足条件的， <code>spring</code> 也能够处理<br>现在我们思考一下，如果要我们自己去实现这个功能，要怎么做呢？要同时满足接口和超类<br>测试的时候不需要考虑注入问题，只要能够判断 <code>Impl1</code> 是类型 <code>I1&lt;OBJ1, OBJ2, OBJ3, OBJ4&gt;</code>  而不是类型 <code>I1&lt;OBJ4, OBJ3, OBJ2, OBJ1&gt;</code> 就可以了  </p>
<p>所有，我们有这么一个方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSameType</span><span class="params">(Type sourceType, Type toMatchedType)</span></span></span><br></pre></td></tr></table></figure></p>
<p>其中 <code>sourceType</code> 的具体例子就是 <code>I1&lt;OBJ1, OBJ2, OBJ3, OBJ4&gt;</code> , <code>toMatchedType</code> 的例子就是 <code>Impl1</code><br>返回是否为同一个类型<br>看到，参数给的是 <code>Type</code> 类型，而不是 <code>Class</code> 如果传原生的 <code>Class</code> 可能会丢到泛型信息，当通过 <code>field</code> 获取字段类型的时候，使用 <code>getGenericType()</code> 方法获取 <code>Type</code> 类型<br>为了实现这个功能，就需要对 <code>jdk</code> 的 <code>Type</code> 体系有点了解了，毕竟，我们通常使用的是 <code>Class</code> 而不是 <code>Type</code>， <code>getGenericType()</code> 返回的是什么呢？<br>JDK 里面的 Type 定义如下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a string describing this type, including information</span></span><br><span class="line"><span class="comment">     * about any type parameters.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@implSpec</span> The default implementation calls &#123;<span class="doctag">@code</span> toString&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a string describing this type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getTypeName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以调用 <code>getTypeName()</code> 方法，来看里面包含什么泛型信息（这里只是调试看的）<br><code>Type</code> 跟 <code>Class</code> 是什么关系？继承关系，<code>Class</code> 也是一个 <code>Type</code><br><code>Type</code> 下面有几个比较重要的体系 <code>ParameterizedType</code>  <code>TypeVariable</code>  <code>Class</code>  这三个比较重要，另外还有 <code>GenericArrayType</code> 和 <code>WildcardType</code><br>其中 <code>GenericArrayType</code> 代表泛型数组，就是字段类型是 <code>T[] array</code> 这样的<br><code>WildcardType</code> 是通配符表达式 类似 <code>List&lt;? extends Number&gt; list</code> 这样的，可以看成是特殊的 TypeVariable<br>本次研究不看 <code>GenericArrayType</code> 和 <code>WildcardType</code>   </p>
<p>首先要明确的是，最终的实现类，一定要确认所有的泛型类型才能注册为 <code>bean</code>，所以，他的泛型信息肯定是在 <code>superClass</code> 或者 <code>interface(s)</code> 里面的<br>先说简单情况，只有继承关系，没有接口的干预<br>通常，我们获取父类调用 <code>Class</code> 的 <code>getSuperClass</code> 这个方法会丢掉泛型信息，我们需要换一个方法 <code>getGenericSuperclass</code> 这个方法返回一个 <code>Type</code><br>如果父类不是泛型类，没有泛型标签，那么返回的是 <code>Class</code> 类型（实际），否则返回的是 <code>ParameterizedType</code> 类型(实现类)<br>而 <code>ParameterizedType</code> 里面有几个重要方法 <code>getRawType</code> 返回原生类型，就跟 <code>getSuperClass</code> 返回一样, <code>getActualTypeArguments()</code> 返回泛型参数列表 <code>Type[]</code><br>这里的 <code>Type[]</code> 数组，里面具体是什么类型的呢？ 可能是 <code>Class</code> 可能是 <code>TypeVariable</code> 和 <code>WildcardType</code><br>如果是 <code>Class</code> 好说，就是这本层指定了具体的泛型类型，譬如 <code>public class AB4&lt;T&gt; extends AB3&lt;T, A2&gt;</code>  如果是 <code>AB4</code> 调用 <code>getActualTypeArguments</code> 那么泛型参数列表<br>就是 <code>&lt;T, A2, A1&gt;</code> 有3个泛型参数，其中后两个确定了，那么就是 <code>Class</code> 类型， <code>T</code> 代表没确定，就是 <code>TypeVariable</code> 暂时先不考虑限定符的问题，这里的 <code>T</code> 可能是子类指定的，所以很自然的想到 <code>Ab2&lt;A3, A2, A1&gt;</code> 跟 <code>AB5</code> 是不是同一个类型的时候，需要判断的是 <code>AB5</code> 原生类型是不是 <code>Ab2</code> 的子类，以及他们的泛型参数列表是不是相同的，其中 <code>Ab2</code> 的泛型参数列表好获取，重点在于 <code>AB5</code> 的，他的泛型参数是从不同的实现类指定了。   </p>
<p>如果实现了上面说的超类的，那么请再考虑一下 <code>interface</code> 的，想想也知道，更为复杂，因为接口允许多继承，各位可以自己想一想，不需要考虑限定符<br>下面给出参考实现(简单测试过没啥问题，不过不保证):<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断两个类型是否为同一个类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceType 目标类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toMatchedType 待匹配类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSameType</span><span class="params">(Type sourceType, Type toMatchedType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为 null，就不是</span></span><br><span class="line">        <span class="keyword">if</span> (sourceType == <span class="keyword">null</span> || toMatchedType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; sourceClass = <span class="keyword">null</span>;</span><br><span class="line">        Class&lt;?&gt; toMatchedClass = <span class="keyword">null</span>;</span><br><span class="line">        ParameterizedType sourceParameterizedType = <span class="keyword">null</span>;</span><br><span class="line">        ParameterizedType toMatchedParameterizedType = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (Class<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">sourceType</span>)) </span>&#123;</span><br><span class="line">            sourceClass = (Class&lt;?&gt;) sourceType;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ParameterizedType<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">sourceType</span>))</span>&#123;</span><br><span class="line">            sourceParameterizedType = (ParameterizedType) sourceType;</span><br><span class="line">            sourceClass = (Class&lt;?&gt;) sourceParameterizedType.getRawType();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Class<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">toMatchedType</span>)) </span>&#123;</span><br><span class="line">            toMatchedClass = (Class&lt;?&gt;) toMatchedType;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ParameterizedType<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">toMatchedType</span>))</span>&#123;</span><br><span class="line">            toMatchedParameterizedType = (ParameterizedType) toMatchedType;</span><br><span class="line">            toMatchedClass = (Class&lt;?&gt;) toMatchedParameterizedType.getRawType();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sourceClass == <span class="keyword">null</span> | toMatchedClass == <span class="keyword">null</span> || !sourceClass.isAssignableFrom(toMatchedClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正常情况下，到这里，sourceType 应该就是泛型类型了，如果不是，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (sourceParameterizedType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里是待匹配的泛型类型</span></span><br><span class="line">        Type[] actualTypeArguments = sourceParameterizedType.getActualTypeArguments();</span><br><span class="line">        <span class="comment">// 现在的重点是拿 toMatched 的泛型类型，但是，这个类可能就是单纯的 class，他的泛型可能是从 superClass 和 interface 获取到的</span></span><br><span class="line">        <span class="comment">// 思路是，从 matchedType 向上（接口线，或者super线，或者 super + 接口线）到 sourceType 的 rawType 类型,并找到这条线上的泛型参数，对比 actualTypeArguments</span></span><br><span class="line"></span><br><span class="line">        List&lt;ParameterizedType&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Type parent = toMatchedClass;</span><br><span class="line">        Type result = searchVertical(sourceClass, parent, list);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            addResult(result, list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这样查询后，最顶层的类在前面</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (!list.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 第一个类或者接口就是 sourceClass</span></span><br><span class="line">            ParameterizedType parameterizedType = list.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 这里就待匹配的泛型了，但是里面可能是 T 这样的 TypeVariable ，具体的泛型在下面</span></span><br><span class="line">            Type[] matchedTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">            Type[] realMatched = <span class="keyword">new</span> Type[matchedTypeArguments.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matchedTypeArguments.length; i++) &#123;</span><br><span class="line">                Type type = matchedTypeArguments[i];</span><br><span class="line">                <span class="keyword">if</span> (TypeVariable<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">type</span>)) </span>&#123;</span><br><span class="line">                    TypeVariable&lt;?&gt; typeVariable = (TypeVariable&lt;?&gt;) type;</span><br><span class="line">                    <span class="comment">// 这里是泛型变量</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; list.size(); j++) &#123;</span><br><span class="line">                        ParameterizedType p2 = list.get(j);</span><br><span class="line">                        Class&lt;?&gt; rawType = (Class&lt;?&gt;) p2.getRawType();</span><br><span class="line">                        TypeVariable&lt;? extends Class&lt;?&gt;&gt;[] typeParameters = rawType.getTypeParameters();</span><br><span class="line">                        <span class="keyword">if</span> (typeParameters.length == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">boolean</span> find = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; typeParameters.length; k++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (typeParameters[k].getName().equals(typeVariable.getName())) &#123;</span><br><span class="line">                                Type t2 = p2.getActualTypeArguments()[k];</span><br><span class="line">                                <span class="keyword">if</span> (Class<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">t2</span>)) </span>&#123;</span><br><span class="line">                                    realMatched[i] = t2;</span><br><span class="line">                                    find = <span class="keyword">true</span>;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (find) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    realMatched[i] = type;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (actualTypeArguments.length != realMatched.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; actualTypeArguments.length; i++) &#123;</span><br><span class="line">                Class&lt;?&gt; actualType = (Class&lt;?&gt;) actualTypeArguments[i];</span><br><span class="line">                Class&lt;?&gt; toMatchType = (Class&lt;?&gt;) realMatched[i];</span><br><span class="line">                <span class="keyword">if</span> (!actualType.isAssignableFrom(toMatchType)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 垂直查询继承体系</span></span><br><span class="line"><span class="comment">     * 递归调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> current</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Type <span class="title">searchVertical</span><span class="params">(Class&lt;?&gt; sourceClass, Type current, List&lt;ParameterizedType&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Class<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">current</span>)) </span>&#123;</span><br><span class="line">            <span class="comment">// 如果是 class 代表没泛型</span></span><br><span class="line">            Class&lt;?&gt; currentClass = (Class&lt;?&gt;) current;</span><br><span class="line">            <span class="keyword">if</span> (currentClass == Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 代表搜寻到 Object 了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> searchClass(sourceClass, currentClass, current, list);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ParameterizedType<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">current</span>)) </span>&#123;</span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType) current;</span><br><span class="line">            Class&lt;?&gt; rawClass = (Class&lt;?&gt;) parameterizedType.getRawType();</span><br><span class="line">            <span class="keyword">if</span> (rawClass == sourceClass) &#123;</span><br><span class="line">                <span class="comment">// 代表搜寻完毕</span></span><br><span class="line">                <span class="keyword">return</span> parameterizedType;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> searchClass(sourceClass, rawClass, current, list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继续向上，搜索父类或者接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> searchClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> current</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Type <span class="title">searchClass</span><span class="params">(Class&lt;?&gt; sourceClass, Class&lt;?&gt; searchClass, Type current, List&lt;ParameterizedType&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Type type : searchClass.getGenericInterfaces()) &#123;</span><br><span class="line">            Type result = searchVertical(sourceClass, type, list);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                addResult(result, list);</span><br><span class="line">                <span class="keyword">return</span> type;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Type superclass = searchClass.getGenericSuperclass();</span><br><span class="line">        Type result = searchVertical(sourceClass, superclass, list);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            addResult(result, list);</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果是泛型，那么添加到列表里面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addResult</span><span class="params">(Type result, List&lt;ParameterizedType&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ParameterizedType<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">result</span>)) </span>&#123;</span><br><span class="line">            list.add((ParameterizedType) result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>给出测试代码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 修改泛型列表的具体类型  </span></span><br><span class="line"><span class="keyword">private</span> Ab2&lt;A3, A2, A1&gt; ab;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Field field = getClass().getDeclaredField(<span class="string">"ab"</span>);</span><br><span class="line">    Type genericType = field.getGenericType();</span><br><span class="line"></span><br><span class="line">    AB5 ab5 = <span class="keyword">new</span> AB5();</span><br><span class="line">    System.out.println();</span><br><span class="line">    GenericTest test = <span class="keyword">new</span> GenericTest();</span><br><span class="line">    <span class="keyword">boolean</span> sameType = GenericUtil.isSameType(genericType, ab5.getClass());</span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">        System.out.println(<span class="string">"same type"</span>);</span><br><span class="line">        field.set(test, ab5);</span><br><span class="line">        System.out.println(<span class="string">"set field success"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"diff type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改泛型列表的具体类型  </span></span><br><span class="line"><span class="keyword">private</span> I1&lt;OBJ1, OBJ2, OBJ3, OBJ4&gt; i1;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Field field = getClass().getDeclaredField(<span class="string">"i1"</span>);</span><br><span class="line">    Type genericType = field.getGenericType();</span><br><span class="line"></span><br><span class="line">    Impl2 impl1 = <span class="keyword">new</span> Impl2();</span><br><span class="line"></span><br><span class="line">    GenericTest test = <span class="keyword">new</span> GenericTest();</span><br><span class="line">    <span class="keyword">boolean</span> sameType = GenericUtil.isSameType(genericType, impl1.getClass());</span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">        System.out.println(<span class="string">"same type"</span>);</span><br><span class="line">        field.set(test, impl1);</span><br><span class="line">        System.out.println(<span class="string">"set field success"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"diff type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘录模式</title>
    <url>/2019/09/01/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>备忘录模式(Memento Pattern)：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。它是一种对象行为型模式，其别名为Token。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
<p><strong>主要解决：</strong>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p>
<p><strong>何时使用：</strong>很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。</p>
<p><strong>如何解决：</strong>通过一个备忘录类专门存储对象状态。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>就是用一个外部类来保存，管理对象的内部状态，这样做就可以在未来某个时间点恢复到之前的一个已知状态，类似于游戏存档</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标记接口，实现类来保存内部状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StarMemento</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个内部状态会变化的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> StarType type;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> ageYears;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> massTons;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructor</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Star</span><span class="params">(StarType startType, <span class="keyword">int</span> startAge, <span class="keyword">int</span> startMass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = startType;</span><br><span class="line">    <span class="keyword">this</span>.ageYears = startAge;</span><br><span class="line">    <span class="keyword">this</span>.massTons = startMass;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Makes time pass for the star</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timePasses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ageYears *= <span class="number">2</span>;</span><br><span class="line">    massTons *= <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> RED_GIANT:</span><br><span class="line">        type = StarType.WHITE_DWARF;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> SUN:</span><br><span class="line">        type = StarType.RED_GIANT;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> SUPERNOVA:</span><br><span class="line">        type = StarType.DEAD;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> WHITE_DWARF:</span><br><span class="line">        type = StarType.SUPERNOVA;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DEAD:</span><br><span class="line">        ageYears *= <span class="number">2</span>;</span><br><span class="line">        massTons = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">StarMemento <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    StarMementoInternal state = <span class="keyword">new</span> StarMementoInternal();</span><br><span class="line">    state.setAgeYears(ageYears);</span><br><span class="line">    state.setMassTons(massTons);</span><br><span class="line">    state.setType(type);</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(StarMemento memento)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    StarMementoInternal state = (StarMementoInternal) memento;</span><br><span class="line">    <span class="keyword">this</span>.type = state.getType();</span><br><span class="line">    <span class="keyword">this</span>.ageYears = state.getAgeYears();</span><br><span class="line">    <span class="keyword">this</span>.massTons = state.getMassTons();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">"%s age: %d years mass: %d tons"</span>, type.toString(), ageYears, massTons);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * StarMemento implementation</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StarMementoInternal</span> <span class="keyword">implements</span> <span class="title">StarMemento</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StarType type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ageYears;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> massTons;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StarType <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(StarType type)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAgeYears</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ageYears;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAgeYears</span><span class="params">(<span class="keyword">int</span> ageYears)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.ageYears = ageYears;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMassTons</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> massTons;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMassTons</span><span class="params">(<span class="keyword">int</span> massTons)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.massTons = massTons;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> StarType &#123;</span><br><span class="line"></span><br><span class="line">  SUN(<span class="string">"sun"</span>), RED_GIANT(<span class="string">"red giant"</span>), WHITE_DWARF(<span class="string">"white dwarf"</span>), SUPERNOVA(<span class="string">"supernova"</span>), DEAD(</span><br><span class="line">      <span class="string">"dead star"</span>), UNDEFINED(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">  StarType(String title) &#123;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> title;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用，这里并没有用外部类来管理，main 方法里面跑，直接用栈保存状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stack&lt;StarMemento&gt; states = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Star star = <span class="keyword">new</span> Star(StarType.SUN, <span class="number">10000000</span>, <span class="number">500000</span>);</span><br><span class="line">    LOGGER.info(star.toString());</span><br><span class="line">    states.add(star.getMemento());</span><br><span class="line">    star.timePasses();</span><br><span class="line">    LOGGER.info(star.toString());</span><br><span class="line">    states.add(star.getMemento());</span><br><span class="line">    star.timePasses();</span><br><span class="line">    LOGGER.info(star.toString());</span><br><span class="line">    states.add(star.getMemento());</span><br><span class="line">    star.timePasses();</span><br><span class="line">    LOGGER.info(star.toString());</span><br><span class="line">    states.add(star.getMemento());</span><br><span class="line">    star.timePasses();</span><br><span class="line">    LOGGER.info(star.toString());</span><br><span class="line">    <span class="keyword">while</span> (states.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      star.setMemento(states.pop());</span><br><span class="line">      LOGGER.info(star.toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>享元模式</title>
    <url>/2019/08/31/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>运用共享技术有效地支持大量细粒度的对象。</p>
<p><strong>主要解决：</strong>在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p>
<p><strong>何时使用：</strong> </p>
<ol>
<li>系统中有大量对象。 </li>
<li>这些对象消耗大量内存。 </li>
<li>这些对象的状态大部分可以外部化。 </li>
<li>这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 </li>
<li>系统不依赖于这些对象身份，这些对象是不可分辨的。</li>
</ol>
<p><strong>如何解决：</strong>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>这里本质想就是对象的共享，当然一个对象的状态不是总能够共享的，那么就分离，将可以共享的对象放在对象内部，这样对象就可以共享了，不能共享的状态当做一个方法的参数来辅助完成功能。<br>看实现的话，就是一个缓存。。</p>
<p><strong>对象</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Potion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HolyWaterPotion</span> <span class="keyword">implements</span> <span class="title">Potion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(HolyWaterPotion<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"You feel blessed. (Potion=&#123;&#125;)"</span>, System.identityHashCode(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoisonPotion</span> <span class="keyword">implements</span> <span class="title">Potion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(PoisonPotion<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"Urgh! This is poisonous. (Potion=&#123;&#125;)"</span>, System.identityHashCode(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvisibilityPotion</span> <span class="keyword">implements</span> <span class="title">Potion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(InvisibilityPotion<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"You become invisible. (Potion=&#123;&#125;)"</span>, System.identityHashCode(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HealingPotion</span> <span class="keyword">implements</span> <span class="title">Potion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(HealingPotion<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"You feel healed. (Potion=&#123;&#125;)"</span>, System.identityHashCode(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrengthPotion</span> <span class="keyword">implements</span> <span class="title">Potion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(StrengthPotion<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"You feel strong. (Potion=&#123;&#125;)"</span>, System.identityHashCode(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>对象获取</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PotionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;PotionType, Potion&gt; potions;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PotionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    potions = <span class="keyword">new</span> EnumMap&lt;&gt;(PotionType<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Potion <span class="title">createPotion</span><span class="params">(PotionType type)</span> </span>&#123;</span><br><span class="line">    Potion potion = potions.get(type);</span><br><span class="line">    <span class="keyword">if</span> (potion == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> HEALING:</span><br><span class="line">          potion = <span class="keyword">new</span> HealingPotion();</span><br><span class="line">          potions.put(type, potion);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HOLY_WATER:</span><br><span class="line">          potion = <span class="keyword">new</span> HolyWaterPotion();</span><br><span class="line">          potions.put(type, potion);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> INVISIBILITY:</span><br><span class="line">          potion = <span class="keyword">new</span> InvisibilityPotion();</span><br><span class="line">          potions.put(type, potion);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> POISON:</span><br><span class="line">          potion = <span class="keyword">new</span> PoisonPotion();</span><br><span class="line">          potions.put(type, potion);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> STRENGTH:</span><br><span class="line">          potion = <span class="keyword">new</span> StrengthPotion();</span><br><span class="line">          potions.put(type, potion);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> potion;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>使用</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlchemistShop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(AlchemistShop<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;Potion&gt; topShelf;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Potion&gt; bottomShelf;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructor</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AlchemistShop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    topShelf = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    bottomShelf = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    fillShelves();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fillShelves</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PotionFactory factory = <span class="keyword">new</span> PotionFactory();</span><br><span class="line"></span><br><span class="line">    topShelf.add(factory.createPotion(PotionType.INVISIBILITY));</span><br><span class="line">    topShelf.add(factory.createPotion(PotionType.INVISIBILITY));</span><br><span class="line">    topShelf.add(factory.createPotion(PotionType.STRENGTH));</span><br><span class="line">    topShelf.add(factory.createPotion(PotionType.HEALING));</span><br><span class="line">    topShelf.add(factory.createPotion(PotionType.INVISIBILITY));</span><br><span class="line">    topShelf.add(factory.createPotion(PotionType.STRENGTH));</span><br><span class="line">    topShelf.add(factory.createPotion(PotionType.HEALING));</span><br><span class="line">    topShelf.add(factory.createPotion(PotionType.HEALING));</span><br><span class="line"></span><br><span class="line">    bottomShelf.add(factory.createPotion(PotionType.POISON));</span><br><span class="line">    bottomShelf.add(factory.createPotion(PotionType.POISON));</span><br><span class="line">    bottomShelf.add(factory.createPotion(PotionType.POISON));</span><br><span class="line">    bottomShelf.add(factory.createPotion(PotionType.HOLY_WATER));</span><br><span class="line">    bottomShelf.add(factory.createPotion(PotionType.HOLY_WATER));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get a read-only list of all the items on the top shelf</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> The top shelf potions</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> List&lt;Potion&gt; <span class="title">getTopShelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(<span class="keyword">this</span>.topShelf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get a read-only list of all the items on the bottom shelf</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> The bottom shelf potions</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> List&lt;Potion&gt; <span class="title">getBottomShelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(<span class="keyword">this</span>.bottomShelf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Enumerate potions</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enumerate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">"Enumerating top shelf potions\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Potion p : topShelf) &#123;</span><br><span class="line">      p.drink();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">"Enumerating bottom shelf potions\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Potion p : bottomShelf) &#123;</span><br><span class="line">      p.drink();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AlchemistShop alchemistShop = <span class="keyword">new</span> AlchemistShop();</span><br><span class="line">    alchemistShop.enumerate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子要生成的对象状态全部都是可以共享的，所以就是变成缓存了<br>如果要用对象完成一个操作（功能），除了本身状态，还有其他状态（非共享状态），那么可以当做功能方法的参数传进去，这样做是为了共享对象（防止内存占用过多）</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2019/08/30/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<p><strong>主要解决：</strong>在运行期建立和删除原型。</p>
<p><strong>何时使用：</strong></p>
<ol>
<li>当一个系统应该独立于它的产品创建，构成和表示时。 </li>
<li>当要实例化的类是在运行时刻指定时，例如，通过动态装载。 </li>
<li>为了避免创建一个与产品类层次平行的工厂类层次时。 </li>
<li>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li>
</ol>
<p><strong>如何解决：</strong>利用已有的一个原型对象，快速地生成和原型对象一样的实例。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>简单点说就是对象的深复制。。<br>通常会给个基本接口有个 copy， deepcopy 等方法名的方法，构造方法接收本对象类型的参数<br>这里的例子依然是游戏世界的，魔法师，兽人，军队的创建</p>
<p><strong>基础接口抽象类</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">copy</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>支持深复制的对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Beast</span> <span class="keyword">extends</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Beast <span class="title">copy</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mage</span> <span class="keyword">extends</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Mage <span class="title">copy</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Warlord</span> <span class="keyword">extends</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Warlord <span class="title">copy</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElfBeast</span> <span class="keyword">extends</span> <span class="title">Beast</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String helpType;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ElfBeast</span><span class="params">(String helpType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.helpType = helpType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ElfBeast</span><span class="params">(ElfBeast elfBeast)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.helpType = elfBeast.helpType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Beast <span class="title">copy</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ElfBeast(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Elven eagle helps in "</span> + helpType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElfMage</span> <span class="keyword">extends</span> <span class="title">Mage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String helpType;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ElfMage</span><span class="params">(String helpType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.helpType = helpType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ElfMage</span><span class="params">(ElfMage elfMage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.helpType = elfMage.helpType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ElfMage <span class="title">copy</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ElfMage(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Elven mage helps in "</span> + helpType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElfWarlord</span> <span class="keyword">extends</span> <span class="title">Warlord</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String helpType;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ElfWarlord</span><span class="params">(String helpType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.helpType = helpType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ElfWarlord</span><span class="params">(ElfWarlord elfWarlord)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.helpType = elfWarlord.helpType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ElfWarlord <span class="title">copy</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ElfWarlord(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Elven warlord helps in "</span> + helpType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrcBeast</span> <span class="keyword">extends</span> <span class="title">Beast</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String weapon;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OrcBeast</span><span class="params">(String weapon)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weapon = weapon;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OrcBeast</span><span class="params">(OrcBeast orcBeast)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weapon = orcBeast.weapon;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Beast <span class="title">copy</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OrcBeast(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Orcish wolf attacks with "</span> + weapon;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrcMage</span> <span class="keyword">extends</span> <span class="title">Mage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String weapon;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OrcMage</span><span class="params">(String weapon)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weapon = weapon;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OrcMage</span><span class="params">(OrcMage orcMage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weapon = orcMage.weapon;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> OrcMage <span class="title">copy</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OrcMage(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Orcish mage attacks with "</span> + weapon;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrcWarlord</span> <span class="keyword">extends</span> <span class="title">Warlord</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String weapon;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OrcWarlord</span><span class="params">(String weapon)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weapon = weapon;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OrcWarlord</span><span class="params">(OrcWarlord orcWarlord)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weapon = orcWarlord.weapon;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> OrcWarlord <span class="title">copy</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OrcWarlord(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Orcish warlord attacks with "</span> + weapon;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">**使用**</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HeroFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Mage <span class="title">createMage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Warlord <span class="title">createWarlord</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Beast <span class="title">createBeast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroFactoryImpl</span> <span class="keyword">implements</span> <span class="title">HeroFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Mage mage;</span><br><span class="line">  <span class="keyword">private</span> Warlord warlord;</span><br><span class="line">  <span class="keyword">private</span> Beast beast;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructor</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HeroFactoryImpl</span><span class="params">(Mage mage, Warlord warlord, Beast beast)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mage = mage;</span><br><span class="line">    <span class="keyword">this</span>.warlord = warlord;</span><br><span class="line">    <span class="keyword">this</span>.beast = beast;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create mage</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Mage <span class="title">createMage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mage.copy();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create warlord</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Warlord <span class="title">createWarlord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> warlord.copy();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create beast</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Beast <span class="title">createBeast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> beast.copy();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HeroFactory factory;</span><br><span class="line">    Mage mage;</span><br><span class="line">    Warlord warlord;</span><br><span class="line">    Beast beast;</span><br><span class="line"></span><br><span class="line">    factory = <span class="keyword">new</span> HeroFactoryImpl(<span class="keyword">new</span> ElfMage(<span class="string">"cooking"</span>), <span class="keyword">new</span> ElfWarlord(<span class="string">"cleaning"</span>), <span class="keyword">new</span> ElfBeast(<span class="string">"protecting"</span>));</span><br><span class="line">    mage = factory.createMage();</span><br><span class="line">    warlord = factory.createWarlord();</span><br><span class="line">    beast = factory.createBeast();</span><br><span class="line">    LOGGER.info(mage.toString());</span><br><span class="line">    LOGGER.info(warlord.toString());</span><br><span class="line">    LOGGER.info(beast.toString());</span><br><span class="line"></span><br><span class="line">    factory = <span class="keyword">new</span> HeroFactoryImpl(<span class="keyword">new</span> OrcMage(<span class="string">"axe"</span>), <span class="keyword">new</span> OrcWarlord(<span class="string">"sword"</span>), <span class="keyword">new</span> OrcBeast(<span class="string">"laser"</span>));</span><br><span class="line">    mage = factory.createMage();</span><br><span class="line">    warlord = factory.createWarlord();</span><br><span class="line">    beast = factory.createBeast();</span><br><span class="line">    LOGGER.info(mage.toString());</span><br><span class="line">    LOGGER.info(warlord.toString());</span><br><span class="line">    LOGGER.info(beast.toString());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>构建工厂的时候先传原型进去，每次创建都是根据原型对象深复制来创建新对象。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/2019/08/29/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>组合模式(Composite Pattern)：组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式，它是一种对象结构型模式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p><strong>主要解决：</strong>它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p>
<p><strong>何时使用：</strong> </p>
<ol>
<li>您想表示对象的部分-整体层次结构（树形结构）。 </li>
<li>您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</li>
</ol>
<p><strong>如何解决：</strong>树枝和叶子实现统一接口，树枝内部组合该接口。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>好吧，这个模式的名字具有迷惑性，还以为是对象组合（虽然确实是），但是主要解决的是展示部分-整体的层次接口（可以看成树状的）<br>譬如说我们的句子有单词构成，单词由字母构成，还有公司组织结构 各个子部门最后到员工<br>当访问表示整体的对象的时候，会遍历里面所有的分支，这个还是看代码比较好理解</p>
<p><strong>骨架</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LetterComposite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;LetterComposite&gt; children = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(LetterComposite letter)</span> </span>&#123;</span><br><span class="line">    children.add(letter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> children.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">printThisBefore</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">printThisAfter</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Print</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    printThisBefore();</span><br><span class="line">    <span class="keyword">for</span> (LetterComposite letter : children) &#123;</span><br><span class="line">      letter.print();</span><br><span class="line">    &#125;</span><br><span class="line">    printThisAfter();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>顶层可以定义操作，实际上是访问所有部分完成对应操作，这里只定义了print，printThisBefore，printThisAfter 方法<br>而 before 和 after 是用在 print 里面完成辅助功能的，通常看做钩子方法</p>
<p><strong>实现</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Letter</span> <span class="keyword">extends</span> <span class="title">LetterComposite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Letter</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.c = c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">printThisBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.print(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Word</span> <span class="keyword">extends</span> <span class="title">LetterComposite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructor</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Word</span><span class="params">(List&lt;Letter&gt; letters)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Letter l : letters) &#123;</span><br><span class="line">      <span class="keyword">this</span>.add(l);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">printThisBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">" "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sentence</span> <span class="keyword">extends</span> <span class="title">LetterComposite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructor</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sentence</span><span class="params">(List&lt;Word&gt; words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Word w : words) &#123;</span><br><span class="line">      <span class="keyword">this</span>.add(w);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">printThisAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>使用</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Messenger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">LetterComposite <span class="title">messageFromOrcs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Word&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    words.add(<span class="keyword">new</span> Word(Arrays.asList(<span class="keyword">new</span> Letter(<span class="string">'W'</span>), <span class="keyword">new</span> Letter(<span class="string">'h'</span>), <span class="keyword">new</span> Letter(<span class="string">'e'</span>), <span class="keyword">new</span> Letter(</span><br><span class="line">        <span class="string">'r'</span>), <span class="keyword">new</span> Letter(<span class="string">'e'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> Word(Arrays.asList(<span class="keyword">new</span> Letter(<span class="string">'t'</span>), <span class="keyword">new</span> Letter(<span class="string">'h'</span>), <span class="keyword">new</span> Letter(<span class="string">'e'</span>), <span class="keyword">new</span> Letter(</span><br><span class="line">        <span class="string">'r'</span>), <span class="keyword">new</span> Letter(<span class="string">'e'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> Word(Arrays.asList(<span class="keyword">new</span> Letter(<span class="string">'i'</span>), <span class="keyword">new</span> Letter(<span class="string">'s'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> Word(Arrays.asList(<span class="keyword">new</span> Letter(<span class="string">'a'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> Word(Arrays.asList(<span class="keyword">new</span> Letter(<span class="string">'w'</span>), <span class="keyword">new</span> Letter(<span class="string">'h'</span>), <span class="keyword">new</span> Letter(<span class="string">'i'</span>), <span class="keyword">new</span> Letter(</span><br><span class="line">        <span class="string">'p'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> Word(Arrays.asList(<span class="keyword">new</span> Letter(<span class="string">'t'</span>), <span class="keyword">new</span> Letter(<span class="string">'h'</span>), <span class="keyword">new</span> Letter(<span class="string">'e'</span>), <span class="keyword">new</span> Letter(</span><br><span class="line">        <span class="string">'r'</span>), <span class="keyword">new</span> Letter(<span class="string">'e'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> Word(Arrays.asList(<span class="keyword">new</span> Letter(<span class="string">'i'</span>), <span class="keyword">new</span> Letter(<span class="string">'s'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> Word(Arrays.asList(<span class="keyword">new</span> Letter(<span class="string">'a'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> Word(Arrays.asList(<span class="keyword">new</span> Letter(<span class="string">'w'</span>), <span class="keyword">new</span> Letter(<span class="string">'a'</span>), <span class="keyword">new</span> Letter(<span class="string">'y'</span>))));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Sentence(words);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">LetterComposite <span class="title">messageFromElves</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Word&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    words.add(<span class="keyword">new</span> Word(Arrays.asList(<span class="keyword">new</span> Letter(<span class="string">'M'</span>), <span class="keyword">new</span> Letter(<span class="string">'u'</span>), <span class="keyword">new</span> Letter(<span class="string">'c'</span>), <span class="keyword">new</span> Letter(</span><br><span class="line">        <span class="string">'h'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> Word(Arrays.asList(<span class="keyword">new</span> Letter(<span class="string">'w'</span>), <span class="keyword">new</span> Letter(<span class="string">'i'</span>), <span class="keyword">new</span> Letter(<span class="string">'n'</span>), <span class="keyword">new</span> Letter(</span><br><span class="line">        <span class="string">'d'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> Word(Arrays.asList(<span class="keyword">new</span> Letter(<span class="string">'p'</span>), <span class="keyword">new</span> Letter(<span class="string">'o'</span>), <span class="keyword">new</span> Letter(<span class="string">'u'</span>), <span class="keyword">new</span> Letter(</span><br><span class="line">        <span class="string">'r'</span>), <span class="keyword">new</span> Letter(<span class="string">'s'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> Word(Arrays.asList(<span class="keyword">new</span> Letter(<span class="string">'f'</span>), <span class="keyword">new</span> Letter(<span class="string">'r'</span>), <span class="keyword">new</span> Letter(<span class="string">'o'</span>), <span class="keyword">new</span> Letter(</span><br><span class="line">        <span class="string">'m'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> Word(Arrays.asList(<span class="keyword">new</span> Letter(<span class="string">'y'</span>), <span class="keyword">new</span> Letter(<span class="string">'o'</span>), <span class="keyword">new</span> Letter(<span class="string">'u'</span>), <span class="keyword">new</span> Letter(</span><br><span class="line">        <span class="string">'r'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> Word(Arrays.asList(<span class="keyword">new</span> Letter(<span class="string">'m'</span>), <span class="keyword">new</span> Letter(<span class="string">'o'</span>), <span class="keyword">new</span> Letter(<span class="string">'u'</span>), <span class="keyword">new</span> Letter(</span><br><span class="line">        <span class="string">'t'</span>), <span class="keyword">new</span> Letter(<span class="string">'h'</span>))));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Sentence(words);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"Message from the orcs: "</span>);</span><br><span class="line"></span><br><span class="line">    LetterComposite orcMessage = <span class="keyword">new</span> Messenger().messageFromOrcs();</span><br><span class="line">    orcMessage.print();</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">"\nMessage from the elves: "</span>);</span><br><span class="line"></span><br><span class="line">    LetterComposite elfMessage = <span class="keyword">new</span> Messenger().messageFromElves();</span><br><span class="line">    elfMessage.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里面只有 Letter 是叶子对象，Word 和 Sentence 是容器对象</p>
<p>但是这里 Letter 并没有屏蔽 add 方法，会导致混乱<br>组合模式分为透明和安全<br>透明模式是说抽象里面就定义所有可以操作的方法（譬如上面的例子），但是容器和叶子（特别是叶子）可能要屏蔽一些方法来保证逻辑安全<br>安全模式是说抽象里面定义部分方法，具体到子类里面定义各自的方法（譬如容器才可以有add 方法），那么这样就不能做到统一的api了</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>状态模式</title>
    <url>/2019/08/27/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>状态模式(State Pattern)：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p>
<p><strong>主要解决：</strong>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</p>
<p><strong>何时使用：</strong>代码中包含大量与对象状态有关的条件语句。</p>
<p><strong>如何解决：</strong>将各种具体的状态类抽象出来。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>当一个类的表现取决于内部状态的变化的时候，将变化的状态抽象封装为一个 State，不同表现为 State 的子类（实现），表现在 state 实现  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onEnterState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">observe</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AngryState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(AngryState<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Mammoth mammoth;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AngryState</span><span class="params">(Mammoth mammoth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mammoth = mammoth;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125; is furious!"</span>, mammoth);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEnterState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125; gets angry!"</span>, mammoth);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeacefulState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(PeacefulState<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Mammoth mammoth;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PeacefulState</span><span class="params">(Mammoth mammoth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mammoth = mammoth;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125; is calm and peaceful."</span>, mammoth);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEnterState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125; calms down."</span>, mammoth);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部访问的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mammoth</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Mammoth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    state = <span class="keyword">new</span> PeacefulState(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Makes time pass for the mammoth</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timePasses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state.getClass().equals(PeacefulState<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">      changeStateTo(<span class="keyword">new</span> AngryState(<span class="keyword">this</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      changeStateTo(<span class="keyword">new</span> PeacefulState(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">changeStateTo</span><span class="params">(State newState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = newState;</span><br><span class="line">    <span class="keyword">this</span>.state.onEnterState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"The mammoth"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state.observe();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Mammoth mammoth = <span class="keyword">new</span> Mammoth();</span><br><span class="line">    mammoth.observe();</span><br><span class="line">    mammoth.timePasses();</span><br><span class="line">    mammoth.observe();</span><br><span class="line">    mammoth.timePasses();</span><br><span class="line">    mammoth.observe();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器模式</title>
    <url>/2019/08/25/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>装饰模式(Decorator Pattern)：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>
<p><strong>主要解决：</strong>一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p>
<p><strong>何时使用：</strong>在不想增加很多子类的情况下扩展类。</p>
<p><strong>如何解决：</strong>将具体功能职责划分，同时继承装饰者模式。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>好吧，这个模式跟代理模式真的很难分清楚，代码结构完全一样（基本），就算把理论上的区别说的再清楚，真到了写代码的时候，保准会迷糊。<br>结构上，装饰类（代理类）得跟具体类实现同样的接口，持有具体类。。。<br>那么从使用场景区分，装饰类可以做装饰（装饰只是一个说法而已，本质上还是在实际调用前后可以做其他事情），代理类做代理（所谓代理同左边注解）<br>一个区别是状态通常要调用具体类，代理有时可以拦截不去调用（太牵强）<br>还有装饰可以扩展不同的子装饰类，但是代理只要定义号了各种钩子方法（before after，around，throws 等），同样可以实现这种功能。。<br>有点迷<br>有一点是可以确定使用的代理的就是远程调用。。</p>
<p>直接上装饰模式的实例吧<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Troll</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getAttackPower</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fleeBattle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTroll</span> <span class="keyword">implements</span> <span class="title">Troll</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SimpleTroll<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"The troll tries to grab you!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAttackPower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fleeBattle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"The troll shrieks in horror and runs away!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClubbedTroll</span> <span class="keyword">implements</span> <span class="title">Troll</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ClubbedTroll<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Troll decorated;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClubbedTroll</span><span class="params">(Troll decorated)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.decorated = decorated;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    decorated.attack();</span><br><span class="line">    LOGGER.info(<span class="string">"The troll swings at you with a club!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAttackPower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> decorated.getAttackPower() + <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fleeBattle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    decorated.fleeBattle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// simple troll</span></span><br><span class="line">    LOGGER.info(<span class="string">"A simple looking troll approaches."</span>);</span><br><span class="line">    Troll troll = <span class="keyword">new</span> SimpleTroll();</span><br><span class="line">    troll.attack();</span><br><span class="line">    troll.fleeBattle();</span><br><span class="line">    LOGGER.info(<span class="string">"Simple troll power &#123;&#125;.\n"</span>, troll.getAttackPower());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change the behavior of the simple troll by adding a decorator</span></span><br><span class="line">    LOGGER.info(<span class="string">"A troll with huge club surprises you."</span>);</span><br><span class="line">    troll = <span class="keyword">new</span> ClubbedTroll(troll);</span><br><span class="line">    troll.attack();</span><br><span class="line">    troll.fleeBattle();</span><br><span class="line">    LOGGER.info(<span class="string">"Clubbed troll power &#123;&#125;.\n"</span>, troll.getAttackPower());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>中介者模式</title>
    <url>/2019/08/23/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>中介者模式(Mediator Pattern)：用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<p><strong>主要解决：</strong>对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。</p>
<p><strong>何时使用：</strong>多个类相互耦合，形成了网状结构。</p>
<p><strong>如何解决：</strong>将上述网状结构分离为星型结构。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>用的啥，将网状对象引用换成中心模式的，给的例子都是同一个基类继承下来的，中心类持有基类集合。。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中心类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Party</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addMember</span><span class="params">(PartyMember member)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">act</span><span class="params">(PartyMember actor, Action action)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PartyMember</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">joinedParty</span><span class="params">(Party party)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">partyAction</span><span class="params">(Action action)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">act</span><span class="params">(Action action)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Action &#123;</span><br><span class="line"></span><br><span class="line">  HUNT(<span class="string">"hunted a rabbit"</span>, <span class="string">"arrives for dinner"</span>), TALE(<span class="string">"tells a tale"</span>, <span class="string">"comes to listen"</span>), GOLD(</span><br><span class="line">      <span class="string">"found gold"</span>, <span class="string">"takes his share of the gold"</span>), ENEMY(<span class="string">"spotted enemies"</span>, <span class="string">"runs for cover"</span>), NONE(</span><br><span class="line">      <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line">  <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">  Action(String title, String description) &#123;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">    <span class="keyword">this</span>.description = description;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> description;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> title;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PartyMemberBase</span> <span class="keyword">implements</span> <span class="title">PartyMember</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(PartyMemberBase<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Party party;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">joinedParty</span><span class="params">(Party party)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125; joins the party"</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.party = party;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">partyAction</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125; &#123;&#125;"</span>, <span class="keyword">this</span>, action.getDescription());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (party != <span class="keyword">null</span>) &#123;</span><br><span class="line">      LOGGER.info(<span class="string">"&#123;&#125; &#123;&#125;"</span>, <span class="keyword">this</span>, action);</span><br><span class="line">      party.act(<span class="keyword">this</span>, action);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hobbit</span> <span class="keyword">extends</span> <span class="title">PartyMemberBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hobbit"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rogue</span> <span class="keyword">extends</span> <span class="title">PartyMemberBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Rogue"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hunter</span> <span class="keyword">extends</span> <span class="title">PartyMemberBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hunter"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wizard</span> <span class="keyword">extends</span> <span class="title">PartyMemberBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Wizard"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>中心类</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartyImpl</span> <span class="keyword">implements</span> <span class="title">Party</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;PartyMember&gt; members;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PartyImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    members = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">(PartyMember actor, Action action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (PartyMember member : members) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!member.equals(actor)) &#123;</span><br><span class="line">        member.partyAction(action);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMember</span><span class="params">(PartyMember member)</span> </span>&#123;</span><br><span class="line">    members.add(member);</span><br><span class="line">    member.joinedParty(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create party and members</span></span><br><span class="line">    Party party = <span class="keyword">new</span> PartyImpl();</span><br><span class="line">    Hobbit hobbit = <span class="keyword">new</span> Hobbit();</span><br><span class="line">    Wizard wizard = <span class="keyword">new</span> Wizard();</span><br><span class="line">    Rogue rogue = <span class="keyword">new</span> Rogue();</span><br><span class="line">    Hunter hunter = <span class="keyword">new</span> Hunter();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add party members</span></span><br><span class="line">    party.addMember(hobbit);</span><br><span class="line">    party.addMember(wizard);</span><br><span class="line">    party.addMember(rogue);</span><br><span class="line">    party.addMember(hunter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// perform actions -&gt; the other party members</span></span><br><span class="line">    <span class="comment">// are notified by the party</span></span><br><span class="line">    hobbit.act(Action.ENEMY);</span><br><span class="line">    wizard.act(Action.TALE);</span><br><span class="line">    rogue.act(Action.GOLD);</span><br><span class="line">    hunter.act(Action.HUNT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/2019/08/22/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>职责链模式(Chain of Responsibility  Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
<p><strong>主要解决：</strong>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p>
<p><strong>何时使用：</strong>在处理消息的时候以过滤很多道。</p>
<p><strong>如何解决：</strong>拦截的类都实现统一接口。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>虽然是一个行为型的模式，但是结构挺清晰的，就是按照单向链表的顺序组装一系列同类型的处理类，同第一个处理类开始处理，如果不处理就丢给下一个处理类处理，直到最后。<br>这个可以避免冗长的if else 代码，但是组装也挺麻烦的。<br>用的比较少，通常的链式，例如 Filter 等都是在一个 chain 统一维护所有处理类，依次调用（包含），每个类都可以在后面的处理类前后做事情，可以判断是否调用处理类，这样的链式比较靠谱点。   </p>
<p><strong>请求类</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The type of this request, used by each item in the chain to see if they should or can handle</span></span><br><span class="line"><span class="comment">   * this particular request</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RequestType requestType;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A description of the request</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String requestDescription;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Indicates if the request is handled or not. A request can only switch state from unhandled to</span></span><br><span class="line"><span class="comment">   * handled, there's no way to 'unhandle' a request</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create a new request of the given type and accompanied description.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> requestType        The type of request</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> requestDescription The description of the request</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(<span class="keyword">final</span> RequestType requestType, <span class="keyword">final</span> String requestDescription)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.requestType = Objects.requireNonNull(requestType);</span><br><span class="line">    <span class="keyword">this</span>.requestDescription = Objects.requireNonNull(requestDescription);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get a description of the request</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> A human readable description of the request</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getRequestDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> requestDescription;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get the type of this request, used by each person in the chain of command to see if they should</span></span><br><span class="line"><span class="comment">   * or can handle this particular request</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> The request type</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestType <span class="title">getRequestType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> requestType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Mark the request as handled</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markHandled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.handled = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Indicates if this request is handled or not</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; when the request is handled, &lt;tt&gt;false&lt;/tt&gt; if not</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHandled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.handled;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRequestDescription();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RequestType &#123;</span><br><span class="line"></span><br><span class="line">  DEFEND_CASTLE, TORTURE_PRISONER, COLLECT_TAX</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>请求处理类</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(RequestHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> RequestHandler next;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RequestHandler</span><span class="params">(RequestHandler next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Request handler</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Request req)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">      next.handleRequest(req);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">printHandling</span><span class="params">(Request req)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125; handling request \"&#123;&#125;\""</span>, <span class="keyword">this</span>, req);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrcSoldier</span> <span class="keyword">extends</span> <span class="title">RequestHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OrcSoldier</span><span class="params">(RequestHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Request req)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (req.getRequestType().equals(RequestType.COLLECT_TAX)) &#123;</span><br><span class="line">      printHandling(req);</span><br><span class="line">      req.markHandled();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.handleRequest(req);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Orc soldier"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrcOfficer</span> <span class="keyword">extends</span> <span class="title">RequestHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OrcOfficer</span><span class="params">(RequestHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Request req)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (req.getRequestType().equals(RequestType.TORTURE_PRISONER)) &#123;</span><br><span class="line">      printHandling(req);</span><br><span class="line">      req.markHandled();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.handleRequest(req);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Orc officer"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrcCommander</span> <span class="keyword">extends</span> <span class="title">RequestHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OrcCommander</span><span class="params">(RequestHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Request req)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (req.getRequestType().equals(RequestType.DEFEND_CASTLE)) &#123;</span><br><span class="line">      printHandling(req);</span><br><span class="line">      req.markHandled();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.handleRequest(req);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Orc commander"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>组装和调用</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrcKing</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  RequestHandler chain;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OrcKing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    buildChain();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    chain = <span class="keyword">new</span> OrcCommander(<span class="keyword">new</span> OrcOfficer(<span class="keyword">new</span> OrcSoldier(<span class="keyword">null</span>)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeRequest</span><span class="params">(Request req)</span> </span>&#123;</span><br><span class="line">    chain.handleRequest(req);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    OrcKing king = <span class="keyword">new</span> OrcKing();</span><br><span class="line">    king.makeRequest(<span class="keyword">new</span> Request(RequestType.DEFEND_CASTLE, <span class="string">"defend castle"</span>));</span><br><span class="line">    king.makeRequest(<span class="keyword">new</span> Request(RequestType.TORTURE_PRISONER, <span class="string">"torture prisoner"</span>));</span><br><span class="line">    king.makeRequest(<span class="keyword">new</span> Request(RequestType.COLLECT_TAX, <span class="string">"collect tax"</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2019/08/19/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p>
<p>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p><strong>主要解决：</strong>主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。</p>
<p><strong>何时使用：</strong> </p>
<ol>
<li>系统需要使用现有的类，而此类的接口不符合系统的需要。 </li>
<li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 </li>
<li>通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</li>
</ol>
<p><strong>如何解决：</strong>继承或依赖（组合）。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>代码结构相似的几个设计模式，适配，代理等<br>适配主要要从含义去理解，譬如在系统里面定义好了接口，系统都在使用接口<br>现在需要扩展，功能有第三方包实现了，他肯定没有实现系统里面定义的接口，怎么使用呢，那就是适配</p>
<p>下面的例子，船长开游艇，现在有一个渔船需要船长开，咋开，把它当做一个游艇开。。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Captain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> RowingBoat rowingBoat;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Captain</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Captain</span><span class="params">(RowingBoat rowingBoat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.rowingBoat = rowingBoat;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRowingBoat</span><span class="params">(RowingBoat rowingBoat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.rowingBoat = rowingBoat;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">row</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rowingBoat.row();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RowingBoat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">row</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FishingBoat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(FishingBoat<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"The fishing boat is sailing"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FishingBoatAdapter</span> <span class="keyword">implements</span> <span class="title">RowingBoat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> FishingBoat boat;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FishingBoatAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boat = <span class="keyword">new</span> FishingBoat();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">row</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boat.sail();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// The captain can only operate rowing boats but with adapter he is able to use fishing boats as well</span></span><br><span class="line">Captain captain = <span class="keyword">new</span> Captain(<span class="keyword">new</span> FishingBoatAdapter());</span><br><span class="line">captain.row();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意一点就是，如果用到了上面涉及模式，要在类名里面体现出来（FishingBoatAdapter），这样看的人就知道了</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/2019/08/18/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>
<p><strong>主要解决：</strong>主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p>
<p><strong>何时使用：</strong>一些基本部件不会变，而其组合经常变化的时候。</p>
<p><strong>如何解决：</strong>将变与不变分离开。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>王者荣耀或者英雄联盟，一个英雄对象的创建，每个英雄都有职业（法师，辅助，adc，战士等），名字（盖伦，赵信，小鲁班等），颜色，装备，武器等<br>这个属性都是有的，但是每个英雄都不一样，也就是构造的算法是稳定的，但是使用的部分对象是可以变化的</p>
<p><strong>英雄需要的属性</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Profession &#123;</span><br><span class="line"></span><br><span class="line">  WARRIOR, THIEF, MAGE, PRIEST;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name().toLowerCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> HairType &#123;</span><br><span class="line"></span><br><span class="line">  BALD(<span class="string">"bald"</span>), SHORT(<span class="string">"short"</span>), CURLY(<span class="string">"curly"</span>), LONG_STRAIGHT(<span class="string">"long straight"</span>), LONG_CURLY(</span><br><span class="line">      <span class="string">"long curly"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">  HairType(String title) &#123;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> title;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> HairColor &#123;</span><br><span class="line"></span><br><span class="line">  WHITE, BLOND, RED, BROWN, BLACK;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name().toLowerCase();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Armor &#123;</span><br><span class="line"></span><br><span class="line">  CLOTHES(<span class="string">"clothes"</span>), LEATHER(<span class="string">"leather"</span>), CHAIN_MAIL(<span class="string">"chain mail"</span>), PLATE_MAIL(<span class="string">"plate mail"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">  Armor(String title) &#123;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> title;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Weapon &#123;</span><br><span class="line"></span><br><span class="line">  DAGGER, SWORD, AXE, WARHAMMER, BOW;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name().toLowerCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>复杂对象</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Profession profession;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HairType hairType;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HairColor hairColor;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Armor armor;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Weapon weapon;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Hero</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.profession = builder.profession;</span><br><span class="line">    <span class="keyword">this</span>.name = builder.name;</span><br><span class="line">    <span class="keyword">this</span>.hairColor = builder.hairColor;</span><br><span class="line">    <span class="keyword">this</span>.hairType = builder.hairType;</span><br><span class="line">    <span class="keyword">this</span>.weapon = builder.weapon;</span><br><span class="line">    <span class="keyword">this</span>.armor = builder.armor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Profession <span class="title">getProfession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> profession;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HairType <span class="title">getHairType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hairType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HairColor <span class="title">getHairColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hairColor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Armor <span class="title">getArmor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> armor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Weapon <span class="title">getWeapon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> weapon;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">"This is a "</span>)</span><br><span class="line">            .append(profession)</span><br><span class="line">            .append(<span class="string">" named "</span>)</span><br><span class="line">            .append(name);</span><br><span class="line">    <span class="keyword">if</span> (hairColor != <span class="keyword">null</span> || hairType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      sb.append(<span class="string">" with "</span>);</span><br><span class="line">      <span class="keyword">if</span> (hairColor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sb.append(hairColor).append(<span class="string">' '</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (hairType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sb.append(hairType).append(<span class="string">' '</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      sb.append(hairType != HairType.BALD ? <span class="string">"hair"</span> : <span class="string">"head"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (armor != <span class="keyword">null</span>) &#123;</span><br><span class="line">      sb.append(<span class="string">" wearing "</span>).append(armor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (weapon != <span class="keyword">null</span>) &#123;</span><br><span class="line">      sb.append(<span class="string">" and wielding a "</span>).append(weapon);</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(<span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * The builder class.</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Profession profession;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HairType hairType;</span><br><span class="line">    <span class="keyword">private</span> HairColor hairColor;</span><br><span class="line">    <span class="keyword">private</span> Armor armor;</span><br><span class="line">    <span class="keyword">private</span> Weapon weapon;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Profession profession, String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (profession == <span class="keyword">null</span> || name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"profession and name can not be null"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.profession = profession;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">withHairType</span><span class="params">(HairType hairType)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.hairType = hairType;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">withHairColor</span><span class="params">(HairColor hairColor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.hairColor = hairColor;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">withArmor</span><span class="params">(Armor armor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.armor = armor;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">withWeapon</span><span class="params">(Weapon weapon)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.weapon = weapon;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hero <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Hero(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>使用</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Hero mage =</span><br><span class="line">        <span class="keyword">new</span> Hero.Builder(Profession.MAGE, <span class="string">"Riobard"</span>).withHairColor(HairColor.BLACK)</span><br><span class="line">            .withWeapon(Weapon.DAGGER).build();</span><br><span class="line">    LOGGER.info(mage.toString());</span><br><span class="line"></span><br><span class="line">    Hero warrior =</span><br><span class="line">        <span class="keyword">new</span> Hero.Builder(Profession.WARRIOR, <span class="string">"Amberjill"</span>).withHairColor(HairColor.BLOND)</span><br><span class="line">            .withHairType(HairType.LONG_CURLY).withArmor(Armor.CHAIN_MAIL).withWeapon(Weapon.SWORD)</span><br><span class="line">            .build();</span><br><span class="line">    LOGGER.info(warrior.toString());</span><br><span class="line"></span><br><span class="line">    Hero thief =</span><br><span class="line">        <span class="keyword">new</span> Hero.Builder(Profession.THIEF, <span class="string">"Desmond"</span>).withHairType(HairType.BALD)</span><br><span class="line">            .withWeapon(Weapon.BOW).build();</span><br><span class="line">    LOGGER.info(thief.toString());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>静态内部类相当于一个指挥者的角色，本来应该是在外面的，这里放在里面类型 Builder （effective java 里面提到的），感觉好理解一点<br>必须的属性，可选的属性，最后构建</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>外观模式</title>
    <url>/2019/08/17/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>外观模式：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<p>Facade Pattern: Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<p><strong>主要解决：</strong>降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。</p>
<p><strong>何时使用：</strong> </p>
<ol>
<li>客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 </li>
<li>定义系统的入口。</li>
</ol>
<p><strong>如何解决：</strong>客户端不与系统耦合，外观类与系统耦合。</p>
<p><strong>关键代码：</strong>在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>这个的理解就是各个模块尽量模块化，然其他模块尽可能少的依赖本系统过多的东西。好吧，怎么看起来说的跟外观模式没关系。<br>在一个业务实现过程中，为了做到可扩展，可复用等特性，会进行接口拆分业务拆分（就像桥接模式，各种组合调用），虽然做到了扩展性强<br>但是当真要完成一个功能（业务）的时候，就需要调用多个地方的方法，当本子系统（或者说第三方jar）需要将这个功能暴露出去的时候，别人肯定不想完成一个功能要调用这么多方法<br>这里就是外观了，对调用方来说，最简单的就是一个方法完成一个功能，虽然在内部会有很多方法调用，但是调用方并不关心，他只需要这个外观就行了。<br>其实不仅仅是代码细节，再往上层看，web 应用，每个url（可能还有 method）对应一个功能，功能内部会有很多数据库等操作，但是对应调用着来说，只用发对应http请求就行了。<br>这就是我理解的外观，统一入口，构建一个高层视图，调用方（依赖方）只依赖这个高层视图而不关心具体细节。    </p>
<p><strong>实现细节</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DwarvenMineWorker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(DwarvenMineWorker<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goToSleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125; goes to sleep."</span>, name());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wakeUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125; wakes up."</span>, name());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goHome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125; goes home."</span>, name());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goToMine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125; goes to the mine."</span>, name());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">      <span class="keyword">case</span> GO_TO_SLEEP:</span><br><span class="line">        goToSleep();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> WAKE_UP:</span><br><span class="line">        wakeUp();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> GO_HOME:</span><br><span class="line">        goHome();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> GO_TO_MINE:</span><br><span class="line">        goToMine();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> WORK:</span><br><span class="line">        work();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        LOGGER.info(<span class="string">"Undefined action"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Perform actions</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">(Action... actions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Action action : actions) &#123;</span><br><span class="line">      action(action);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">enum</span> Action &#123;</span><br><span class="line">    GO_TO_SLEEP, WAKE_UP, GO_HOME, GO_TO_MINE, WORK</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DwarvenGoldDigger</span> <span class="keyword">extends</span> <span class="title">DwarvenMineWorker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(DwarvenGoldDigger<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125; digs for gold."</span>, name());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Dwarf gold digger"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DwarvenCartOperator</span> <span class="keyword">extends</span> <span class="title">DwarvenMineWorker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(DwarvenCartOperator<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125; moves gold chunks out of the mine."</span>, name());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Dwarf cart operator"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DwarvenTunnelDigger</span> <span class="keyword">extends</span> <span class="title">DwarvenMineWorker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(DwarvenTunnelDigger<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125; creates another promising tunnel."</span>, name());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Dwarven tunnel digger"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>外观</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DwarvenGoldmineFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;DwarvenMineWorker&gt; workers;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructor</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DwarvenGoldmineFacade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    workers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    workers.add(<span class="keyword">new</span> DwarvenGoldDigger());</span><br><span class="line">    workers.add(<span class="keyword">new</span> DwarvenCartOperator());</span><br><span class="line">    workers.add(<span class="keyword">new</span> DwarvenTunnelDigger());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startNewDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    makeActions(workers, DwarvenMineWorker.Action.WAKE_UP, DwarvenMineWorker.Action.GO_TO_MINE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">digOutGold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    makeActions(workers, DwarvenMineWorker.Action.WORK);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    makeActions(workers, DwarvenMineWorker.Action.GO_HOME, DwarvenMineWorker.Action.GO_TO_SLEEP);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeActions</span><span class="params">(Collection&lt;DwarvenMineWorker&gt; workers,</span></span></span><br><span class="line"><span class="function"><span class="params">      DwarvenMineWorker.Action... actions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (DwarvenMineWorker worker : workers) &#123;</span><br><span class="line">      worker.action(actions);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DwarvenGoldmineFacade facade = <span class="keyword">new</span> DwarvenGoldmineFacade();</span><br><span class="line">    facade.startNewDay();</span><br><span class="line">    facade.digOutGold();</span><br><span class="line">    facade.endDay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>外观将聚合内部的各个细节，形成一个完整的功能对外发布</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/2019/08/15/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>将抽象部分与实现部分分离，使它们都可以独立的变化。</p>
<p><strong>主要解决：</strong>在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。</p>
<p><strong>何时使用：</strong>实现系统可能有多个角度分类，每一种角度都可能变化。</p>
<p><strong>如何解决：</strong>把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。</p>
<p><strong>关键代码：</strong>抽象类依赖实现类。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>又是一个容易混淆的模式，为啥会混淆，因为都是对象组合模式的，咋一看，结构都是差不多的，要分辨出来挺麻烦的。。。<br>个人理解，桥接模式，本质上就是分离出一个变化方向，并且抽象，通过组合的方式使用这个抽象，那么分离出来的这个方向就可以独立发展（扩展）<br>最后在使用的时候因为都是组合形式的，使用具体类构建，就可以组合成不同功能的类。<br>简单点说，就是在抽象层面就使用组合的方式（定义一个接口，这个接口依赖而不是继承另一个接口），然后可以在各自不同的维度扩展，最后在使用的时候组合具体的实现类。</p>
<p>这里的例子是武器，有不同的武器，每个武器都有魔法，不同的魔法。<br>那么我们可以在武器和魔法两个维度分别各自扩展<br>固定的需求是武器都有魔法，这个就是组合了</p>
<p><strong>组合</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wield</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swing</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unwield</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Enchantment <span class="title">getEnchantment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Enchantment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onActivate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onDeactivate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就是两个接口了，各自扩展<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sword</span> <span class="keyword">implements</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Sword<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Enchantment enchantment;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sword</span><span class="params">(Enchantment enchantment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.enchantment = enchantment;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wield</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"The sword is wielded."</span>);</span><br><span class="line">    enchantment.onActivate();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"The sword is swinged."</span>);</span><br><span class="line">    enchantment.apply();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unwield</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"The sword is unwielded."</span>);</span><br><span class="line">    enchantment.onDeactivate();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Enchantment <span class="title">getEnchantment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> enchantment;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hammer</span> <span class="keyword">implements</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Hammer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Enchantment enchantment;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Hammer</span><span class="params">(Enchantment enchantment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.enchantment = enchantment;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wield</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"The hammer is wielded."</span>);</span><br><span class="line">    enchantment.onActivate();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"The hammer is swinged."</span>);</span><br><span class="line">    enchantment.apply();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unwield</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"The hammer is unwielded."</span>);</span><br><span class="line">    enchantment.onDeactivate();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Enchantment <span class="title">getEnchantment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> enchantment;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoulEatingEnchantment</span> <span class="keyword">implements</span> <span class="title">Enchantment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SoulEatingEnchantment<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"The item spreads bloodlust."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"The item eats the soul of enemies."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDeactivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"Bloodlust slowly disappears."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyingEnchantment</span> <span class="keyword">implements</span> <span class="title">Enchantment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(FlyingEnchantment<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"The item begins to glow faintly."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"The item flies and strikes the enemies finally returning to owner's hand."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDeactivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"The item's glow fades."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>使用</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"The knight receives an enchanted sword."</span>);</span><br><span class="line">    Sword enchantedSword = <span class="keyword">new</span> Sword(<span class="keyword">new</span> SoulEatingEnchantment());</span><br><span class="line">    enchantedSword.wield();</span><br><span class="line">    enchantedSword.swing();</span><br><span class="line">    enchantedSword.unwield();</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">"The valkyrie receives an enchanted hammer."</span>);</span><br><span class="line">    Hammer hammer = <span class="keyword">new</span> Hammer(<span class="keyword">new</span> FlyingEnchantment());</span><br><span class="line">    hammer.wield();</span><br><span class="line">    hammer.swing();</span><br><span class="line">    hammer.unwield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>抽象就使用组合的方式，具体构建的时候使用具体的实现类，不过正在在写代码的时候通常由 ioc 容器帮我们组装</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>模板模式</title>
    <url>/2019/08/14/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>模板方法模式：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p><strong>主要解决：</strong>一些方法通用，却在每一个子类都重新写了这一方法。</p>
<p><strong>何时使用：</strong>有一些通用的方法。</p>
<p><strong>如何解决：</strong>将这些通用算法抽象出来。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>模板模式，在一个业务流程固定，业务实现细节可变的情况下使用，在模板类的业务方法里面留出钩子方法给子类实现    </p>
<p><strong>模板</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StealingMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(StealingMethod<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">pickTarget</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">confuseTarget</span><span class="params">(String target)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">stealTheItem</span><span class="params">(String target)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Steal</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">steal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String target = pickTarget();</span><br><span class="line">    LOGGER.info(<span class="string">"The target has been chosen as &#123;&#125;."</span>, target);</span><br><span class="line">    confuseTarget(target);</span><br><span class="line">    stealTheItem(target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HitAndRunMethod</span> <span class="keyword">extends</span> <span class="title">StealingMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(HitAndRunMethod<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">pickTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"old goblin woman"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">confuseTarget</span><span class="params">(String target)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"Approach the &#123;&#125; from behind."</span>, target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">stealTheItem</span><span class="params">(String target)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"Grab the handbag and run away fast!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubtleMethod</span> <span class="keyword">extends</span> <span class="title">StealingMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SubtleMethod<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">pickTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"shop keeper"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">confuseTarget</span><span class="params">(String target)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"Approach the &#123;&#125; with tears running and hug him!"</span>, target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">stealTheItem</span><span class="params">(String target)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"While in close contact grab the &#123;&#125;'s wallet."</span>, target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>使用</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HalflingThief</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> StealingMethod method;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HalflingThief</span><span class="params">(StealingMethod method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.method = method;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">steal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    method.steal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeMethod</span><span class="params">(StealingMethod method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.method = method;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HalflingThief thief = <span class="keyword">new</span> HalflingThief(<span class="keyword">new</span> HitAndRunMethod());</span><br><span class="line">    thief.steal();</span><br><span class="line">    thief.changeMethod(<span class="keyword">new</span> SubtleMethod());</span><br><span class="line">    thief.steal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/2019/08/13/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>命令模式(Command Pattern)：将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p>
<p><strong>主要解决：</strong>在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p>
<p><strong>何时使用：</strong>在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p>
<p><strong>如何解决：</strong>通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>个人理解，就是将功能封装成命令，但是不要直接执行，而是交给一个执行器统一执行，这么做的好处，是可以记录命令执行记录，这样就可以有撤销，重做等操作。<br>特别注意的一点是，命令不仅仅只参数，还是功能实现，这个容易弄错。    </p>
<p><strong>命令针对的对象</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Target<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Size size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Visibility visibility;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Size <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(Size size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Visibility <span class="title">getVisibility</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> visibility;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVisibility</span><span class="params">(Visibility visibility)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.visibility = visibility;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Print status</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125;, [size=&#123;&#125;] [visibility=&#123;&#125;]"</span>, <span class="keyword">this</span>, getSize(), getVisibility());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goblin</span> <span class="keyword">extends</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Goblin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setSize(Size.NORMAL);</span><br><span class="line">    setVisibility(Visibility.VISIBLE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Goblin"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Size &#123;</span><br><span class="line"></span><br><span class="line">  SMALL(<span class="string">"small"</span>), NORMAL(<span class="string">"normal"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">  Size(String title) &#123;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> title;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Visibility &#123;</span><br><span class="line"></span><br><span class="line">  VISIBLE(<span class="string">"visible"</span>), INVISIBLE(<span class="string">"invisible"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">  Visibility(String title) &#123;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> title;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>命令</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Target target)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">redo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShrinkSpell</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Size oldSize;</span><br><span class="line">  <span class="keyword">private</span> Target target;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Target target)</span> </span>&#123;</span><br><span class="line">    oldSize = target.getSize();</span><br><span class="line">    target.setSize(Size.SMALL);</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (oldSize != <span class="keyword">null</span> &amp;&amp; target != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Size temp = target.getSize();</span><br><span class="line">      target.setSize(oldSize);</span><br><span class="line">      oldSize = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    undo();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Shrink spell"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvisibilitySpell</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Target target;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Target target)</span> </span>&#123;</span><br><span class="line">    target.setVisibility(Visibility.INVISIBLE);</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">      target.setVisibility(Visibility.VISIBLE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">      target.setVisibility(Visibility.INVISIBLE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Invisibility spell"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>执行器</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wizard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Wizard<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Deque&lt;Command&gt; undoStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> Deque&lt;Command&gt; redoStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Wizard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// comment to ignore sonar issue: LEVEL critical</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Cast spell</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">castSpell</span><span class="params">(Command command, Target target)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125; casts &#123;&#125; at &#123;&#125;"</span>, <span class="keyword">this</span>, command, target);</span><br><span class="line">    command.execute(target);</span><br><span class="line">    undoStack.offerLast(command);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Undo last spell</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undoLastSpell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!undoStack.isEmpty()) &#123;</span><br><span class="line">      Command previousSpell = undoStack.pollLast();</span><br><span class="line">      redoStack.offerLast(previousSpell);</span><br><span class="line">      LOGGER.info(<span class="string">"&#123;&#125; undoes &#123;&#125;"</span>, <span class="keyword">this</span>, previousSpell);</span><br><span class="line">      previousSpell.undo();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Redo last spell</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redoLastSpell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!redoStack.isEmpty()) &#123;</span><br><span class="line">      Command previousSpell = redoStack.pollLast();</span><br><span class="line">      undoStack.offerLast(previousSpell);</span><br><span class="line">      LOGGER.info(<span class="string">"&#123;&#125; redoes &#123;&#125;"</span>, <span class="keyword">this</span>, previousSpell);</span><br><span class="line">      previousSpell.redo();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Wizard"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>调用</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Wizard wizard = <span class="keyword">new</span> Wizard();</span><br><span class="line">    Goblin goblin = <span class="keyword">new</span> Goblin();</span><br><span class="line"></span><br><span class="line">    goblin.printStatus();</span><br><span class="line"></span><br><span class="line">    wizard.castSpell(<span class="keyword">new</span> ShrinkSpell(), goblin);</span><br><span class="line">    goblin.printStatus();</span><br><span class="line"></span><br><span class="line">    wizard.castSpell(<span class="keyword">new</span> InvisibilitySpell(), goblin);</span><br><span class="line">    goblin.printStatus();</span><br><span class="line"></span><br><span class="line">    wizard.undoLastSpell();</span><br><span class="line">    goblin.printStatus();</span><br><span class="line"></span><br><span class="line">    wizard.undoLastSpell();</span><br><span class="line">    goblin.printStatus();</span><br><span class="line"></span><br><span class="line">    wizard.redoLastSpell();</span><br><span class="line">    goblin.printStatus();</span><br><span class="line"></span><br><span class="line">    wizard.redoLastSpell();</span><br><span class="line">    goblin.printStatus();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>访问者模式</title>
    <url>/2019/08/12/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>访问者模式(Visitor Pattern):提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式是一种对象行为型模式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>主要将数据结构与数据操作分离。</p>
<p><strong>主要解决：</strong>稳定的数据结构和易变的操作耦合问题。</p>
<p><strong>何时使用：</strong>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。</p>
<p><strong>如何解决：</strong>在被访问的类里面加一个对外提供接待访问者的接口。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>访问者模式，用在想要以不同方式访问稳定结构中的部分或者全部元素，方式可能变化，但是数据是稳定的。    </p>
<p><strong>结构</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Unit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Unit[] children;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Unit</span><span class="params">(Unit... children)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.children = children;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Accept visitor</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(UnitVisitor visitor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Unit child : children) &#123;</span><br><span class="line">      child.accept(visitor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> <span class="keyword">extends</span> <span class="title">Unit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Soldier</span><span class="params">(Unit... children)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(children);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(UnitVisitor visitor)</span> </span>&#123;</span><br><span class="line">    visitor.visitSoldier(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">super</span>.accept(visitor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"soldier"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sergeant</span> <span class="keyword">extends</span> <span class="title">Unit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sergeant</span><span class="params">(Unit... children)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(children);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(UnitVisitor visitor)</span> </span>&#123;</span><br><span class="line">    visitor.visitSergeant(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">super</span>.accept(visitor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"sergeant"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Commander</span> <span class="keyword">extends</span> <span class="title">Unit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Commander</span><span class="params">(Unit... children)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(children);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(UnitVisitor visitor)</span> </span>&#123;</span><br><span class="line">    visitor.visitCommander(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">super</span>.accept(visitor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"commander"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>访问</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UnitVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">visitSoldier</span><span class="params">(Soldier soldier)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">visitSergeant</span><span class="params">(Sergeant sergeant)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">visitCommander</span><span class="params">(Commander commander)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoldierVisitor</span> <span class="keyword">implements</span> <span class="title">UnitVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SoldierVisitor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitSoldier</span><span class="params">(Soldier soldier)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"Greetings &#123;&#125;"</span>, soldier);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitSergeant</span><span class="params">(Sergeant sergeant)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do nothing</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCommander</span><span class="params">(Commander commander)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do nothing</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommanderVisitor</span> <span class="keyword">implements</span> <span class="title">UnitVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(CommanderVisitor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitSoldier</span><span class="params">(Soldier soldier)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do nothing</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitSergeant</span><span class="params">(Sergeant sergeant)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do nothing</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCommander</span><span class="params">(Commander commander)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"Good to see you &#123;&#125;"</span>, commander);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SergeantVisitor</span> <span class="keyword">implements</span> <span class="title">UnitVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SergeantVisitor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitSoldier</span><span class="params">(Soldier soldier)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do nothing</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitSergeant</span><span class="params">(Sergeant sergeant)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"Hello &#123;&#125;"</span>, sergeant);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCommander</span><span class="params">(Commander commander)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do nothing</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，在visitor 接口里面使用到类具体类了，因此结构要是稳定的，否则这里扩展麻烦  </p>
<p><strong>使用</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Commander commander =</span><br><span class="line">        <span class="keyword">new</span> Commander(<span class="keyword">new</span> Sergeant(<span class="keyword">new</span> Soldier(), <span class="keyword">new</span> Soldier(), <span class="keyword">new</span> Soldier()), <span class="keyword">new</span> Sergeant(</span><br><span class="line">            <span class="keyword">new</span> Soldier(), <span class="keyword">new</span> Soldier(), <span class="keyword">new</span> Soldier()));</span><br><span class="line">    commander.accept(<span class="keyword">new</span> SoldierVisitor());</span><br><span class="line">    commander.accept(<span class="keyword">new</span> SergeantVisitor());</span><br><span class="line">    commander.accept(<span class="keyword">new</span> CommanderVisitor());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以通过传入不同的 visitor，实现不同的访问。    </p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>解释器模式</title>
    <url>/2019/08/11/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>解释器模式(Interpreter Pattern)：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。解释器模式是一种类行为型模式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p>
<p><strong>主要解决：</strong>对于一些固定文法构建一个解释句子的解释器。</p>
<p><strong>何时使用：</strong>如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</p>
<p><strong>如何解决：</strong>构件语法树，定义终结符与非终结符。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>这个模式用的非常少，代码结构不复杂，难点在于语法设计。要满足语法规则，构建语法树，根据语法树来完成解析。<br>而稍微复杂一点的语法设计，其语法树就挺庞大的。。    </p>
<p><strong>实例</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NumberExpression</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.number = number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NumberExpression</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.number = Integer.parseInt(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"number"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiplyExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Expression leftExpression;</span><br><span class="line">  <span class="keyword">private</span> Expression rightExpression;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MultiplyExpression</span><span class="params">(Expression leftExpression, Expression rightExpression)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.leftExpression = leftExpression;</span><br><span class="line">    <span class="keyword">this</span>.rightExpression = rightExpression;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> leftExpression.interpret() * rightExpression.interpret();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"*"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlusExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Expression leftExpression;</span><br><span class="line">  <span class="keyword">private</span> Expression rightExpression;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PlusExpression</span><span class="params">(Expression leftExpression, Expression rightExpression)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.leftExpression = leftExpression;</span><br><span class="line">    <span class="keyword">this</span>.rightExpression = rightExpression;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> leftExpression.interpret() + rightExpression.interpret();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"+"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinusExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Expression leftExpression;</span><br><span class="line">  <span class="keyword">private</span> Expression rightExpression;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MinusExpression</span><span class="params">(Expression leftExpression, Expression rightExpression)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.leftExpression = leftExpression;</span><br><span class="line">    <span class="keyword">this</span>.rightExpression = rightExpression;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> leftExpression.interpret() - rightExpression.interpret();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"-"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>使用</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String tokenString = <span class="string">"4 3 2 - 1 + *"</span>;</span><br><span class="line">    Stack&lt;Expression&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    String[] tokenList = tokenString.split(<span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : tokenList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isOperator(s)) &#123;</span><br><span class="line">        Expression rightExpression = stack.pop();</span><br><span class="line">        Expression leftExpression = stack.pop();</span><br><span class="line">        LOGGER.info(<span class="string">"popped from stack left: &#123;&#125; right: &#123;&#125;"</span>,</span><br><span class="line">            leftExpression.interpret(), rightExpression.interpret());</span><br><span class="line">        Expression operator = getOperatorInstance(s, leftExpression, rightExpression);</span><br><span class="line">        LOGGER.info(<span class="string">"operator: &#123;&#125;"</span>, operator);</span><br><span class="line">        <span class="keyword">int</span> result = operator.interpret();</span><br><span class="line">        NumberExpression resultExpression = <span class="keyword">new</span> NumberExpression(result);</span><br><span class="line">        stack.push(resultExpression);</span><br><span class="line">        LOGGER.info(<span class="string">"push result to stack: &#123;&#125;"</span>, resultExpression.interpret());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Expression i = <span class="keyword">new</span> NumberExpression(s);</span><br><span class="line">        stack.push(i);</span><br><span class="line">        LOGGER.info(<span class="string">"push to stack: &#123;&#125;"</span>, i.interpret());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGGER.info(<span class="string">"result: &#123;&#125;"</span>, stack.pop().interpret());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOperator</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.equals(<span class="string">"+"</span>) || s.equals(<span class="string">"-"</span>) || s.equals(<span class="string">"*"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get expression for string</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Expression <span class="title">getOperatorInstance</span><span class="params">(String s, Expression left, Expression right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PlusExpression(left, right);</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MinusExpression(left, right);</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MultiplyExpression(left, right);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MultiplyExpression(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2019/08/10/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>观察者模式(Observer Pattern)：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p>
<p><strong>何时使用：</strong>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p>
<p><strong>如何解决：</strong>使用面向对象技术，可以将这种依赖关系弱化。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>这个模式使用非常频繁，Rx 系列就是这种模式的实例。<br>主要是观察者和观察对象，当观察对象有变化的时候通知观察者  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 观察者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WeatherObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(WeatherType currentWeather)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orcs</span> <span class="keyword">implements</span> <span class="title">WeatherObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Orcs<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(WeatherType currentWeather)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (currentWeather) &#123;</span><br><span class="line">      <span class="keyword">case</span> COLD:</span><br><span class="line">        LOGGER.info(<span class="string">"The orcs are freezing cold."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> RAINY:</span><br><span class="line">        LOGGER.info(<span class="string">"The orcs are dripping wet."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> SUNNY:</span><br><span class="line">        LOGGER.info(<span class="string">"The sun hurts the orcs' eyes."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> WINDY:</span><br><span class="line">        LOGGER.info(<span class="string">"The orc smell almost vanishes in the wind."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hobbits</span> <span class="keyword">implements</span> <span class="title">WeatherObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Hobbits<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(WeatherType currentWeather)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (currentWeather) &#123;</span><br><span class="line">      <span class="keyword">case</span> COLD:</span><br><span class="line">        LOGGER.info(<span class="string">"The hobbits are shivering in the cold weather."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> RAINY:</span><br><span class="line">        LOGGER.info(<span class="string">"The hobbits look for cover from the rain."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> SUNNY:</span><br><span class="line">        LOGGER.info(<span class="string">"The happy hobbits bade in the warm sun."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> WINDY:</span><br><span class="line">        LOGGER.info(<span class="string">"The hobbits hold their hats tightly in the windy weather."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> WeatherType &#123;</span><br><span class="line"></span><br><span class="line">  SUNNY, RAINY, WINDY, COLD;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name().toLowerCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 待观察对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weather</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Weather<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> WeatherType currentWeather;</span><br><span class="line">  <span class="keyword">private</span> List&lt;WeatherObserver&gt; observers;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Weather</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    currentWeather = WeatherType.SUNNY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(WeatherObserver obs)</span> </span>&#123;</span><br><span class="line">    observers.add(obs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(WeatherObserver obs)</span> </span>&#123;</span><br><span class="line">    observers.remove(obs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Makes time pass for weather</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timePasses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WeatherType[] enumValues = WeatherType.values();</span><br><span class="line">    currentWeather = enumValues[(currentWeather.ordinal() + <span class="number">1</span>) % enumValues.length];</span><br><span class="line">    LOGGER.info(<span class="string">"The weather changed to &#123;&#125;."</span>, currentWeather);</span><br><span class="line">    notifyObservers();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (WeatherObserver obs : observers) &#123;</span><br><span class="line">      obs.update(currentWeather);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Weather weather = <span class="keyword">new</span> Weather();</span><br><span class="line">    weather.addObserver(<span class="keyword">new</span> Orcs());</span><br><span class="line">    weather.addObserver(<span class="keyword">new</span> Hobbits());</span><br><span class="line"></span><br><span class="line">    weather.timePasses();</span><br><span class="line">    weather.timePasses();</span><br><span class="line">    weather.timePasses();</span><br><span class="line">    weather.timePasses();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2019/08/08/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图</strong>：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。<br><strong>主要解决</strong>：主要解决接口选择的问题。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>铁匠可以打造武器，根据指定的类型返回不同的武器<br>兽人铁匠打造兽人武器<br>精灵铁匠打造精灵武器（精灵有铁匠吗。。）<br><strong>工厂接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 铁匠，一个抽象的概念，不同种族的铁匠打造对应种族的武器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Blacksmith</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Weapon <span class="title">manufactureWeapon</span><span class="params">(WeaponType weaponType)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其他相关类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> WeaponType &#123;</span><br><span class="line"></span><br><span class="line">  SHORT_SWORD(<span class="string">"short sword"</span>), SPEAR(<span class="string">"spear"</span>), AXE(<span class="string">"axe"</span>), UNDEFINED(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">  WeaponType(String title) &#123;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> title;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">WeaponType <span class="title">getWeaponType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrcWeapon</span> <span class="keyword">implements</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> WeaponType weaponType;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OrcWeapon</span><span class="params">(WeaponType weaponType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weaponType = weaponType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Orcish "</span> + weaponType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> WeaponType <span class="title">getWeaponType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> weaponType;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElfWeapon</span> <span class="keyword">implements</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> WeaponType weaponType;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ElfWeapon</span><span class="params">(WeaponType weaponType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weaponType = weaponType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Elven "</span> + weaponType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> WeaponType <span class="title">getWeaponType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> weaponType;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>工厂接口实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 精灵铁匠</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElfBlacksmith</span> <span class="keyword">implements</span> <span class="title">Blacksmith</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Weapon <span class="title">manufactureWeapon</span><span class="params">(WeaponType weaponType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ElfWeapon(weaponType);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兽人铁匠</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrcBlacksmith</span> <span class="keyword">implements</span> <span class="title">Blacksmith</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Weapon <span class="title">manufactureWeapon</span><span class="params">(WeaponType weaponType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OrcWeapon(weaponType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>简单工厂<br>根据传入的参数来决定使用什么对象<br>正常的简单工厂使用静态方法的，里面if else 判断<br>来个lambda + map的  </p>
<p><strong>工厂类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WeaponFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates an instance of the given type.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name representing enum of an object type to be created.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> new instance of a requested class implementing &#123;<span class="doctag">@link</span> Weapon&#125; interface.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Weapon <span class="title">create</span><span class="params">(WeaponType name)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates factory - placeholder for specified &#123;<span class="doctag">@link</span> Builder&#125;s.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> consumer for the new builder to the factory.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> factory with specified &#123;<span class="doctag">@link</span> Builder&#125;s</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 是不是很神奇，这里吧 map 的 put 方法， 当做一个 builder 方法传给 Consumer 了</span></span><br><span class="line">  <span class="comment">// 而 Builder 里面的 add 方法的参数 Supplier&lt;Weapon&gt; 实际上就是无参返回值为 Weapon 的函数，而各个 Weapon 的无惨构造方法就是这样的</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> WeaponFactory <span class="title">factory</span><span class="params">(Consumer&lt;Builder&gt; consumer)</span> </span>&#123;</span><br><span class="line">    Map&lt;WeaponType, Supplier&lt;Weapon&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    consumer.accept(map::put);</span><br><span class="line">    <span class="keyword">return</span> name -&gt; map.get(name).get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">**相关类**</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(WeaponType name, Supplier&lt;Weapon&gt; supplier)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> WeaponType &#123;</span><br><span class="line">  SWORD, AXE, BOW, SPEAR</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bow</span> <span class="keyword">implements</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Bow"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sword</span> <span class="keyword">implements</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Sword"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Axe</span> <span class="keyword">implements</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Axe"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Spear</span> <span class="keyword">implements</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Spear"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    WeaponFactory factory = WeaponFactory.factory(builder -&gt; &#123;</span><br><span class="line">      builder.add(WeaponType.SWORD, Sword::<span class="keyword">new</span>);</span><br><span class="line">      builder.add(WeaponType.AXE, Axe::<span class="keyword">new</span>);</span><br><span class="line">      builder.add(WeaponType.SPEAR, Spear::<span class="keyword">new</span>);</span><br><span class="line">      builder.add(WeaponType.BOW, Bow::<span class="keyword">new</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    Weapon axe = factory.create(WeaponType.AXE);</span><br><span class="line">    LOGGER.info(axe.toString());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2019/08/07/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>代理模式：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。</p>
<p>Proxy Pattern: Provide a surrogate or placeholder for another object to control access to it.</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><strong>主要解决：</strong>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p>
<p><strong>何时使用：</strong>想在访问一个类时做一些控制。</p>
<p><strong>如何解决：</strong>增加中间层。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>这个在装饰模式就说过了，跟装饰太像了，除了远程访问，其他情况基本跟装饰一样的结构。。。<br>这里的代理应该称为静态代理，通常我们用代理是动态代理（如果要代理的对象很少的情况下，静态代理还好，要是很多，那就是噩梦了）  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wizard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Wizard</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WizardTower</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enter</span><span class="params">(Wizard wizard)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IvoryTower</span> <span class="keyword">implements</span> <span class="title">WizardTower</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(IvoryTower<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enter</span><span class="params">(Wizard wizard)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125; enters the tower."</span>, wizard);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WizardTowerProxy</span> <span class="keyword">implements</span> <span class="title">WizardTower</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(WizardTowerProxy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_WIZARDS_ALLOWED = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> numWizards;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> WizardTower tower;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">WizardTowerProxy</span><span class="params">(WizardTower tower)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.tower = tower;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enter</span><span class="params">(Wizard wizard)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numWizards &lt; NUM_WIZARDS_ALLOWED) &#123;</span><br><span class="line">      tower.enter(wizard);</span><br><span class="line">      numWizards++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LOGGER.info(<span class="string">"&#123;&#125; is not allowed to enter!"</span>, wizard);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    WizardTowerProxy proxy = <span class="keyword">new</span> WizardTowerProxy(<span class="keyword">new</span> IvoryTower());</span><br><span class="line">    proxy.enter(<span class="keyword">new</span> Wizard(<span class="string">"Red wizard"</span>));</span><br><span class="line">    proxy.enter(<span class="keyword">new</span> Wizard(<span class="string">"White wizard"</span>));</span><br><span class="line">    proxy.enter(<span class="keyword">new</span> Wizard(<span class="string">"Black wizard"</span>));</span><br><span class="line">    proxy.enter(<span class="keyword">new</span> Wizard(<span class="string">"Green wizard"</span>));</span><br><span class="line">    proxy.enter(<span class="keyword">new</span> Wizard(<span class="string">"Brown wizard"</span>));</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2019/08/06/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>策略模式(Strategy Pattern)：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。策略模式是一种对象行为型模式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p>
<p><strong>主要解决：</strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p>
<p><strong>何时使用：</strong>一个系统有许多许多类，而区分它们的只是他们直接的行为。</p>
<p><strong>如何解决：</strong>将这些算法封装成一个一个的类，任意地替换。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>这个模式用的比较多，就是将计算过程（或者业务过程）抽象，在业务使用的时候可以配置选择    </p>
<p><strong>策略</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DragonSlayingStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeleeStrategy</span> <span class="keyword">implements</span> <span class="title">DragonSlayingStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MeleeStrategy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"With your Excalibur you sever the dragon's head!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProjectileStrategy</span> <span class="keyword">implements</span> <span class="title">DragonSlayingStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ProjectileStrategy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"You shoot the dragon with the magical crossbow and it falls dead on the ground!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellStrategy</span> <span class="keyword">implements</span> <span class="title">DragonSlayingStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SpellStrategy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"You cast the spell of disintegration and the dragon vaporizes in a pile of dust!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>调用</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DragonSlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> DragonSlayingStrategy strategy;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DragonSlayer</span><span class="params">(DragonSlayingStrategy strategy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeStrategy</span><span class="params">(DragonSlayingStrategy strategy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goToBattle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    strategy.execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// GoF Strategy pattern</span></span><br><span class="line">    LOGGER.info(<span class="string">"Green dragon spotted ahead!"</span>);</span><br><span class="line">    DragonSlayer dragonSlayer = <span class="keyword">new</span> DragonSlayer(<span class="keyword">new</span> MeleeStrategy());</span><br><span class="line">    dragonSlayer.goToBattle();</span><br><span class="line">    LOGGER.info(<span class="string">"Red dragon emerges."</span>);</span><br><span class="line">    dragonSlayer.changeStrategy(<span class="keyword">new</span> ProjectileStrategy());</span><br><span class="line">    dragonSlayer.goToBattle();</span><br><span class="line">    LOGGER.info(<span class="string">"Black dragon lands before you."</span>);</span><br><span class="line">    dragonSlayer.changeStrategy(<span class="keyword">new</span> SpellStrategy());</span><br><span class="line">    dragonSlayer.goToBattle();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Java 8 Strategy pattern</span></span><br><span class="line">    LOGGER.info(<span class="string">"Green dragon spotted ahead!"</span>);</span><br><span class="line">    dragonSlayer = <span class="keyword">new</span> DragonSlayer(</span><br><span class="line">        () -&gt; LOGGER.info(<span class="string">"With your Excalibur you severe the dragon's head!"</span>));</span><br><span class="line">    dragonSlayer.goToBattle();</span><br><span class="line">    LOGGER.info(<span class="string">"Red dragon emerges."</span>);</span><br><span class="line">    dragonSlayer.changeStrategy(() -&gt; LOGGER.info(</span><br><span class="line">        <span class="string">"You shoot the dragon with the magical crossbow and it falls dead on the ground!"</span>));</span><br><span class="line">    dragonSlayer.goToBattle();</span><br><span class="line">    LOGGER.info(<span class="string">"Black dragon lands before you."</span>);</span><br><span class="line">    dragonSlayer.changeStrategy(() -&gt; LOGGER.info(</span><br><span class="line">        <span class="string">"You cast the spell of disintegration and the dragon vaporizes in a pile of dust!"</span>));</span><br><span class="line">    dragonSlayer.goToBattle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象工厂</title>
    <url>/2019/08/04/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<p><strong>主要解决：</strong>主要解决接口选择的问题。</p>
<p><strong>何时使用：</strong>系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p>
<p><strong>如何解决：</strong>在一个产品族里面，定义多个产品。</p>
<p><strong>关键代码：</strong>在一个工厂里聚合多个同类产品。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>王国工厂<br>每个王国有 国王，城堡，军队<br>王国工厂就是用来创建不同种族的王国的<br>精灵王国工厂创建精灵城堡，精灵王，精灵军队<br>兽人王国工厂创建兽人城堡，兽人王，兽人军队<br>这里，国王，城堡，军队，代表着产品族，而精灵，兽人代表产品等级<br>工厂是按照等级划分的，每个工厂都可以返回一个产品族的产品，<br>系统在使用的时候，应该是每次使用一个产品族，而不是多个产品等级<br><em>扩展产品等级容易，扩展产品族难</em><br>就是说添加不同的王国容易，想添加王国内的成员难</p>
<p><strong>产品族相关</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Castle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">King</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Army</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>各自产品族的实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElfArmy</span> <span class="keyword">implements</span> <span class="title">Army</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> String DESCRIPTION = <span class="string">"This is the Elven Army!"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DESCRIPTION;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElfCastle</span> <span class="keyword">implements</span> <span class="title">Castle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> String DESCRIPTION = <span class="string">"This is the Elven castle!"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DESCRIPTION;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElfKing</span> <span class="keyword">implements</span> <span class="title">King</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> String DESCRIPTION = <span class="string">"This is the Elven king!"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DESCRIPTION;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrcArmy</span> <span class="keyword">implements</span> <span class="title">Army</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> String DESCRIPTION = <span class="string">"This is the Orc Army!"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DESCRIPTION;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrcCastle</span> <span class="keyword">implements</span> <span class="title">Castle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> String DESCRIPTION = <span class="string">"This is the Orc castle!"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DESCRIPTION;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrcKing</span> <span class="keyword">implements</span> <span class="title">King</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> String DESCRIPTION = <span class="string">"This is the Orc king!"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DESCRIPTION;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>工厂接口</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">KingdomFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Castle <span class="title">createCastle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">King <span class="title">createKing</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Army <span class="title">createArmy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>工厂实现</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElfKingdomFactory</span> <span class="keyword">implements</span> <span class="title">KingdomFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Castle <span class="title">createCastle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ElfCastle();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> King <span class="title">createKing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ElfKing();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Army <span class="title">createArmy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ElfArmy();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrcKingdomFactory</span> <span class="keyword">implements</span> <span class="title">KingdomFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Castle <span class="title">createCastle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OrcCastle();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> King <span class="title">createKing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OrcKing();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Army <span class="title">createArmy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OrcArmy();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>使用</strong><br>抽象工厂通常还配合简单工厂，<br>因为系统中通常使用一个产品等级的产品，对应一个工厂的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Enumeration for the different types of Kingdoms.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">enum</span> KingdomType &#123;</span><br><span class="line">    ELF, ORC</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The factory method to create KingdomFactory concrete objects.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KingdomFactory <span class="title">makeFactory</span><span class="params">(KingdomType type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> ELF:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ElfKingdomFactory();</span><br><span class="line">      <span class="keyword">case</span> ORC:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrcKingdomFactory();</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"KingdomType not supported."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面标准的简单工厂</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/2019/08/03/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>迭代器模式(Iterator Pattern)：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p>
<p><strong>主要解决：</strong>不同的方式来遍历整个整合对象。</p>
<p><strong>何时使用：</strong>遍历一个聚合对象。</p>
<p><strong>如何解决：</strong>把在元素之间游走的责任交给迭代器，而不是聚合对象。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>迭代器模式在 JDK 里面内建了，我们使用的非常多（for），但是通常不会自己去实现，不过了解其中原理结构权当学习。<br>如果要扩展，也是实现 Iterator   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ItemType type;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Item</span><span class="params">(ItemType type, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setType(type);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ItemType <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(ItemType type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ItemType &#123;</span><br><span class="line"></span><br><span class="line">  ANY, WEAPON, RING, POTION</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ItemIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Item <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreasureChest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;Item&gt; items;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructor</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TreasureChest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    items.add(<span class="keyword">new</span> Item(ItemType.POTION, <span class="string">"Potion of courage"</span>));</span><br><span class="line">    items.add(<span class="keyword">new</span> Item(ItemType.RING, <span class="string">"Ring of shadows"</span>));</span><br><span class="line">    items.add(<span class="keyword">new</span> Item(ItemType.POTION, <span class="string">"Potion of wisdom"</span>));</span><br><span class="line">    items.add(<span class="keyword">new</span> Item(ItemType.POTION, <span class="string">"Potion of blood"</span>));</span><br><span class="line">    items.add(<span class="keyword">new</span> Item(ItemType.WEAPON, <span class="string">"Sword of silver +1"</span>));</span><br><span class="line">    items.add(<span class="keyword">new</span> Item(ItemType.POTION, <span class="string">"Potion of rust"</span>));</span><br><span class="line">    items.add(<span class="keyword">new</span> Item(ItemType.POTION, <span class="string">"Potion of healing"</span>));</span><br><span class="line">    items.add(<span class="keyword">new</span> Item(ItemType.RING, <span class="string">"Ring of armor"</span>));</span><br><span class="line">    items.add(<span class="keyword">new</span> Item(ItemType.WEAPON, <span class="string">"Steel halberd"</span>));</span><br><span class="line">    items.add(<span class="keyword">new</span> Item(ItemType.WEAPON, <span class="string">"Dagger of poison"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ItemIterator <span class="title">iterator</span><span class="params">(ItemType itemType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreasureChestItemIterator(<span class="keyword">this</span>, itemType);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get all items</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Item&gt; <span class="title">getItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Item&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.addAll(items);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreasureChestItemIterator</span> <span class="keyword">implements</span> <span class="title">ItemIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> TreasureChest chest;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> idx;</span><br><span class="line">  <span class="keyword">private</span> ItemType type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructor</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TreasureChestItemIterator</span><span class="params">(TreasureChest chest, ItemType type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.chest = chest;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">    <span class="keyword">this</span>.idx = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findNextIdx() != -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    idx = findNextIdx();</span><br><span class="line">    <span class="keyword">if</span> (idx != -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> chest.getItems().get(idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findNextIdx</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Item&gt; items = chest.getItems();</span><br><span class="line">    <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> tempIdx = idx;</span><br><span class="line">    <span class="keyword">while</span> (!found) &#123;</span><br><span class="line">      tempIdx++;</span><br><span class="line">      <span class="keyword">if</span> (tempIdx &gt;= items.size()) &#123;</span><br><span class="line">        tempIdx = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (type.equals(ItemType.ANY) || items.get(tempIdx).getType().equals(type)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tempIdx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TreasureChest chest = <span class="keyword">new</span> TreasureChest();</span><br><span class="line"></span><br><span class="line">    ItemIterator ringIterator = chest.iterator(ItemType.RING);</span><br><span class="line">    <span class="keyword">while</span> (ringIterator.hasNext()) &#123;</span><br><span class="line">      LOGGER.info(ringIterator.next().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">"----------"</span>);</span><br><span class="line"></span><br><span class="line">    ItemIterator potionIterator = chest.iterator(ItemType.POTION);</span><br><span class="line">    <span class="keyword">while</span> (potionIterator.hasNext()) &#123;</span><br><span class="line">      LOGGER.info(potionIterator.next().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">"----------"</span>);</span><br><span class="line"></span><br><span class="line">    ItemIterator weaponIterator = chest.iterator(ItemType.WEAPON);</span><br><span class="line">    <span class="keyword">while</span> (weaponIterator.hasNext()) &#123;</span><br><span class="line">      LOGGER.info(weaponIterator.next().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">"----------"</span>);</span><br><span class="line"></span><br><span class="line">    ItemIterator it = chest.iterator(ItemType.ANY);</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">      LOGGER.info(it.next().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2019/08/02/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">引用地址</a> </p>
<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。<br>通常用在需要大量资源而且不需要重复创建的类<br>注意：</p>
<ol>
<li>单例类只能有一个实例。</li>
<li>单例类必须自己创建自己的唯一实例。</li>
<li>单例类必须给所有其他对象提供这一实例。</li>
</ol>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</p>
<p><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。</p>
<p><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
<p><strong>关键代码：</strong>构造函数是私有的。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>没啥说的，直接上代码<br>主要有懒汉，饿汉方式，注意线程安全和不安全。。线程不安全的单例就不用写了<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程安全，双重检查，初始化的时候加锁，以后获取的时候不加锁，这个属于懒汉</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeDoubleCheckLocking</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 针对这里为啥要 volatile  主要是防止重排序导致程序错误</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ThreadSafeDoubleCheckLocking instance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * private constructor to prevent client from instantiating.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ThreadSafeDoubleCheckLocking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// to prevent instantiating by Reflection call</span></span><br><span class="line">    <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already initialized."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Public accessor.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> an instance of the class.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadSafeDoubleCheckLocking <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// local variable increases performance by 25 percent</span></span><br><span class="line">    <span class="comment">// Joshua Bloch "Effective Java, Second Edition", p. 283-284</span></span><br><span class="line">    </span><br><span class="line">    ThreadSafeDoubleCheckLocking result = instance;</span><br><span class="line">    <span class="comment">// Check if singleton instance is initialized. If it is initialized then we can return the instance.</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// It is not initialized but we cannot be sure because some other thread might have initialized it</span></span><br><span class="line">      <span class="comment">// in the meanwhile. So to make sure we need to lock on an object to get mutual exclusion.</span></span><br><span class="line">      <span class="keyword">synchronized</span> (ThreadSafeDoubleCheckLocking<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Again assign the instance to local variable to check if it was initialized by some other thread</span></span><br><span class="line">        <span class="comment">// while current thread was blocked to enter the locked zone. If it was initialized then we can </span></span><br><span class="line">        <span class="comment">// return the previously created instance just like the previous null check.</span></span><br><span class="line">        result = instance;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// The instance is still not initialized so we can safely (no other thread can enter this zone)</span></span><br><span class="line">          <span class="comment">// create an instance and make it our singleton instance.</span></span><br><span class="line">          instance = result = <span class="keyword">new</span> ThreadSafeDoubleCheckLocking();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样是懒汉，线程安全，但是锁加在方法上了，无论初始化还是拿锁的时候都会有锁操作，对频繁获取对象的场景会有一丢丢性能影响，不过胜在简单粗暴，代码简洁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeLazyLoadedIvoryTower</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ThreadSafeLazyLoadedIvoryTower instance;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ThreadSafeLazyLoadedIvoryTower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// protect against instantiation via reflection</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already initialized."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The instance gets created only when it is called for first time. Lazy-loading</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> ThreadSafeLazyLoadedIvoryTower <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> ThreadSafeLazyLoadedIvoryTower();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样懒汉，线程安全，使用私有静态内部类来持有实例，使用类加载机制保障线程安全（类加载线程安全）和延时加载（按需加载）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializingOnDemandHolderIdiom</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Private constructor.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">InitializingOnDemandHolderIdiom</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> Singleton instance</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InitializingOnDemandHolderIdiom <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> HelperHolder.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Provides the lazy-loaded Singleton instance.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HelperHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InitializingOnDemandHolderIdiom INSTANCE =</span><br><span class="line">        <span class="keyword">new</span> InitializingOnDemandHolderIdiom();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个是饿汉，线程安全，更加简单粗暴，加载类的时候就完成初始化，对实例初始化耗时的情况下，会影响系统启动（但是系统启动的时候也不一定会加载这个类，JVM 是按需加载的）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IvoryTower</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Private constructor so nobody can instantiate the class.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">IvoryTower</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Static to class instance of the class.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IvoryTower INSTANCE = <span class="keyword">new</span> IvoryTower();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * To be called by user to obtain instance of the class.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> instance of the singleton.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IvoryTower <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是饿汉，线程安全，effective java 里面提到的枚举单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumIvoryTower &#123;</span><br><span class="line"></span><br><span class="line">  INSTANCE;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getDeclaringClass().getCanonicalName() + <span class="string">"@"</span> + hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池实现分析</title>
    <url>/2019/08/01/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>线程池，主要是用来重复使用线程，省去每次任务都去创建线程这个开销。<br>这样一说，最简单的实现就是 run 方法了吗一个死循环，然后从阻塞队列里面获取任务执行。<br>其实大体思路是这样，我们看一下 JDK 线程池的具体实现。<br>知道了他是怎样实现的，我们就知道了他的不足，以及如何扩展。  </p>
<p>最简单的创建线程池的方法就是 Executors.new** 方法，Executors 是一个线程池相关的工具类，我们进到里面看，创建普通线程池就是 ThreadPoolExecutor 类<br>创建定时线程池就是 ScheduledThreadPoolExecutor 类， </p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>我们先看普通线程池的实现<br>接口体系很简单<br>Executor<br>只有一个 execute 方法，用来执行任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ExecutorService<br>添加了关闭线程池相关的方法，还有 submit 方法，这个方法主要是针对返回 Future 的调用，还有 invoke 系列方法，执行部分或者全部给定任务，用的比较少  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着就是一个抽象实现 AbstractExecutorService  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">doInvokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> ntasks = tasks.size();</span><br><span class="line">        <span class="keyword">if</span> (ntasks == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(ntasks);</span><br><span class="line">        ExecutorCompletionService&lt;T&gt; ecs =</span><br><span class="line">            <span class="keyword">new</span> ExecutorCompletionService&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For efficiency, especially in executors with limited</span></span><br><span class="line">        <span class="comment">// parallelism, check to see if previously submitted tasks are</span></span><br><span class="line">        <span class="comment">// done before submitting more of them. This interleaving</span></span><br><span class="line">        <span class="comment">// plus the exception mechanics account for messiness of main</span></span><br><span class="line">        <span class="comment">// loop.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Record exceptions so that if we fail to obtain any</span></span><br><span class="line">            <span class="comment">// result, we can throw the last exception we got.</span></span><br><span class="line">            ExecutionException ee = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">            Iterator&lt;? extends Callable&lt;T&gt;&gt; it = tasks.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start one task for sure; the rest incrementally</span></span><br><span class="line">            futures.add(ecs.submit(it.next()));</span><br><span class="line">            --ntasks;</span><br><span class="line">            <span class="keyword">int</span> active = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Future&lt;T&gt; f = ecs.poll();</span><br><span class="line">                <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ntasks &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        --ntasks;</span><br><span class="line">                        futures.add(ecs.submit(it.next()));</span><br><span class="line">                        ++active;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (active == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                        f = ecs.poll(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                        nanos = deadline - System.nanoTime();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        f = ecs.take();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    --active;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> f.get();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ExecutionException eex) &#123;</span><br><span class="line">                        ee = eex;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException rex) &#123;</span><br><span class="line">                        ee = <span class="keyword">new</span> ExecutionException(rex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ee == <span class="keyword">null</span>)</span><br><span class="line">                ee = <span class="keyword">new</span> ExecutionException();</span><br><span class="line">            <span class="keyword">throw</span> ee;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">                futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> doInvokeAny(tasks, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException cannotHappen) &#123;</span><br><span class="line">            <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doInvokeAny(tasks, <span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">        <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks) &#123;</span><br><span class="line">                RunnableFuture&lt;T&gt; f = newTaskFor(t);</span><br><span class="line">                futures.add(f);</span><br><span class="line">                execute(f);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++) &#123;</span><br><span class="line">                Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">                <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        f.get();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            done = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> futures;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!done)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">                    futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                         <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">        ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">        <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks)</span><br><span class="line">                futures.add(newTaskFor(t));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanos;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> size = futures.size();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Interleave time checks and calls to execute in case</span></span><br><span class="line">            <span class="comment">// executor doesn't have any/much parallelism.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                execute((Runnable)futures.get(i));</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> futures;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">                <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                        <span class="keyword">return</span> futures;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        f.get(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">                        <span class="keyword">return</span> futures;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = deadline - System.nanoTime();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            done = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> futures;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!done)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">                    futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个抽象类首先加了两个 newTaskFor 方法，用来将 runnable 和 callable 方法包装成一个 FutureTask<br>FutureTask是 RunnableFuture 的实现。他包装 callbale（runnable 用适配器包装）。然后可以管理 Future<br>然后 实现了submit 方法，内部都是调用 newTaskFor 然后调用 execute 方法，返回 Future<br>最后，实现了 invoke系列方法。<br>可以看到 invokeAny 调用的是 doInvokeAny 方法。这个方法里面使用 ExecutorCompletionService 。他里面有个内部类实现<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueingFuture</span> <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    QueueingFuture(RunnableFuture&lt;V&gt; task) &#123;</span><br><span class="line">        <span class="keyword">super</span>(task, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123; completionQueue.add(task); &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Future&lt;V&gt; task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到，当任务执行完成后添加到了阻塞队列中了。然后调用 poll 就可以获取结果，知道了这个后，再看 doInvokeAny 方法就清楚了多。<br>就是先调用第一个任务，然后进到循环，如果看有没有返回值，没有的话，就依次提交所有任务，然后等待阻塞队列返回结果，获取到了就返回，然后取消所有任务。<br>invokeAll 的逻辑就简单了。自己看看就行了，重点在于 execute 方法，我们可以看到还剩下关闭方法和 execute 方法没有实现，是在 ThreadPoolExecutor 类中实现的。    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是3步：</p>
<ol>
<li>判断当前工作线程是否 &gt; 核心线程数，如果小于，那就添加工作线程，这个任务作为第一个任务，添加工作线程可能失败。  </li>
<li>如果线程池正在执行状态（你没调用 shutdown方法），那就添加任务到队列。后面还有一些检查，如果这个时候线程池关闭了，就移除任务，拒绝，或者工作线程数量为0，那就添加一个工作线程。</li>
<li>如果添加失败了，就再尝试添加工作线程，如果还是失败，执行拒绝策略。   </li>
</ol>
<p>上面的 ctl 是 AtomicInteger 类型，工作线程数量，线程池状态都是有这个字段表示，高3位表示状态，后面的位表示工作线程数量。</p>
<p>我们再看看 addWorker </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面那一坨 for 循环主要是判断状态和数量是否超了，如果正常，就工作线程数量+1，继续下面的逻辑<br>下面就是 new 一个 Worker 了。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">         * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">        <span class="keyword">final</span> Thread thread;</span><br><span class="line">        <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">        Runnable firstTask;</span><br><span class="line">        <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runWorker(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Lock methods</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">        <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread t;</span><br><span class="line">            <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到内部 thread 字段就是具体的线程实例，外部也是调用这个实例的 start 方法启动线程的。<br>thread 包装的 runnable 是 this，也就是本 worker，worker 的 run 方法是调用外部的 runWorker。<br>线程实例的构建调用了 getThreadFactory 获取线程工厂来构造的。Worker 还继承了 AQS ，这个就不将了。    </p>
<p>先简单说一下 getThreadFactory 这个方法，他获取的是 ThreadFactory 的实现。<br>这里 runnable 传的参数可以看到就是 worker 本身。这个 ThreadFactory 可以自己实现，通常自己实现都是加上线程名。或者是否为后台线程。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在说runWorker<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                    (Thread.interrupted() &amp;&amp;</span><br><span class="line">                    runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 到这里，实际上就线程执行完就挺了，不过可能会在这里面新建线程出来</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个稍微复杂点，就是工作线程的实际执行逻辑。简单的说，就是阻塞获取任务，执行。<br>看到每个 Worker 有自己的锁。<br>我们还看到 beforeExecute 和 afterExecute 两个钩子方。<br>看到如果出异常了，直接为抛出去，工作线程就走 processWorkerExit 方法了。<br>completedAbruptly 这个标记，要是执行的过程中异常了那就是 true 了<br>这里重点有两个方法 getTask 和 processWorkerExit 。<br>getTask 方法是获取要执行的任务。<br>这个方法，如果返回 null ，那么线程就会退出<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// 这里也是个注意点，当调用 shutdown 的时候，标记就是 SHUTDOWN 了，但是如果队列还有任务的时候，还是会继续执行</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">// 这里就是停止一个线程的条件    已经调用关闭了(shutdown)，并且队列为空   或者立即关闭 (showdownNow) 如果是立即关闭，那就丢弃任务了</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">                <span class="comment">// 这里也是一个停止线程的条件，获取任务超时，并且线程数量 &gt; 1 或者队列为空</span></span><br><span class="line">                <span class="comment">// 特别注意，这里是跟 1 比较，而不是 coreSize 比较，实际上当线程数量没到 coreSize 的时候，线程也是会停的</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里在 for 循环里面，还是先判断线程池的状态，要 decrementWorkerCount ，是因为外面 addWorker 的时候先 +1 了，return null 后（后面执行 processWorkerExit ），所以这里 -1，继续判断条件，自己看，就是工作线程多了就 -1，然后从任务队列里面限时等待或者阻塞获取任务返回。    </p>
<p>再看看 processWorkerExit<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="comment">// 这里，就是会新建线程出来，也就是说，总线程数量小于 coreSize，线程也会被回收，可能会新建一个线程</span></span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法看名字叫就是处理工作线程关闭。<br>首先就是，异常出来的，工作线程数量 -1（因为，如果是返回 null，导致工作线程退出，在 getTask 那里已经 -1 了）。<br>计算执行的任务数量，移除工作线程，尝试关闭线程池（如果状态是正常的，就没任何影响。）<br>如果线程池的状态 &lt; STOP (那就是正常状态 或者 刚调用 shutdown 方法)。<br>如果是异常退出的，直接调用 addWorker 方法（因为工作线程挂掉了，很可能还需要 +1 一个工作线程，不带初始任务，非核心线程）<br>如果是正常退出的，那么判断一下当前工作线程是否大于最小线程数量，如果不是，一样调用 addWorker 方法。 </p>
<p>还有一个方法，就是 reject<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    handler.rejectedExecution(command, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接调用拒绝策略,接口实现，内部有4个实现，默认设置的时候忽略，可以直接实习打印日志之类的，便于排查问题。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>线程池分析到这里就基本差不多了，还有一些关于关闭线程池的方法没看<br>在上面这些方法中，还看到了一些之前没见过的参数，譬如说 allowCoreThreadTimeOut ，是否允许核心线程超时。  </p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>源码</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 AQS 的同步器简单分析</title>
    <url>/2019/07/30/%E5%9F%BA%E4%BA%8E-AQS-%E7%9A%84%E5%90%8C%E6%AD%A5%E5%99%A8%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>大部分同步器的实现都是基于 AQS 的。<br>在了解了 AQS 的实现后，理解其他同步器的实现就比较轻松了。<br>这里只是简单介绍一下。<br>可重入锁 ReentrantLock 已经单独看过了，就不在分析了 </p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量（不知道是不是这样翻译）<br>里面有一堆许可，每次可以请求一个或多个许可，当请求成功，内部许可数量减少相应许可<br>如果内部许可不够，就请求失败（看调用的方法，是阻塞还是返回false）<br>使用完要归还许可    </p>
<h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><p>先从常用方法 acquire 开始分析   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 sync 是静态内部类, 基础自 AQS ，又公平和非公平实现（区别就是最新一个请求的线程是否有资格立即获取许可）<br>acquireSharedInterruptibly 这个方法是 AQS 里面的方法，获取共享资源，回调子类的 tryAcquireShared，来判断是否获取成功<br>又公平实现和非公平实现， Semaphore 只使用了共享相关的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非公平实现，直接调用 Sync 的 nonfairTryAcquireShared</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 公平实现获取</span></span><br><span class="line"><span class="comment">* 如果有节点排在前面，返回失败</span></span><br><span class="line"><span class="comment">* 再看许可数量，尝试获取</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认是非公平实现的，因此，关注一下非公平的  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个是非公平的尝试获取共享节点实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="comment">// 当前剩余的许可数量 &lt; 请求的许可数量 返回 （负数就是失败）</span></span><br><span class="line">        <span class="comment">// 否则尝试修改state值（获取），成功就返回（非负数），失败就继续循环</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟公平的实现就是少了前面的判断，公平就是得排队获取，<br>AQS 的 state 存储的就是 Semaphore 当前拥有的许可数量    </p>
<p>然后简单过一下 acquire 的其他几个方法，基本差不多   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.acquireSharedInterruptibly(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.acquireShared(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这几个方法都是调用 AQS 里面的方法，而 AQS 会调用子类的实现 tryAcquireShared     </p>
<h2 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h2><p>这个方法就是尝试获取许可，获取失败返回false，成功返回true，不阻塞<br>来看一下类似的方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquireShared(<span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquireShared(permits) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(permits, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感觉没啥好说的 调用 AQS ，然后 AQS 调用 tryAcquireShared 判断是否获取了，如果没有获取，阻塞，限时阻塞，中断判断都由 AQS 来维护  </p>
<h2 id="release"><a href="#release" class="headerlink" title="release"></a>release</h2><p>释放许可    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.releaseShared(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是调用共享节点的 releaseShared ， 注意一点，就是共享节点，释放会激活下一个节点，获取会激活下一个共享节点。<br>所以释放的许可不只一个的时候，首先获取到许可的是下一个等待节点（假设没有竞争），下一个节点获取到后，继续激活下一个共享节点(只是激活，能否获取许可还是看子类的 tryAcquireShared 实现)    </p>
<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>这个用法也比较简单，就是设置一个门闩，当有足够多的线程到达的时候（countDown），就激活所有在等待的线程（说的可能有问题）<br>重点方法有构造，countDown， 和 await<br>构造指定 门闩值，count，减少门闩，await 在门闩上等待，等门闩值减到0，激活所有 await 线程    </p>
<h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 传进来的count 就是 state 的值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 下面的await 直接调用 AQS 的方法，AQS 的方法会调用这个方法来判断是否获取成功</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 当 state 的值为0 的时候是成功的，也就是 await 不会阻塞，直接放行</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 下面的countDown 直接调用 AQS 的方法，AQS 的方法会调用这个方法来判断是否释放成功</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="comment">// 这个是 countDown 方法调用后 AQS 回调子类的方法，判断是否要解除阻塞</span></span><br><span class="line">        <span class="comment">// 下面的逻辑很简单 如果 state 为 0 返回false，不是是话，state - 1，返回 state 是否为 0</span></span><br><span class="line">        <span class="comment">// 如果为0了，就代表 AQS 要做释放共享节点操作了（通知后续节点）</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 AQS 的 state 里面存的就是构造指定的值  </p>
<h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>看下 await 相关的方法   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果是直接阻塞，还是限时阻塞都是获取的共享节点，共享节点调用的是  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当 state 的值为0 的时候是成功的，也就是 await 不会阻塞，直接放行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，子类实现的，获取到共享节点的条件就是 state 的值为 0，所以 await 就是阻塞了    </p>
<h2 id="countDown"><a href="#countDown" class="headerlink" title="countDown"></a>countDown</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法调用的是 释放共享节点，能否释放看子类实现的 tryReleaseShared    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="comment">// 这个是 countDown 方法调用后 AQS 回调子类的方法，判断是否要解除阻塞</span></span><br><span class="line">    <span class="comment">// 下面的逻辑很简单 如果 state 为 0 返回false，不是是话，state - 1，返回 state 是否为 0</span></span><br><span class="line">    <span class="comment">// 如果为0了，就代表 AQS 要做释放共享节点操作了（通知后续节点）</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，调用一次 state 就 -1，等到 state = 0 的时候，就可以释放了，当释放的时候，会激活后面等待的共享节点 </p>
<h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p>这个场景就是，指定一个值，当等待的线程达到这个值的时候，所有等待的线程激活。<br>这个不是直接基于 AQS 的，内部使用了重入锁和条件<br>重要的方法有构造，await，reset  </p>
<h2 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>barrierAction 这个是用来指定当满足条件，激活的时候回调的一个任务    </p>
<h2 id="await-1"><a href="#await-1" class="headerlink" title="await"></a>await</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">            BrokenBarrierException,</span></span><br><span class="line"><span class="function">            TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>await 方法是调用内部的 dowait 方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 本质上很简单</span></span><br><span class="line"><span class="comment">* 使用重入锁和条件机制</span></span><br><span class="line"><span class="comment">* 线程在条件上等待，当等待的线程达到指定数量，就激活所有线程，然后进行下一轮</span></span><br><span class="line"><span class="comment">* 重点在于异常处理，当等待的线程中，有中断，或者使用限时等待，超时了，那么本同步器就处于一个中断（不可用状态）</span></span><br><span class="line"><span class="comment">* 需要调用 reset 来重置一下状态</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Main barrier code, covering the various policies.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">            TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">// 如果调用 await 的线程中断了 那中断这个同步器</span></span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="comment">// 注意这里直接调用 run，也就是说再最后一个调用 await 的线程中调用的</span></span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                <span class="comment">// 如果不发生异常，就是true了，重置这个同步器</span></span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 如果上面 command 异常了，那中断这个同步器</span></span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果到这里，那就代表还没到激活线程的时候，本线程也要等待，直到激活，同步器中断，线程中断，超时</span></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 没有超时条件，那就直接在条件上等待</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="comment">// 否则 限时等待</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">// 这里处理线程中断</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    <span class="comment">// 如果同步器没有中断，就中断同步器，抛中断异常</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果同步器已经中断了，设置线程中断，后面抛同步器中断异常</span></span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 同步器中断</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当调用了 nextGeneration 才为true，正常返回</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果有超时标记，并且超时了</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="comment">// 中断同步器，抛超时异常</span></span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码上有注释了，就不细讲了<br>当本同步器因为一次，中断导致不可用后，可以通过 reset 方法恢复</p>
<h1 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h1><p>读写锁<br>实现的逻辑是 读读不互斥，读写互斥，写写互斥<br>源码里面的内容很多，看懂不复杂，还是基于 AQS， 内部有读锁 和 写锁<br>读锁获取共享节点，写锁获取独占节点  </p>
<p>读写锁接口就两个方法，返回读锁和写锁    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for reading</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for writing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部就是    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 内部类实现的读锁 */</span></span><br><span class="line"><span class="comment">/** Inner class providing readlock */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line"><span class="comment">/** 内部类实现的写锁 */</span></span><br><span class="line"><span class="comment">/** Inner class providing writelock */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 接口实现，返回内部的读写锁实现 */</span></span><br><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock  <span class="title">readLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> readerLock; &#125;</span><br></pre></td></tr></table></figure>
<p>一般同步器大部分方法都是实现在一个继承 AQS 的静态内部类上，通常叫 Sync，如果还要区分公平，非公平的话，下面再有 FairSync 和 UnfairSync<br>先看看 Sync </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6317671515068378041L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 下面这些变量，主要用来计算读锁，写锁的持有数</span></span><br><span class="line"><span class="comment">    * AQS 内部是一个 state int变量，使用这个变量记录</span></span><br><span class="line"><span class="comment">    * 一个int 32位，其中高 16位 为读锁数量，低16位为写锁数量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);<span class="comment">// 2 的16次方</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;<span class="comment">// 上面 -1，就是低16位全1</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;<span class="comment">// 同上</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回读锁数量 */</span></span><br><span class="line">    <span class="comment">/** Returns the number of shared holds represented in count  */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回写锁数量 */</span></span><br><span class="line">    <span class="comment">/** Returns the number of exclusive holds represented in count  */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * A counter for per-thread read hold counts.</span></span><br><span class="line"><span class="comment">        * Maintained as a ThreadLocal; cached in cachedHoldCounter</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Use id, not reference, to avoid garbage retention</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ThreadLocal subclass. Easiest to explicitly define for sake</span></span><br><span class="line"><span class="comment">    * of deserialization mechanics.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 线程变量，保存当前线程持有的读锁数量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 线程对象的缓存，减少线程对象的get</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 第一个读锁线程，和第一个读锁线程的持有读锁的数量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line"></span><br><span class="line">    Sync() &#123;</span><br><span class="line">        readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line">        setState(getState()); <span class="comment">// ensures visibility of readHolds</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 两个子类实现的方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 这个是写锁的释放方法</span></span><br><span class="line"><span class="comment">        * 当前线程持有写锁的数量为0的时候返回true</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">        <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (free)</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 这个是写锁获取的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">        <span class="comment">// 如果当前有读锁或者写锁被持有了</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">            <span class="comment">// w == 0 代表有读锁，如果 != 0 ，代表有线程持有读锁，继续判断持有的线程是否为当前线程，如果还不是，返回false</span></span><br><span class="line">            <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 到这里来， w != 0 ，并且持有的线程就是自己，判断重入次数</span></span><br><span class="line">            <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="comment">// Reentrant acquire</span></span><br><span class="line">            <span class="comment">// 增加锁持有数量</span></span><br><span class="line">            setState(c + acquires);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前没有人持有，判断写锁是否需要阻塞，非公平不需要，公平则判断前面有没有等待的节点</span></span><br><span class="line">        <span class="comment">// 如果不需要阻塞，直接尝试获取，成功返回true，是否返回false</span></span><br><span class="line">        <span class="comment">// 这里的结果不是最终结果，父类上面还有尝试的机会，尝试失败，则阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">            !compareAndSetState(c, c + acquires))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 尝试释放共享资源</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 建少线程持有的读锁数量</span></span><br><span class="line">        <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">            <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                firstReader = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                firstReaderHoldCount--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                rh = readHolds.get();</span><br><span class="line">            <span class="keyword">int</span> count = rh.count;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                readHolds.remove();</span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">            &#125;</span><br><span class="line">            --rh.count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环保证成功</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">            <span class="comment">// 这里才是真正修改读锁数量的地方，修改成功，判断读锁的数量是否为0，如果是，那就可以释放共享资源了</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">                <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">                <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IllegalMonitorStateException <span class="title">unmatchedUnlockException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IllegalMonitorStateException(</span><br><span class="line">            <span class="string">"attempt to unlock read lock, not locked by current thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 尝试获取共享锁，返回 &lt; 0 ，获取失败</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 如果写锁被其他线程持有，获取失败</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            getExclusiveOwnerThread() != current)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 获取当前读锁持有数量</span></span><br><span class="line">        <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">        <span class="comment">// 非公平下，如果有写锁在第一个等待位置（第二个节点），读锁就应该阻塞</span></span><br><span class="line">        <span class="comment">// 这里如果不阻塞，并且读锁持有数量不超过最大值，尝试读锁加1，如果成功,那就是获取成功了，否则继续 fullTryAcquireShared</span></span><br><span class="line">        <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">            r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">            <span class="comment">// 尝试读锁加1 ，高16位标识读锁数量，SHARED_UNIT，就是高16位是 1，低16位是0</span></span><br><span class="line">            compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 代表本线程持有第一个读锁</span></span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// 如果持有数量 &gt; 0 ，第一个持有线程还是本线程，则第一个线程持有锁的数量 ++</span></span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 当前线程不为第一个持有读锁的线程</span></span><br><span class="line">                <span class="comment">// 线程变量记录当前线程持有的读锁的数量</span></span><br><span class="line">                <span class="comment">// cachedHoldCounter 字段用来减少 readHolds.get() 调用</span></span><br><span class="line">                HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 当前线程第一个获取读锁，设置线程变量</span></span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上面如果需要阻塞，或者获取失败</span></span><br><span class="line">        <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">        HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 循环尝试</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="comment">// 如果有其他线程获取写锁，返回失败</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">                <span class="comment">// would cause deadlock.</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">                <span class="comment">// 当获取读锁需要被阻塞</span></span><br><span class="line">                <span class="comment">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class="line">                <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                    <span class="comment">// 第一个获取读锁的线程不管</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 重点在这里。readerShouldBlock 影响</span></span><br><span class="line">                    <span class="comment">// 其他线程，如果该线程已经持有读锁了，继续后面的逻辑，没有持有，那就返回失败</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        rh = cachedHoldCounter;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                            rh = readHolds.get();</span><br><span class="line">                            <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                                readHolds.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 其他新线程想要获取读锁，返回失败</span></span><br><span class="line">                    <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 读锁最大数量检查</span></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="comment">// 读锁总数 + 1，如果失败，可能其他读锁操作了，外层循环，继续重新尝试</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="comment">// 如果读锁刚开始为0，则是第一个获取读锁的</span></span><br><span class="line">                <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    <span class="comment">// 不为0，如果还是第一个获取读锁的线程</span></span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 否则就是其他线程获取锁了</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                        rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                    cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 尝试获取写锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 有锁被获取</span></span><br><span class="line">            <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">            <span class="comment">// 有读锁被获取，获取有其他线程持有写锁返回false</span></span><br><span class="line">            <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (w == MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试获取写锁，成功返回true，失败返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetState(c, c + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 尝试获取读锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 循环中保证有结果</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="comment">// 如果有写锁了，返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">            <span class="comment">// 读锁达到最大数量</span></span><br><span class="line">            <span class="keyword">if</span> (r == MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="comment">// 尝试获取读锁，如果 CAS 操作失败，可能是同时有其他读锁在修改，继续循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="comment">// 下面就是设置 是否是读锁的第一个线程，或者本线程是否是第一次获取读锁，设置数量</span></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 本线程是否为写锁持有线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// While we must in general read state before owner,</span></span><br><span class="line">        <span class="comment">// we don't need to do so to check if current thread is owner</span></span><br><span class="line">        <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Methods relayed to outer class</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Thread <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Must read state before owner to ensure memory consistency</span></span><br><span class="line">        <span class="keyword">return</span> ((exclusiveCount(getState()) == <span class="number">0</span>) ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                getExclusiveOwnerThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getReadLockCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sharedCount(getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isWriteLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exclusiveCount(getState()) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWriteHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHeldExclusively() ? exclusiveCount(getState()) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getReadHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getReadLockCount() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (firstReader == current)</span><br><span class="line">            <span class="keyword">return</span> firstReaderHoldCount;</span><br><span class="line"></span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh != <span class="keyword">null</span> &amp;&amp; rh.tid == getThreadId(current))</span><br><span class="line">            <span class="keyword">return</span> rh.count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = readHolds.get().count;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) readHolds.remove();</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Reconstitutes the instance from a stream (that is, deserializes it).</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line">        setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> getState(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面有注释，写下自己的理解把<br>如果当前是写锁持有，那么后面不管是读还是写全部阻塞，这个很简单，独占<br>如果当前是读锁持有，情况就复杂点，如果还是请求读锁，直接获取了，如果写锁请求，阻塞（正常情况下，他就在第二个节点上了，等待唤醒）<br>但是，后面如果还有请求读锁，这个读锁是否可以获取到，就区分公平和非公平了<br>在非公平条件下，是写锁优先的，如果有写锁在等待了，读锁应该要等待（不代表要阻塞，这里持有资源的还是读锁），这个时候如果请求的线程已经获取读锁了，那么可以继续获取，如果之前<br>没有获取过读锁，那么是获取不到的，阻塞<br>在公平条件下，先到先得，写锁一直要等待没有读锁被持有，才能获取锁。这可能会导致写锁长时间阻塞    </p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>AQS</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS 分析</title>
    <url>/2019/07/28/AQS-%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>juc 下面很多同步器都是基于 AQS 的。<br>因此，掌握了 AQS ,其他同步器的实现原理就都明白了    </p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>AQS 的阻塞使用的是 LockSupport 这个类来实现的<br>阻塞可以被线程的中断标记唤醒    </p>
<p>内部使用双向链表（prev，next）来维持阻塞的线程（使用 Node 来代表）<br>链表的头节点为当前获取资源的线程节点<br>链表是延时加载的，如果没有竞争发生的时候，链表不会初始化    </p>
<p>节点分为独占节点 和 共享节点<br>独占节点的概念是，如果独占节点持有资源，那么后面的节点都得等待，等待该节点释放资源后唤醒下一个节点<br>共享节点的概念是，如果共享节点获取到了资源，那么会判断后面的节点是不是共享节点，如果是，那就唤醒后一个节点（是否获取到资源得看子类实现）    </p>
<p>AQS 内部有一个 volatile int 类型的变量 state。<br>来表示 AQS 的状态，子类可以在 state 上面存自己设计的值</p>
<p>还有条件 Condition<br>AQS 内部有 Condition 的内部类实现（就是说，可以访问外部类的变量，方法） ConditionObject<br>条件等待是在一个单向链表的（nextWaiter），也是基于 Node 的  </p>
<p>外部通常可能会调用 AQS 的方法有   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 独占节点相关的方法</span></span><br><span class="line">acquire(<span class="keyword">int</span> arg)</span><br><span class="line">acquireInterruptibly(<span class="keyword">int</span> arg) <span class="keyword">throws</span> InterruptedException</span><br><span class="line">tryAcquireNanos(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout) <span class="keyword">throws</span> InterruptedException </span><br><span class="line">release(<span class="keyword">int</span> arg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享节点相关的方法   </span></span><br><span class="line">acquireShared(<span class="keyword">int</span> arg)</span><br><span class="line">acquireSharedInterruptibly(<span class="keyword">int</span> arg) <span class="keyword">throws</span> InterruptedException</span><br><span class="line">tryAcquireSharedNanos(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout) <span class="keyword">throws</span> InterruptedException</span><br><span class="line">releaseShared(<span class="keyword">int</span> arg)</span><br></pre></td></tr></table></figure>
<p>当然，还有其他 public 的方法，不过，这几个是重点方法，功能也是基于这几个方法实现的<br>acquire 代表获取<br>release 是释放  </p>
<p>特别注意的是调用 acquire ，获取资源，具体是否获取的到，得看子类实现 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 独占节点相关的方法</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span> arg)</span><br><span class="line">tryRelease(<span class="keyword">int</span> arg)</span><br><span class="line"><span class="comment">// 共享节点相关的方法   </span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span> arg)</span><br><span class="line">tryReleaseShared(<span class="keyword">int</span> arg)</span><br></pre></td></tr></table></figure>
<p>这上面4个方法是留给子类实现的，用来实现自己的同步器功能<br>而在 AQS 内部 则是通过调用这4个方法，来判断是否获取，释放了节点<br>如果获取，或者释放了，那么内部的同步队列（双向链表）的状态，节点状态做相应变更  </p>
<p>这里只是一个概述，下面跟着代码，来看看 AQS 内部怎么维持双向链表和阻塞的逻辑 </p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="独占"><a href="#独占" class="headerlink" title="独占"></a>独占</h3><p>独占节点相关的是 acquire,release<br>后面不带 share 的，那就是独占节点的方法<br>我们先看一下获取独占节点    </p>
<h4 id="acquire-int-arg"><a href="#acquire-int-arg" class="headerlink" title="acquire(int arg)"></a>acquire(int arg)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，首先调用了 tryAcquire 方法，这个是由子类实现的。<br>任何同步器，肯定有自己的阻塞条件和逻辑，因此这个只是一个模版方法，将是否获取到资源的条件留给子类实现<br>如果子类说没获取到，那么 AQS 将保证，本线程阻塞，并且可以被取消和激活。<br>JDK 源码大部分都写的比较精简，行数是减少了，但是也不太容易看<br>首先看 addWaiter 方法<br>这个方法是将节点添加到同步队列（双向链表）里面去，根据参数，我们可以看到是独占节点（Node.EXCLUSIVE）<br>添加的节点是到链表尾部，这个时候，如果链表没有初始化，则先初始化    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只是讲解，源码上注释可以看<br>如果链表没有初始化（tail == null），调用 enq 方法，这个方法是初始化链表 + 加入节点到队尾<br>如果已经初始化了，我们可以看到是直接设置节点到队尾（一次CAS 操作尝试），如果失败了（可能多个线程都要阻塞），还是调用 enq    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>enq 方法通过 循环 + CAS 来保证操作成功（为什么，因为即使在竞争情况下，肯定会有一个线程成功操作，其余的线程就继续再循环里面 CAS）<br>可以看到，如果双向链表没有初始化的情况下，添加一个空节点当头节点，然后参数节点添加到队尾，如果有并发情况，则依次添加到队尾<br>这里需要注意的一点是，返回的节点是给定节点的<strong>前驱节点</strong></p>
<p>回到上面 acquire 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加到链表里面去了之后，调用 acquireQueued 方法，这个方法是处在队列里面的节点尝试获取资源，如果获取不到就阻塞   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论需不需要抛中断异常，中断条件都是要判断的。<br>还是在循环里面，尝试获取资源和阻塞<br>首先判断的是前一个节点是否是头节点，如果是，那就尝试去获取资源（tryAcquire），记住，是否获取到资源（获取到资源的线程不阻塞）由实现类来决定<br>获取到的资源节点设置为头节点，并将前一个节点断开。返回是否有中断<br>如果没有获取到，或者前一个节点不是头节点，那就可以开始判断是否需要阻塞了 shouldParkAfterFailedAcquire   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>什么条件下会阻塞呢？当前一个节点的等待状态为 SIGNAL 的时候返回true，其他情况都返回 false<br>因为 AQS 的实现，保证等待状态为 SIGNAL 的节点会至少唤醒一次下一个节点<br>这里还删除了取消状态的节点，如果前一个节点的等待状态不为 SIGNAL，则 CAS 操作修改为 SIGNAL<br>这里是有可能失败的，不过外层是循环。    </p>
<p>深入分析一下：<br>为什么当前一个节点是头节点的时候，可以去尝试获取资源？<br>因为，可能头节点将要释放资源了，这个时候有可能获取到。<br>为什么一定要等待设置前一个节点为 SIGNAL 状态的时候才阻塞。parkAndCheckInterrupt 方法就是阻塞   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 AQS 保证的是 SIGNAL 的节点会通知下一个节点（实现后面分析）。<br>如果没等到设置前一个节点状态为 SIGNAL，本节点可能得不到通知 </p>
<p>在最后还有一段代码  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在本方法中，不会走到这里的，这个是在现时等待，响应中断的时候可能到这里，用来取消节点    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先删除节点前面已经取消的节点，然后设置本节点的状态为 CANCELLED 取消<br>如果本节点是尾节点，并且设置前一个节点为尾节点成功，删除本节点就行了<br>否则 else 下面的逻辑就有点复杂了<br>判断 前一个节点不是头节点 &amp;&amp; 前一个节点的状态为 SIGNAL ，或者（非取消节点）成功设置为 SIGNAL &amp;&amp; 代表的线程不为 null   </p>
<p>那么本节点就是可以获得前一个节点的通知的，把这个条件转移到下一个节点，然后删除本节点<br>否则，就激活下一个节点（想想阻塞那里，会将前面的取消节点删除）。<br>最后的结果就是删除给定节点，保证后一个节点可以得到通知      </p>
<p>再看一下激活后一个节点的方法 unparkSuccessor    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当节点的状态 &lt; 0 ，则设置为0，如果后一个节点为null，或者为取消状态，那么从尾节点开始向前寻找，离本节点最近的一个非取消节点<br>如果找到了，就唤醒改线程。  </p>
<p>acquire 方法最后的就是 selfInterrupt 方法了，这个是设置线程的中断标记<br>除了 acquire 方法，还有 acquireInterruptibly tryAcquireNanos 方法，分别是不响应中断异常，和限时等待，逻辑大体类似   </p>
<p>再看看 release  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是释放独占节点，首先还是调用子类实现的 tryRelease 方法，子类说可以释放了，那么释放当前头节点（获取资源的节点为头节点）<br>这里，只要当头节点的 waitStatus != 0 就通知后面的节点，这里需要知道 &gt;0 是取消，&lt;0 是需要获取通知（有几个小于0的值） </p>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>共享的获取方法是 acquireShared  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是先调用子类实现的 tryAcquireShared 方法，如果失败了(返回值小于0)，继续调用 doAcquireShared   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本上跟获取独占节点的差不多，不同的是，这里添加的时一个共享节点。<br>这里，在获取到资源后，调用了 setHeadAndPropagate 方法<br>这里，将本节点设置为头节点。并唤醒下一个共享节点。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面经过条件判断后，如果后一个节点为共享节点，那么调用 doReleaseShared 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是激活后一个节点，当节点的状态为 SIGNAL 的时候，唤醒后一个节点代表的线程。<br>独占节点判断是否阻塞也是方法 shouldParkAfterFailedAcquire 来判断的，这里，如果节点要阻塞，那么会设置前一个节点的状态为 SIGNAL<br>当它被唤醒后，如果有可能获取资源（前一个节点为 头节点），还是会调用 tryAcquireShared 方法尝试获取。 </p>
<p>可以看到，共享节点的逻辑是如果一个共享节点获取资源，那么会激活后一个共享节点，至于这个共享节点是否获取资源，得看子类实现的 tryAcquireShared 方法。<br>AQS 只做到激活后一个共享节点，如果也能获取，那么继续往后激活。  </p>
<p>同样的，获取共享节点还有方法 acquireSharedInterruptibly tryAcquireSharedNanos   </p>
<p>释放共享节点 releaseShared  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>也是先调用 tryReleaseShared 子类实现，判断是否释放，如果是否，还是调用 doReleaseShared 方法，这个方法上面看到过了   </p>
<p>AQS 的重点方法就这些，还有一部分是条件的实现    </p>
<h3 id="条件-Condition"><a href="#条件-Condition" class="headerlink" title="条件 Condition"></a>条件 Condition</h3><p>条件就是通知机制，线程可以在条件上等待，其他线程可以激活一个条件上的线程，或者激活条件上的所有线程。<br>实现方式是内部类，上面说过 Node 有个 nextWaiter 自动，就是维护单向链表用的，维护的就是条件上等待的节点，当被唤醒后，会将单向链表的节点，加入到双向链表中，等待获取资源<br>所以 条件是跟锁一起工作的，必须先获取资源，才能调用条件上面的方法。<br>我们看一个条件上的等待 await    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果中断了，就抛中断异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 添加一个节点到条件队列尾部</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放锁资源（如果没持有锁，会抛异常出来）</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环判断，如果当前节点不在同步队列中（当调用 signal 方法的时候，会将节点放入同步队列）</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 线程阻塞，正常流程应该是到这里</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 阻塞取消，出来判断中断状态,如果 ！= 0，就是没有中断</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从上面出来后，尝试获取锁，这里还是会触发等待锁的阻塞（如果要等的话），获取成功，处理了继续判断中断状态</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">// 如果 当前节点在条件队列上后后续节点，那么清除一遍无效节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">// 如果有中断状态，判断是否要抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加一个条件节点到 条件队列上面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// 如果最后一个节点取消了，那么清理整个队列中取消的节点</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新建一个mode 为 CONDITION 的节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码上又点注释，整个逻辑不是很复杂。<br>除了 await 外，还有几个限时等待的方法，和不响应中断异常的方法，在源码上已经加了注释了，就不一一细讲了，实现大体类似。<br>再看一下 signal 方法    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果锁的持有者不是当前线程，抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="comment">// 如果等待队列不为空，激活第一个</span></span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单的，直接调用 doSignal 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 从first 开始向后遍历</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// first 节点从链表中断开</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 转换first节点，如果成功，跳出循环，如果失败，继续下一个节点，获取节点为null，跳出循环</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点在 transferForSignal 方法，如果激活成功返回 true。这里的逻辑是一直向后，直到激活一个。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 如果不能改变 等待状态值，那么这个节点就是取消状态(就是不通知)</span></span><br><span class="line"><span class="comment">    * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 将节点插入到同步队列尾部</span></span><br><span class="line"><span class="comment">    * 如果 前一个节点的等待状态是取消状态，那么设置为 SIGNAL，代表本节点需要收到前一个节点的通知</span></span><br><span class="line"><span class="comment">    * 如果设置失败，那么立马激活本节点代表的线程，返回true</span></span><br><span class="line"><span class="comment">    * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">    * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">    * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">    * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是将单向链表的节点，添加的双向链表（等待之前释放的资源）  </p>
<p>signalAll 方法就是遍历等待队列，调用这个方法。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>了解了上面的一些内容，那么再分析 CountDownLatch, CyclicBarrier, ReentrantLock, ReentrantReadWriteLock, Semaphore 这里同步器就很轻松了。<br>源码里面有注释。<br>PS: StampedLock 没有分析，是新的读写锁，思路是，读不阻塞写，当写发生后，可以重读</p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>AQS</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>ReentrantLock 源码分析</title>
    <url>/2019/07/27/ReentrantLock-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>基本所有的同步器都是基于 <code>AbstractQueuedSynchronizer</code> 实现的，但是直接分析 <code>AbstractQueuedSynchronizer</code> 有太复杂，因此，从一个具体的实现 <code>ReentrantLock</code>，可重入锁开始分析    </p>
<h2 id="ReentrantLock-结构"><a href="#ReentrantLock-结构" class="headerlink" title="ReentrantLock 结构"></a>ReentrantLock 结构</h2><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，在其内部有一个 静态抽象类 <code>Sync</code> 继承了 <code>AbstractQueuedSynchronizer</code>,这是大部分同步器的实现方式，在内部通常有一个自定义的 <code>Sync</code> 类继承 <code>AbstractQueuedSynchronizer</code><br><code>ReentrantLock</code> 内部对 <code>Sync</code> 有两个实现 <code>NonfairSync</code>, <code>FairSync</code> ，看名字就知道是公平锁，和非公平锁。<br>构造 <code>ReentrantLock</code>,默认是非公平锁，可以指定一个 <code>boolean</code> 设置为公平锁，这两个有啥区别，下面看源码分析。    </p>
<h3 id="lock-方法"><a href="#lock-方法" class="headerlink" title="lock 方法"></a>lock 方法</h3><p>首先分析的情况是默认的非公平锁的 <code>lock</code> 方法<br>直接就是调用内部 <code>sync</code> 对象的 <code>lock</code> 方法 </p>
<pre><code class="lang-java">public void lock() {
        sync.lock();
    }
</code></pre>
<p>我们先看非公平锁的实现    </p>
<pre><code class="lang-java">final void lock() {
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
        }
</code></pre>
<p>首先调用 <code>compareAndSetState(0, 1)</code> 尝试获取，如果设置成功了，那么就代表锁被当前线程获得了 <code>setExclusiveOwnerThread(Thread.currentThread())</code>,这个方法设置当前获取锁的线程对象。<br>这两个方法都是 <code>AbstractQueuedSynchronizer</code> 的方法，到这里我们就得去简单的分析一下  <code>AbstractQueuedSynchronizer</code> 内部的情况了    </p>
<p><code>AbstractQueuedSynchronizer</code> 内部维护了一个双向链表结构. 节点对象就是静态内部类 <code>Node</code>,看其中的成员</p>
<pre><code class="lang-java">/** 表示节点正处在共享模式下等待的标记 **/
        static final Node SHARED = new Node();
        /**表示节点正在以独占模式等待的标记*/
        static final Node EXCLUSIVE = null;
        /**waitStatus值,表示线程已取消 */
        static final int CANCELLED = 1;
        /** waitStatus值,表示后继线程需要取消挂起 */
        static final int SIGNAL = -1;
        /** waitStatus值，表示线程正在等待条件 */
        static final int CONDITION = -2;
        /**waitStatus值指示下一个acquireShared应无条件传播*/
        static final int PROPAGATE = -3;
        /**
         * 状态字段，仅接受值:
         *
         * SIGNAL:值为-1 ，后继节点的线程处于等待状态，
         * 而当前节点的线程如果释放了同步状态或者被取消，
         * 将会通知后继节点，使后继节点的线程得以运行。
         *
         * CANCELLED:值为1，由于在同步队列中等待的
         * 线程等待超时或者被中断，需要从同步队列中取消等待，
         * 节点进入该状态将不会变化
         *
         * CONDITION: 值为-2，节点在等待队列中，
         * 节点线程等待在Condition上，当其他线程
         * 对Condition调用了singal方法后，该节点
         * 将会从等待队列中转移到同步队列中，加入到
         * 对同步状态的获取中
         *
         * PROPAGATE: 值为-3，表示下一次共享模式同步
         * 状态获取将会无条件地传播下去
         *
         * INITIAL: 初始状态值为0
         *
         * value 按数值排列以简化使用
         * 非负数 意味着这个节点不需要通知，所以，大部分代码里面不需要检查一些特殊值(只要判断是否 &gt;0 就行)
         * 这个字段初始化为0，使用 CAS 进行更新
         * 或者，无条件写（就是赋值，无条件赋值，在赋值的时候不应该依赖当前值）
         */
        volatile int waitStatus;
        /**
        * 链接到前驱节点，当前节点/线程依赖它来检查 waitStatus 。
        * 在入同步队列时被设置(waitStatus)，并且仅在移除同步队列时才归零
        * （为了GC的目的）。 此外，在取消(出队列)状态为（CANCELLED）前驱节点时，我们使用简单的循环找到未取消的节点 
        * 这将始终存在，因为头节点从未被取消：节点仅作为成功获取的结果而变为头。
        * 被取消的线程永远不会成功获取，并且线程只取消自身，
        * 而不是任何其他节点。
        */
        volatile Node prev;
        /**
        * 链接到后续节点，当前节点/线程释放时释放。
        * 在入同步队列期间分配，在绕过取消的前驱节
        * 点时调整，并在出同步队列时取消（为了GC的目的）。
        * enq操作不会分配前驱节点的next字段，直到附加之后，
        * 因此看到一个为null的next字段不一定意味着该节点在
        * 队列的末尾。 但是，如果next字段显示为null,我们
        * 可以从尾部扫描prev，仔细检查。 被取消的节点的next字段
        * 被设置为指向节点本身而不是null，以使isOnSyncQueue更
        * 方便操作。调用isOnSyncQueue时，如果节点（始终
        * 是放置在条件队列上的节点）正等待在同步队列上重新获取，则返回true。
        **/
        volatile Node next;
        /**
         * 这个节点代表的线程，入队的时候初始化，出队的时候设置null
         * construction and nulled out after use.
         */
        volatile Thread thread;
         /**
        * 将此节点入列的线程。在构造方法里初始化，使用后清零。
        * 链接到下一个节点等待条件，或特殊值SHARED。
        * 因为条件队列只有在保持在独占模式时才被访问，
        * 所以我们只需要一个简单的链接队列来保存节点，
        * 同时等待条件。 然后将它们转移到队列中以重新获取。
        * 并且因为条件只能是排它的，我们通过使用特殊的
        * 值来指示共享模式来保存一个字段。
        */
        Node nextWaiter;
        /**
         * 如果节点在共享模式下等待，则返回true
         */
        final boolean isShared() {
            return nextWaiter == SHARED;
        }
        /**
         * 返回上一个节点，如果为null，
         * 则抛出NullPointerException。当前驱节点不为null时使用。
         **/
        final Node predecessor() throws NullPointerException {
            Node p = prev;
            if (p == null)
                throw new NullPointerException();
            else
                return p;
        }
</code></pre>
<p>每个节点就是线程的代表，因此里面有 <code>Thread</code> 对象，<code>waitStatus</code> 这个字段代表当前线程所处的状态，只能是定义的几个静态常量值里面的。    </p>
<p>在来看 <code>AbstractQueuedSynchronizer</code> 里面有什么东西     </p>
<pre><code class="lang-java">    /**
     * Head of the wait queue, lazily initialized. Except for
     * initialization, it is modified only via method setHead. Note:
     * If head exists, its waitStatus is guaranteed not to be
     * CANCELLED.
     */
    private transient volatile Node head;
    /**
     * Tail of the wait queue, lazily initialized. Modified only via
     * method enq to add new wait node.
     */
    private transient volatile Node tail;
    /**
     * The synchronization state.
     */
    private volatile int state;
</code></pre>
<p>维护了链表的头节点和尾节点，还有一个状态值 <code>state</code>, 注意使用了 <code>volatile</code>, 保证的该变量的可见性。<br>还有几个用来使用 <code>CAS</code> 操作相关的成员，这里就不展示了    </p>
<p>好了，继续看之前的 <code>compareAndSetState(0, 1)</code><br>这个方法就是使用 <code>CAS</code> 操作，当 <code>state</code> 的值为0的时候，修改为1（在多线程的情况下，只会有一个成功，其他的失败），<br>如果这个方法调用成功，那就是获取到锁了，调用 <code>setExclusiveOwnerThread</code> 方法，设置当前获取锁的线程对象，这里是 <code>AbstractQueuedSynchronizer</code> 的方法，<code>AbstractQueuedSynchronizer</code> 内部维护当前获取到临界资源的线程对象<br>这就是获取到锁的情况，很简单，那么如果 <code>compareAndSetState</code> 不成功，代表锁获取失败。<br>后面就调用 <code>acquire(1)</code><br>这个 <code>acquire</code> 方法也是 <code>AbstractQueuedSynchronizer</code> 里面的方法    </p>
<pre><code class="lang-java">public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;&amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
</code></pre>
<p>可以看到 调用了 <code>tryAcquire</code>, <code>acquireQueued</code>, <code>addWaiter</code>, <code>selfInterrupt</code>,这些方法。<br>都是 <code>AbstractQueuedSynchronizer</code> 内部定义的。<br>其中 <code>tryAcquire</code> 是定义好，专门给继承者重写的，<code>AbstractQueuedSynchronizer</code> 本身没有实现它，只是抛异常    </p>
<pre><code class="lang-java">protected boolean tryAcquire(int arg) {
        throw new UnsupportedOperationException();
    }
</code></pre>
<p>我们可以找到，实现是在非公平锁那里实现的 </p>
<pre><code class="lang-java">protected final boolean tryAcquire(int acquires) {
            return nonfairTryAcquire(acquires);
        }
</code></pre>
<p>它又调用了父类 <code>Sync</code> 的 <code>nonfairTryAcquire</code><br>跟进去看一下    </p>
<pre><code class="lang-java">final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc &lt; 0) // overflow
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                setState(nextc);
                return true;
            }
            return false;
        }
</code></pre>
<p>看逻辑，获取状态值，如果是0，代表还没有被获取，因此就再次调用 <code>compareAndSetState</code>,尝试获取锁，如果获取成功，那么返回 <code>true</code>，<br>这也是获取到锁的情况，获取锁的逻辑到这里就结束了<br>如果状态值不等于0，判断之前获取到锁的线程是不是当前线程，如果是，状态值增加，返回 <code>true</code> ，这也是获取到锁的情况，结束，否则，返回 <code>false</code>,进行后面的步骤（再次尝试，进入等待等。。）<br>看到这里，就知道为什么叫可重入锁了，也看到可重入次数就是 <code>Integer.max</code>。<br>那么继续，看如果返回了 <code>false</code> 会发生什么 </p>
<p>还是回到 <code>AbstractQueuedSynchronizer</code> 的 <code>acquire</code> 方法    </p>
<pre><code class="lang-java">public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;&amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
</code></pre>
<p>理一下逻辑，<code>tryAcquire</code> 是非公平锁实现的方法，调用了 <code>Sync</code> 里面的 <code>nonfairTryAcquire</code> 方法，获取成功了返回 <code>true</code>，否则失败<code>false</code><br>这里可以看到如果返回 <code>true</code> 后面就木有了，返回 <code>false</code> 的时候，继续 <code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</code><br>我们一个一个看，先看 <code>addWaiter</code> 方法    </p>
<pre><code class="lang-java">private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);
        return node;
    }
</code></pre>
<p><code>new</code> 一个 <code>Node</code> 节点，使用独占模式   </p>
<pre><code class="lang-java">Node() { // Used to establish initial head or SHARED marker
        }
        Node(Thread thread, Node mode) { // Used by addWaiter
            this.nextWaiter = mode;
            this.thread = thread;
        }
        Node(Thread thread, int waitStatus) { // Used by Condition
            this.waitStatus = waitStatus;
            this.thread = thread;
        }
</code></pre>
<p>如果 尾节点为不为 <code>null</code>，代表双向链表已经初始化过了，尝试设置当前新建的节点为尾节点 <code>compareAndSetTail</code>，(尾节点设置要用CAS操作)设置成功后，加入链表中返回这个节点<br>如果失败（多个抢锁失败的线程同时过来了），或者尾节点为 <code>null</code> 了 调用 <code>enq</code> 方法，然后返回这个节点。<br>看下 <code>enq</code>方法的实现    </p>
<pre><code class="lang-java">private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
</code></pre>
<p>这是一个私有方法。在一个for循环中，一直操作，知道成功<br>如果尾节点为 <code>null</code> 了，代表链表还没有初始化，那么新建一个头节点，尾节点跟头节点指向同一个节点（正常情况下，头节点代表获取到锁的线程，设置头节点不需要CAS操作，但是这里链表还没初始化，还没有获取锁的线程。因此得使用CAS）<br>链表初始化好了后继续循环<br>设置当前节点为尾节点，加入链表，使用 <code>CAS</code> 加上 循环，保证成功，成功后返回当前节点<br>为什么能一定成功？如果是多个线程同时操作，那么可能有一个成功，其他失败，成功的就返回了，其他失败的继续尝试，每次都有一个成功，到最后，每个都可以操作完，因此 <code>CAS</code> 操作很多时候都是跟死循环在一起使用的。    </p>
<p>所以简单的一句话来说明 <code>addWaiter</code> 方法的作用，那就是，新建一个独占节点代表当前线程，加入到双向链表的尾部，如果链表还没初始化，则先初始化<br>这里注意，初始化的头节点是 waitStatus 值为0 ，不代表任何线程的节点，这里注意一下。<br>还发现一个问题没有 <code>addWaiter</code> 里面 </p>
<pre><code class="lang-java">Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
</code></pre>
<p>即便是没有这段，也是一样的，加上这段是为了应对大部分情况，因为链表只用初始化一次，大部分时候 <code>tail</code> 的指向不会为 <code>null</code> 的，这是题外话<br>继续看    </p>
<pre><code class="lang-java">
public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;&amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
</code></pre>
<p>后面就是 <code>acquireQueued</code> 方法了    </p>
<pre><code class="lang-java">final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head &amp;&amp; tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
</code></pre>
<p>这里的 failed 代表的是失败标记，interrupted 代表的是中断标记<br>可以看到，这里又是一个死循环，在循环里面处理<br>获取当前线程的前一个节点，如果前一个节点就是头节点，那么就再次尝试获取锁 <code>tryAcquire</code>，这个方法前面已经说过了，arg 都是 1<br>如果这里获取成功了，那么设置本节点为头节点（默认情况下，头节点代表已经获取锁的节点，但是也不是绝对，链表是延时加载的，如果每次获取锁都没有人竞争或者等到，这个链表压根就会初始化，只有有人需要等待的时候才会初始化）<br>没有获取成功就是进入 <code>shouldParkAfterFailedAcquire</code> 方法了    </p>
<pre><code class="lang-java">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL)
            /*
             * This node has already set status asking a release
             * to signal it, so it can safely park.
             */
            return true;
        if (ws &gt; 0) {
            /*
             * Predecessor was cancelled. Skip over predecessors and
             * indicate retry.
             */
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus &gt; 0);
            pred.next = node;
        } else {
            /*
             * waitStatus must be 0 or PROPAGATE. Indicate that we
             * need a signal, but don&#39;t park yet. Caller will need to
             * retry to make sure it cannot acquire before parking.
             */
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }
</code></pre>
<p>这段逻辑就是当前一个节点的等待状态值<code>waitStatus</code> 为 <code>Node.SIGNAL</code> 的时候，本节点需要等待（等待前一个节点激活），如果是大于0（代表取消）,就从链表里面删除这些（while循环）节点，直到遇到一个不大于0的节点为止，<br>如果 等于0，那或者 <code>PROPAGATE</code>,代表，我们需要信号，但是，不要现在阻塞我，我阻塞之前还要最后再来尝试一次，设置前一个节点的等待状态为 <code>SIGNAL</code>.<br>可以看到，只有前一个节点的等待状态为 <code>SIGNAL</code> 的时候，才返回 true，其他情况 都是 false<br>而这个方法外面，又是一个循环，通常如果这个方法返回false的时候，还是会再次进入到这里，可以看到最终，除非本线程拿到锁，否则还是得返回true，无非就是多有几次获取锁的机会（注意，这里不是尝试获取锁了，而是有尝试获取锁的机会，除非在这几次循环过程中，锁被释放掉了，而且本线程排在队列前面，并且没有插队的线程来抢锁，这个时候，本线程在多循环几次才可能抢到锁）<br>这个方法返回true，代表本线程要阻塞了 ，后面的方法 <code>parkAndCheckInterrupt</code> 就是阻塞当前线程，并检查中断标记    </p>
<pre><code class="lang-java">private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this);
        return Thread.interrupted();
    }
</code></pre>
<p><code>LockSupport.park(this)</code> 这个就是阻塞当前线程<br><code>return Thread.interrupted()</code> 这行，就是，当本线程被激活后，返回本线程是否被设置了中断标记    </p>
<p>注意的是 <code>LockSupport.park(this)</code> 阻塞线程，可以通过线程中断或者 <code>unpark</code> 唤醒<br>返回是是否中断 <code>Thread.interrupted()</code> 判断中断标记，并且清除标记。<br>所以在后面如果判断是中断，线程自己又设置了中断标记    </p>
<pre><code class="lang-java">static void selfInterrupt() {
        Thread.currentThread().interrupt();
    }
</code></pre>
<p><code>lock</code> 方法到这里就说完了，大部分时候，都是拿到锁，或者阻塞。    </p>
<h3 id="lockInterruptibly-方法"><a href="#lockInterruptibly-方法" class="headerlink" title="lockInterruptibly 方法"></a>lockInterruptibly 方法</h3><p>这个方法是，响应中断标记的加锁，会抛中断异常    </p>
<pre><code class="lang-java">public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }
</code></pre>
<p>直接调用 <code>AQS</code> 里面的方法    </p>
<pre><code class="lang-java">public final void acquireInterruptibly(int arg)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        if (!tryAcquire(arg))
            doAcquireInterruptibly(arg);
    }
</code></pre>
<p>如果这个时候，线程已经被中断了，直接抛异常，这里清除中断标记<br>如果没有中断，尝试获取锁，获取成功，返回，失败，就调用 <code>doAcquireInterruptibly</code> 方法  </p>
<pre><code class="lang-java">private void doAcquireInterruptibly(int arg)
        throws InterruptedException {
        final Node node = addWaiter(Node.EXCLUSIVE);
        boolean failed = true;
        try {
            for (;;) {
                final Node p = node.predecessor();
                if (p == head &amp;&amp; tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                    throw new InterruptedException();
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
</code></pre>
<p>这个方法跟 <code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>  类似。<br>先在链表尾部添加独占节点。<br>然后尝试获取锁，阻塞，不同的是，这里遇到中断标记，抛出中断异常，而不是设置中断标记，这里就需要注意了，当抛异常出去的时候，<code>failed</code> 是为 <code>false</code> 的.。<br>之前上面是没有说这个的，因为上面的方法，即使被中断了，也出不去循环的，只有获取锁的时候，也只是设置了一下中断标记，<code>failed</code> 始终是 <code>false</code> 的，但是这里，如果异常出去，就会有 <code>finally</code> 里面的逻辑了<br>看一下 <code>cancelAcquire</code> 这个方法     </p>
<pre><code class="lang-java">private void cancelAcquire(Node node) {
        if (node == null)
            return;
        node.thread = null;
        // 跳过前置节点状态大于0的节点（出队列）
        Node pred = node.prev;
        while (pred.waitStatus &gt; 0)
            node.prev = pred = pred.prev;
        // pred 是 node 的前置节点，predNext 是 pred.next ，那么显然是 node 节点
        Node predNext = pred.next;
        // 设置 node 节点的等待状态为 取消
        node.waitStatus = Node.CANCELLED;
        // 如果是尾节点，那就删掉，前置节点设置为尾节点
        if (node == tail &amp;&amp; compareAndSetTail(node, pred)) {
            compareAndSetNext(pred, predNext, null);
        } else {
            // node 不是尾节点，或者设置pred为尾节点的时候失败了（有其他节点又加上来了）
            int ws;
            // 如果 pred 不是头节点 并且 ( pred的状态为 SIGNAL, 或者 状态小于等于0并且成功设置为 SIGNAL) 并且 pred 前置节点代表的线程不为null，那就删除当前节点，连接前置节点和后置节点
            // 这里的条件有点复杂，简单点说，就是看前置节点被设置为是否通知后面节点的状态没，如果设置了，或者如果没有设置，但是现在成功设置了，删除节点，
            // 否则，现在就尝试激活当前节点的后置节点,看 unparkSuccessor 方法
            if (pred != head &amp;&amp;
                ((ws = pred.waitStatus) == Node.SIGNAL ||
                 (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;
                pred.thread != null) {
                Node next = node.next;
                if (next != null &amp;&amp; next.waitStatus &lt;= 0)
                    compareAndSetNext(pred, predNext, next);
            } else {
                // 如果pred为头节点，或者看上面的条件，就激活node的下一个节点
                unparkSuccessor(node);
            }
            node.next = node; // help GC
        }
    }
</code></pre>
<p>上面已经有注释了，继续看看 <code>unparkSuccessor</code>    </p>
<pre><code class="lang-java">private void unparkSuccessor(Node node) {
        /*
         * 如果本节点的状态值 &lt; 0 ，则设置为0，cas操作失败了也没关系，可能状态被等待的线程修改了
         * 修改的原因是，当前节点不需要等待锁资源，将要唤醒下一个节点
         */
        int ws = node.waitStatus;
        if (ws &lt; 0)
            compareAndSetWaitStatus(node, ws, 0);
        /*
         * 找到下一个节点，如果不为null，并且没有取消（状态值），则下一个节点就是继承人
         * 如果不满足上面的条件，就从尾节点开始，向前寻找(到当前节点的位置)未取消的节点(一直寻找，最后满足的那个)
         */
        Node s = node.next;
        if (s == null || s.waitStatus &gt; 0) {
            s = null;
            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
                if (t.waitStatus &lt;= 0)
                    s = t;
        }
        // 如果找到继承人，唤醒线程
        if (s != null)
            LockSupport.unpark(s.thread);
    }
</code></pre>
<p>注释也已经有了，注意的是从<code>cancelAcquire</code> 方法过来的节点，等待状态值是取消，也就是 &gt; 0 的<br>参见上面获取锁的逻辑， 阻塞是在循环里面的，这里被激活了，也只是循环一次后，激活阻塞（大部分时候）<br>其实，这里主要保证的是，如果当前节点被取消了，至少要保证它后面的节点会被它前面的节点激活，或者立即就激活一次    </p>
<h3 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock"></a>tryLock</h3><p>在来看看 <code>tryLock</code> ，尝试获取锁，获取成功返回true，获取失败返回false，直截了当    </p>
<pre><code class="lang-java">public boolean tryLock() {
        return sync.nonfairTryAcquire(1);
    }
</code></pre>
<p>调用的时候 <code>Sync</code> 里面的方法    </p>
<pre><code class="lang-java">final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc &lt; 0) // overflow
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                setState(nextc);
                return true;
            }
            return false;
        }
</code></pre>
<p>这个方法就是 <code>lock</code> 里面调用过的方法，成功就返回true，失败就是返回 false</p>
<h3 id="tryLock-long-timeout-TimeUnit-unit"><a href="#tryLock-long-timeout-TimeUnit-unit" class="headerlink" title="tryLock(long timeout, TimeUnit unit)"></a>tryLock(long timeout, TimeUnit unit)</h3><p>限时等待的 <code>tryLock</code>    </p>
<pre><code class="lang-java">public boolean tryLock(long timeout, TimeUnit unit)
            throws InterruptedException {
        return sync.tryAcquireNanos(1, unit.toNanos(timeout));
    }
</code></pre>
<p>直接调用 <code>AQS</code> 的方法    </p>
<pre><code class="lang-java">public final boolean tryAcquireNanos(int arg, long nanosTimeout)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        return tryAcquire(arg) ||
            doAcquireNanos(arg, nanosTimeout);
    }
</code></pre>
<p>同样是响应中断的<br><code>tryAcquire</code> 就不说了，调用子类的方法<br>看看 <code>doAcquireNanos</code>    </p>
<pre><code class="lang-java">private boolean doAcquireNanos(int arg, long nanosTimeout)
            throws InterruptedException {
        // 如果已经超时了，返回 false
        if (nanosTimeout &lt;= 0L)
            return false;
        // 获取 最后期限
        final long deadline = System.nanoTime() + nanosTimeout;
        // 提交节点到链表最后
        final Node node = addWaiter(Node.EXCLUSIVE);
        boolean failed = true;
        try {
            for (;;) {
                final Node p = node.predecessor();
                // 如果前置节点是头节点，尝试获取获取锁，获取成功返回true
                if (p == head &amp;&amp; tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return true;
                }
                nanosTimeout = deadline - System.nanoTime();
                // 如果超时了，返回false
                if (nanosTimeout &lt;= 0L)
                    return false;
                // 判断是否需要阻塞 如果离 最后期限只剩1秒了，就不需要阻塞了，一直循环就行了
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    nanosTimeout &gt; spinForTimeoutThreshold)
                    // 限时阻塞, 阻塞可能是限时等待结束，或者前置节点激活
                    LockSupport.parkNanos(this, nanosTimeout);
                // 中断标识判断
                if (Thread.interrupted())
                    throw new InterruptedException();
            }
        } finally {
            // 中断出去的逻辑
            if (failed)
                cancelAcquire(node);
        }
    }
</code></pre>
<p>可以看到，阻塞还是使用的 <code>LockSupport</code> 阻塞工具类    </p>
<h3 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h3><p>看一下是否锁的逻辑    </p>
<pre><code class="lang-java">public void unlock() {
        sync.release(1);
    }
</code></pre>
<p>调用 <code>AQS</code> 里面的逻辑   </p>
<pre><code class="lang-java">public final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            if (h != null &amp;&amp; h.waitStatus != 0)
                unparkSuccessor(h);
            return true;
        }
        return false;
    }
</code></pre>
<p>尝试释放，释放成功，判断是否需要激活后面的节点，如果需要就激活<br><code>tryRelease</code> 由子类 <code>Sync</code> 实现</p>
<pre><code class="lang-java">protected final boolean tryRelease(int releases) {
            int c = getState() - releases;
            if (Thread.currentThread() != getExclusiveOwnerThread())
                throw new IllegalMonitorStateException();
            boolean free = false;
            if (c == 0) {
                free = true;
                setExclusiveOwnerThread(null);
            }
            setState(c);
            return free;
        }
</code></pre>
<p>当 <code>AQS</code> 里面的 <code>state</code> 值为0，才算当前线程释放锁    </p>
<h3 id="newCondition"><a href="#newCondition" class="headerlink" title="newCondition"></a>newCondition</h3><p>最后看一个 <code>newCondition</code>    </p>
<pre><code class="lang-java">public Condition newCondition() {
        return sync.newCondition();
    }
</code></pre>
<p>调用  <code>Sync</code> 里面的方法   </p>
<pre><code class="lang-java">final ConditionObject newCondition() {
            return new ConditionObject();
        }
</code></pre>
<p>这个 <code>ConditionObject</code> 对象是 <code>AQS</code> 里面定义的,实现 <code>Condition</code> 接口    </p>
<pre><code class="lang-java">public interface Condition {
    /**
     * 等待信号量，响应中断
     */
    void await() throws InterruptedException;

    /**
     * 等待信号量，不响应中断
     */
    void awaitUninterruptibly();

    /**
     * 限时等待
     */
    long awaitNanos(long nanosTimeout) throws InterruptedException;

    /**
     * 限时等待
     */
    boolean await(long time, TimeUnit unit) throws InterruptedException;

    /**
     * 限时等待
     */
    boolean awaitUntil(Date deadline) throws InterruptedException;

    /**
     * 激活一个阻塞线程
     */
    void signal();

    /**
     * 激活所有阻塞线程
     */
    void signalAll();
}
</code></pre>
<p>用法就是 <code>new</code> 一个 <code>Condition</code> 出来，获取锁后可以调用 <code>await</code> （注意，不要跟 wait 弄混了）。<code>signal</code> 方法也需要持有锁的线程才能调用。<br>从 <code>await</code> 跟一下代码<br><code>ReentrantLock</code> 里面的 <code>newCondition</code> 方法，直接调用内部类 <code>Sync</code></p>
<pre><code class="lang-java">public Condition newCondition() {
        return sync.newCondition();
    }
</code></pre>
<p><code>Sync</code>    </p>
<pre><code class="lang-java">final ConditionObject newCondition() {
            return new ConditionObject();
        }
</code></pre>
<p>这个 <code>ConditionObject</code> 是 <code>AQS</code> 内部类对 <code>Condition</code> 接口的实现<br>然后具体跟一下 <code>await</code> 方法    </p>
<pre><code class="lang-java">/**
         * 在条件上等待
         * 1. 如果当前线程已经中断，则抛 InterruptedException 异常
         * 2. 保存当前 getState 状态
         * 3. 释放 state，如果失败，就抛 IllegalMonitorStateException。（当前线程必须持有锁）
         * 4. 阻塞，直到被激活（signal或者中断）
         * 5. 重新尝试获取之前持有的锁（可能继续等待）
         * 6. 如果在步骤4，阻塞的时候中断了，抛 InterruptedException
         * Implements interruptible condition wait.
         * &lt;ol&gt;
         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.
         * &lt;li&gt; Save lock state returned by {@link #getState}.
         * &lt;li&gt; Invoke {@link #release} with saved state as argument,
         * throwing IllegalMonitorStateException if it fails.
         * &lt;li&gt; Block until signalled or interrupted.
         * &lt;li&gt; Reacquire by invoking specialized version of
         * {@link #acquire} with saved state as argument.
         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.
         * &lt;/ol&gt;
         */
        public final void await() throws InterruptedException {
            // 如果中断了，就抛中断异常
            if (Thread.interrupted())
                throw new InterruptedException();
            // 添加一个节点到条件队列尾部
            Node node = addConditionWaiter();
            // 释放锁资源（如果没持有锁，会抛异常出来）
            int savedState = fullyRelease(node);
            int interruptMode = 0;
            // 循环判断，如果当前节点不在同步队列中（当调用 signal 方法的时候，会将节点放入同步队列）
            while (!isOnSyncQueue(node)) {
                // 线程阻塞，正常流程应该是到这里
                LockSupport.park(this);
                // 阻塞取消，出来判断中断状态,如果 ！= 0，就是没有中断
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
            }
            // 从上面出来后，尝试获取锁，这里还是会触发等待锁的阻塞（如果要等的话），获取成功，处理了继续判断中断状态
            if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            // 如果 当前节点在条件队列上后后续节点，那么清除一遍无效节点
            if (node.nextWaiter != null) // clean up if cancelled
                unlinkCancelledWaiters();
            // 如果有中断状态，判断是否要抛异常
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
        }
</code></pre>
<p>代码上面已经有注释了，简单说一下，这里涉及到  节点 <code>Node</code> 的条件同步队列，再看一下 <code>Node</code> 的定义</p>
<pre><code class="lang-java">/**
        * 链接到前驱节点，当前节点/线程依赖它来检查 waitStatus 。
        * 在入同步队列时被设置(waitStatus)，并且仅在移除同步队列时才归零
        * （为了GC的目的）。 此外，在取消(出队列)状态为（CANCELLED）前驱节点时，我们使用简单的循环找到未取消的节点 
        * 这将始终存在，因为头节点从未被取消：节点仅作为成功获取的结果而变为头。
        * 被取消的线程永远不会成功获取，并且线程只取消自身，
        * 而不是任何其他节点。
        */
        volatile Node prev;
        /**
        * 链接到后续节点，当前节点/线程释放时释放。
        * 在入同步队列期间分配，在绕过取消的前驱节
        * 点时调整，并在出同步队列时取消（为了GC的目的）。
        * enq操作不会分配前驱节点的next字段，直到附加之后，
        * 因此看到一个为null的next字段不一定意味着该节点在
        * 队列的末尾。 但是，如果next字段显示为null,我们
        * 可以从尾部扫描prev，仔细检查。 被取消的节点的next字段
        * 被设置为指向节点本身而不是null，以使isOnSyncQueue更
        * 方便操作。调用isOnSyncQueue时，如果节点（始终
        * 是放置在条件队列上的节点）正等待在同步队列上重新获取，则返回true。
        **/
        volatile Node next;
        /**
         * 这个节点代表的线程，入队的时候初始化，出队的时候设置null
         * construction and nulled out after use.
         */
        volatile Thread thread;
         /**
        * 将此节点入列的线程。在构造方法里初始化，使用后清零。
        * 链接到下一个节点等待条件，或特殊值SHARED。
        * 因为条件队列只有在保持在独占模式时才被访问，
        * 所以我们只需要一个简单的链接队列来保存节点，
        * 同时等待条件。 然后将它们转移到队列中以重新获取。
        * 并且因为条件只能是排它的，我们通过使用特殊的
        * 值来指示共享模式来保存一个字段。
        */
        Node nextWaiter;
</code></pre>
<p>在锁的实现里面，我们看到了同步队列，是一个双向链表，使用了 <code>prev</code> 和 <code>next</code> 。<br>条件等待队列是一个单向链表,使用了 <code>nextWaiter</code> 字段    </p>
<p>看一下 <code>addConditionWaiter</code> 方法    </p>
<pre><code class="lang-java">/**
         * 添加一个新的等待节点到条件等待队列队尾
         * @return its new wait node
         */
        private Node addConditionWaiter() {
            Node t = lastWaiter;
            // 如果最后一个节点取消了，那么清理整个队列中取消的节点
            if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {
                unlinkCancelledWaiters();
                t = lastWaiter;
            }
            // 新建一个mode 为 CONDITION 的节点
            Node node = new Node(Thread.currentThread(), Node.CONDITION);
            if (t == null)
                firstWaiter = node;
            else
                t.nextWaiter = node;
            lastWaiter = node;
            return node;
        }
</code></pre>
<p><code>firstWaiter</code>, <code>lastWaiter</code> 是 <code>ConditionObject</code> 里面的字段    </p>
<pre><code class="lang-java">public class ConditionObject implements Condition, java.io.Serializable {
        private static final long serialVersionUID = 1173984872572414699L;
        /** First node of condition queue. */
        private transient Node firstWaiter;
        /** Last node of condition queue. */
        private transient Node lastWaiter;
</code></pre>
<p>重点关注 <code>Node.CONDITION</code> 和 <code>nextWaiter</code><br>这里可以看到节点的等待状态是 <code>CONDITION</code>,进的队列是 消息等待队列    </p>
<p>进入队列后，释放锁    </p>
<pre><code class="lang-java">/**
     * 释放本节点持有的 state
     * 如果释放失败，就标记这个节点为取消状态
     */
    final int fullyRelease(Node node) {
        boolean failed = true;
        try {
            int savedState = getState();
            if (release(savedState)) {
                failed = false;
                return savedState;
            } else {
                throw new IllegalMonitorStateException();
            }
        } finally {
            if (failed)
                node.waitStatus = Node.CANCELLED;
        }
    }
</code></pre>
<p>其中 <code>release</code> 方法就是正常的锁的释放流程，上面已经看过了<br>然后就是一个循环，判断节点释放在同步队列（双向链表，正常情况是不在的，当其他线程调用了 signal 后才会放入到同步队列中）。循环内部就是阻塞了，阻塞可以被其他线程唤醒或者中断唤醒<br>当出了循环后，就是重新尝试获取锁（这里正常的锁获取流程，也会阻塞等待），和中断处理<br><code>acquireQueued</code> 之前看过，就不分析了。<br><code>unlinkCancelledWaiters</code> 这个方法就是清理条件队列的无效节点（CANNELED 状态）    </p>
<pre><code class="lang-java">/**
         * 从条件队列清除取消的等待节点，这个方法只应该被持有锁的线程调用
         */
        private void unlinkCancelledWaiters() {
            Node t = firstWaiter;
            Node trail = null;
            while (t != null) {
                Node next = t.nextWaiter;
                if (t.waitStatus != Node.CONDITION) {
                    t.nextWaiter = null;
                    if (trail == null)
                        firstWaiter = next;
                    else
                        trail.nextWaiter = next;
                    if (next == null)
                        lastWaiter = trail;
                }
                else
                    trail = t;
                t = next;
            }
        }
</code></pre>
<p><code>reportInterruptAfterWait</code> 方法是中断处理</p>
<pre><code class="lang-java">/**
         * 根据中断标记，抛异常，或者设置中断状态
         * Throws InterruptedException, reinterrupts current thread, or
         * does nothing, depending on mode.
         */
        private void reportInterruptAfterWait(int interruptMode)
            throws InterruptedException {
            if (interruptMode == THROW_IE)
                throw new InterruptedException();
            else if (interruptMode == REINTERRUPT)
                selfInterrupt();
        }
</code></pre>
<p>其他的几个 <code>await</code> 方法就不一一细说了。    </p>
<pre><code class="lang-java">/**
         * 在条件上等待 nanosTimeout 长时间
         * 基本跟上面一样
         * Implements timed condition wait.
         * &lt;ol&gt;
         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.
         * &lt;li&gt; Save lock state returned by {@link #getState}.
         * &lt;li&gt; Invoke {@link #release} with saved state as argument,
         * throwing IllegalMonitorStateException if it fails.
         * &lt;li&gt; Block until signalled, interrupted, or timed out.
         * &lt;li&gt; Reacquire by invoking specialized version of
         * {@link #acquire} with saved state as argument.
         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.
         * &lt;/ol&gt;
         */
        public final long awaitNanos(long nanosTimeout)
                throws InterruptedException {
            // 如果中断了，就抛中断异常
            if (Thread.interrupted())
                throw new InterruptedException();
            // 添加一个节点到条件队列尾部
            Node node = addConditionWaiter();
            // 释放锁资源（如果没持有锁，会抛异常出来）
            int savedState = fullyRelease(node);
            // 阻塞的截至时间
            final long deadline = System.nanoTime() + nanosTimeout;
            int interruptMode = 0;
            // 循环判断，如果当前节点不在同步队列中（当调用 signal 方法的时候，会将节点放入同步队列）
            while (!isOnSyncQueue(node)) {
                // 超时，跳出循环
                if (nanosTimeout &lt;= 0L) {
                    // 设置节点状态为取消，如果设置成功，那就是超时，如果设置失败（可能这个节点被激活了，超时就是 false）
                    transferAfterCancelledWait(node);
                    break;
                }
                // 如果要阻塞的时间大于 1s，继续限时阻塞（如果小于1s了，就不继续阻塞了，循环直到超时，获取被唤醒，很多地方都是这样的设计）
                if (nanosTimeout &gt;= spinForTimeoutThreshold)
                    LockSupport.parkNanos(this, nanosTimeout);
                // 如果有中断，跳出循环
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
                // 计算离超时时间点的间隔
                nanosTimeout = deadline - System.nanoTime();
            }
            // 从上面出来后，尝试获取锁，这里还是会触发等待锁的阻塞（如果要等的话），获取成功，处理了继续判断中断状态
            if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            // 如果 当前节点在条件队列上后后续节点，那么清除一遍无效节点
            if (node.nextWaiter != null)
                unlinkCancelledWaiters();
            // 如果有中断状态，判断是否要抛异常
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
            return deadline - System.nanoTime();
        }

/**
         * 在条件上等待，直到给定时间点
         * 基本同上
         * Implements absolute timed condition wait.
         * &lt;ol&gt;
         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.
         * &lt;li&gt; Save lock state returned by {@link #getState}.
         * &lt;li&gt; Invoke {@link #release} with saved state as argument,
         * throwing IllegalMonitorStateException if it fails.
         * &lt;li&gt; Block until signalled, interrupted, or timed out.
         * &lt;li&gt; Reacquire by invoking specialized version of
         * {@link #acquire} with saved state as argument.
         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.
         * &lt;li&gt; If timed out while blocked in step 4, return false, else true.
         * &lt;/ol&gt;
         */
        public final boolean awaitUntil(Date deadline)
                throws InterruptedException {
            // 阻塞的截至时间
            long abstime = deadline.getTime();
            // 如果中断了，就抛中断异常
            if (Thread.interrupted())
                throw new InterruptedException();
            // 添加一个节点到条件队列尾部
            Node node = addConditionWaiter();
            // 释放锁资源（如果没持有锁，会抛异常出来）
            int savedState = fullyRelease(node);
            boolean timedout = false;
            int interruptMode = 0;
            // 循环判断，如果当前节点不在同步队列中（当调用 signal 方法的时候，会将节点放入同步队列）
            while (!isOnSyncQueue(node)) {
                // 超时，跳出循环
                if (System.currentTimeMillis() &gt; abstime) {
                    // 设置节点状态为取消，如果设置成功，那就是超时，如果设置失败（可能这个节点被激活了，超时就是 false）
                    timedout = transferAfterCancelledWait(node);
                    break;
                }
                // 阻塞
                LockSupport.parkUntil(this, abstime);
                // 判断中断，如果有，跳出循环
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
            }
            // 从上面出来后，尝试获取锁，这里还是会触发等待锁的阻塞（如果要等的话），获取成功，处理了继续判断中断状态
            if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            // 如果 当前节点在条件队列上后后续节点，那么清除一遍无效节点
            if (node.nextWaiter != null)
                unlinkCancelledWaiters();
            // 如果有中断状态，判断是否要抛异常
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
            // 如果超时，返回false
            return !timedout;
        }
        /**
         * 在条件上限时等待
         * 基本同上
         * Implements timed condition wait.
         * &lt;ol&gt;
         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.
         * &lt;li&gt; Save lock state returned by {@link #getState}.
         * &lt;li&gt; Invoke {@link #release} with saved state as argument,
         * throwing IllegalMonitorStateException if it fails.
         * &lt;li&gt; Block until signalled, interrupted, or timed out.
         * &lt;li&gt; Reacquire by invoking specialized version of
         * {@link #acquire} with saved state as argument.
         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.
         * &lt;li&gt; If timed out while blocked in step 4, return false, else true.
         * &lt;/ol&gt;
         */
        public final boolean await(long time, TimeUnit unit)
                throws InterruptedException {
            long nanosTimeout = unit.toNanos(time);
            // 如果中断了，就抛中断异常
            if (Thread.interrupted())
                throw new InterruptedException();
            // 添加一个节点到条件队列尾部
            Node node = addConditionWaiter();
            // 释放锁资源（如果没持有锁，会抛异常出来）
            int savedState = fullyRelease(node);
            // 阻塞的截至时间
            final long deadline = System.nanoTime() + nanosTimeout;
            boolean timedout = false;
            int interruptMode = 0;
            // 循环判断，如果当前节点不在同步队列中（当调用 signal 方法的时候，会将节点放入同步队列）
            while (!isOnSyncQueue(node)) {
                if (nanosTimeout &lt;= 0L) {
                    // 设置节点状态为取消，如果设置成功，那就是超时，如果设置失败（可能这个节点被激活了，超时就是 false）
                    timedout = transferAfterCancelledWait(node);
                    break;
                }
                // 如果要阻塞的时间大于 1s，继续限时阻塞（如果小于1s了，就不继续阻塞了，循环直到超时，获取被唤醒，很多地方都是这样的设计）
                if (nanosTimeout &gt;= spinForTimeoutThreshold)
                    LockSupport.parkNanos(this, nanosTimeout);
                // 如果有中断，跳出循环
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
                // 计算离超时时间点的间隔
                nanosTimeout = deadline - System.nanoTime();
            }
            // 从上面出来后，尝试获取锁，这里还是会触发等待锁的阻塞（如果要等的话），获取成功，处理了继续判断中断状态
            if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            // 如果 当前节点在条件队列上后后续节点，那么清除一遍无效节点
            if (node.nextWaiter != null)
                unlinkCancelledWaiters();
            // 如果有中断状态，判断是否要抛异常
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
            // 如果超时，返回false
            return !timedout;
        }
</code></pre>
<p>然后再看一下 <code>signal</code> 方法    </p>
<pre><code class="lang-java">/**
         * 激活一个等待节点
         * Moves the longest-waiting thread, if one exists, from the
         * wait queue for this condition to the wait queue for the
         * owning lock.
         *
         * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
         * returns {@code false}
         */
        public final void signal() {
            // 如果锁的持有者不是当前线程，抛异常
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
            Node first = firstWaiter;
            // 如果等待队列不为空，激活第一个
            if (first != null)
                doSignal(first);
        }
</code></pre>
<p>可以看到当前线程必须持有锁    </p>
<pre><code class="lang-java">/**
         * 从参数node，开始，异常，并且转移直到一个没有取消的节点，或者nul
         * Removes and transfers nodes until hit non-cancelled one or
         * null. Split out from signal in part to encourage compilers
         * to inline the case of no waiters.
         * @param first (non-null) the first node on condition queue
         */
        private void doSignal(Node first) {
            do {
                // 从first 开始向后遍历
                if ( (firstWaiter = first.nextWaiter) == null)
                    lastWaiter = null;
                // first 节点从链表中断开
                first.nextWaiter = null;
                // 转换first节点，如果成功，跳出循环，如果失败，继续下一个节点，获取节点为null，跳出循环
            } while (!transferForSignal(first) &amp;&amp;
                     (first = firstWaiter) != null);
        }
</code></pre>
<p>就是移除条件队列的第一个节点然后激活，如果激活失败，继续尝试下一个节点，直到激活成功，或者队列遍历完   </p>
<pre><code class="lang-java">/**
     * 这个方法的功能就是激活在条件上等待的线程（node里面的）
     * 将节点从条件队列，丢到同步队列中，成功返回true，失败返回false
     * Transfers a node from a condition queue onto sync queue.
     * Returns true if successful.
     * @param node the node
     * @return true if successfully transferred (else the node was
     * cancelled before signal)
     */
    final boolean transferForSignal(Node node) {
        /*
         * 如果不能改变 等待状态值，那么这个节点就是取消状态(就是不通知)
         * If cannot change waitStatus, the node has been cancelled.
         */
        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
            return false;
        /*
         * 将节点插入到同步队列尾部
         * 如果 前一个节点的等待状态是取消状态，那么设置为 SIGNAL，代表本节点需要收到前一个节点的通知
         * 如果设置失败，那么立马激活本节点代表的线程，返回true
         * Splice onto queue and try to set waitStatus of predecessor to
         * indicate that thread is (probably) waiting. If cancelled or
         * attempt to set waitStatus fails, wake up to resync (in which
         * case the waitStatus can be transiently and harmlessly wrong).
         */
        Node p = enq(node);
        int ws = p.waitStatus;
        if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
            LockSupport.unpark(node.thread);
        return true;
    }
</code></pre>
<p>先尝试将等待状态修改为0（初始状态),然后入同步队列，告诉前一个前一个节点，本节点需要等待通知（获取锁）。如果设置通知失败，那先激活当前线程（执行到获取锁那里，阻塞或者获取）    </p>
<p>最后看 <code>signalAll</code>    </p>
<pre><code class="lang-java">/**
         * 激活所有节点
         * Moves all threads from the wait queue for this condition to
         * the wait queue for the owning lock.
         *
         * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
         * returns {@code false}
         */
        public final void signalAll() {
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
            Node first = firstWaiter;
            if (first != null)
                doSignalAll(first);
        }
</code></pre>
<pre><code class="lang-java">/**
         * 从first开始激活所有等待的节点
         * Removes and transfers all nodes.
         * @param first (non-null) the first node on condition queue
         */
        private void doSignalAll(Node first) {
            lastWaiter = firstWaiter = null;
            // 逻辑跟上面是一样的，不过就是激活所有节点，所有取消了对 transferForSignal 的结果判断
            do {
                Node next = first.nextWaiter;
                first.nextWaiter = null;
                transferForSignal(first);
                first = next;
            } while (first != null);
        }
</code></pre>
<p>如果理解上激活单个节点，这里就好理解了，激活所有节点，所谓激活，就是将节点丢到同步队列里面去参与锁的竞争。    </p>
<p>上面还有几个限时等待，注意的是，如果超时后，就会将节点丢到同步队列参与锁的竞争，或者 <code>signal</code> 方法也可以触发<br>非限时等待方法，只有 <code>signal</code> 才能激活    </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过分析，学到什么    </p>
<ol>
<li><code>AQS</code> 的内部结构，虽然还没完全了解，但是基本概念知道了，等后面再分析几个同步器，就可以对 <code>AQS</code> 进行总结了    </li>
<li>可重入锁基本掌握，知道了锁并不是随机获取的，而是有顺序的，所谓非公平锁，那也只是在刚好释放锁的时候，下一个节点跟当前请求线程的竞争    </li>
<li>条件，基本都是使用 <code>AQS</code> 内部的实现。知道了内部有同步队列和条件队列    </li>
</ol>
<p>锁的顺序获取测试     </p>
<pre><code class="lang-java">public static final ReentrantLock lock = new ReentrantLock();
    public static void main(String[] args) {
        // 主线程获取锁
        lock.lock();
        new Thread(() -&gt; {
            System.out.println(&quot;线程1 尝试获取锁&quot;);
            lock.lock();
            SleepUtil.sleepQuietly(2);//业务运行2s
            System.out.println(&quot;线程1 获取到锁&quot;);
            System.out.println(&quot;线程1 释放锁&quot;);
            lock.unlock();
        }).start();
        SleepUtil.sleepQuietly(2);//停2s，等线程运行到等锁那里
        new Thread(() -&gt; {
            System.out.println(&quot;线程2 尝试获取锁&quot;);
            lock.lock();
            SleepUtil.sleepQuietly(2);//业务运行2s
            System.out.println(&quot;线程2 获取到锁&quot;);
            System.out.println(&quot;线程2 释放锁&quot;);
            lock.unlock();
        }).start();
        SleepUtil.sleepQuietly(2);//停2s，等线程运行到等锁那里
        new Thread(() -&gt; {
            System.out.println(&quot;线程3 尝试获取锁&quot;);
            lock.lock();
            SleepUtil.sleepQuietly(2);//业务运行2s
            System.out.println(&quot;线程3 获取到锁&quot;);
            System.out.println(&quot;线程3 释放锁&quot;);
            lock.unlock();
        }).start();
        SleepUtil.sleepQuietly(2);//停2s，等线程运行到等锁那里
        // 主线程释放锁
        lock.unlock();
    }
</code></pre>
<p>运行结果（可以多次运行，但是输出是固定的）</p>
<pre><code class="lang-txt">线程1 尝试获取锁
线程2 尝试获取锁
线程3 尝试获取锁
线程1 获取到锁
线程1 释放锁
线程2 获取到锁
线程2 释放锁
线程3 获取到锁
线程3 释放锁
</code></pre>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>AQS</tag>
        <tag>Lock</tag>
      </tags>
  </entry>
  <entry>
    <title>Map 源码阅读</title>
    <url>/2019/07/26/Map-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<p>常用 Map 的实现分析 </p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>实现原理就是数组，根据 hash 找到数组中对应的位置 （取余）, 如果已经有值了，但是 key不同，构建链表，链表长度 &gt; 8 了，链表变成红黑树。<br>key，value 允许 null    </p>
<p>重点方法注释<br>putVal 这个方法是往 map 里面添加元素使用的内部方法</p>
<pre><code class="lang-java">/**
* 这里是 put 到 map 的逻辑
*/
/**
    * Implements Map.put and related methods
    *
    * @param hash hash for key
    * @param key the key
    * @param value the value to put
    * @param onlyIfAbsent if true, don&#39;t change existing value
    * @param evict if false, the table is in creation mode.
    * @return previous value, or null if none
    */
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                boolean evict) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    // 第一个判断，如果内部的数组还没初始化，那么先初始化（可能说初始化不准确），resize 方法，是要扩容的时候调用的，如果未初始化，的确需要第一次扩容
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;

    // hash 值 对数组长度取余，如果对应 index 位置没有元素，那么直接就放在数组上
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        // 如果 index 上有元素了
        Node&lt;K,V&gt; e; K k;
        // 如果put 的 key 已经存在了（先比较 hash，再判断是否 equals）
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;
        // 如果已经成为 TreeNode 了
        // 默认情况下，map 内部是一个数组，里面存的是 Node 节点， 如果存在相同位置的元素，那么用 Node 组成单向链表，如果链表长度超过指定长度，进化成 红黑树
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        else {
            // 否则，遍历链表，找到相同的key，或者链表尾部插入一个节点，如果长度超过来阀值，变换成红黑树
            for (int binCount = 0; ; ++binCount) {
                // p.next == null 就是遍历到了尾部了
                if ((e = p.next) == null) {
                    // 新建节点，插入链表尾部
                    p.next = newNode(hash, key, value, null);
                    // 如果超过阀值了（8），换成红黑树
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                // 或者，存在 key 相同的节点，找到
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        // e != null 代表存在相同的 key
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            // 如果 onlyIfAbsent = true 代表不替换旧值，当然，如果旧值为 null，那也替换了
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            // 一个空方法，留待子类实现，当相同 key 的节点的时候
            afterNodeAccess(e);
            return oldValue;
        }
    }
    // 如果是新增了节点，修改数 加一
    ++modCount;
    // 如果 自增 size 后 超过阀值了，扩容
    if (++size &gt; threshold)
        resize();
    // 这是一个空方法，插入节点后，留待子类实现自己的动作
    afterNodeInsertion(evict);
    // put 方法，返回的是原来的值，如果没有原来的值，返回 null
    return null;
}
</code></pre>
<p>resize 扩容<br>当 size &gt; threshold 的时候，扩容</p>
<pre><code class="lang-java">/**
 * 初始化或者双倍扩容
 */
/**
    * Initializes or doubles table size.  If null, allocates in
    * accord with initial capacity target held in field threshold.
    * Otherwise, because we are using power-of-two expansion, the
    * elements from each bin must either stay at same index, or move
    * with a power of two offset in the new table.
    *
    * @return the table
    */
final Node&lt;K,V&gt;[] resize() {
    Node&lt;K,V&gt;[] oldTab = table;
    // 拿到 旧的 最大容量 和 扩容门槛
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    // 如果 旧的最大容量 &gt; 0 代表已经初始化过了
    if (oldCap &gt; 0) {
        // 如果旧的容量已经超过 最大容量了，直接把门槛设为 最大 int 值
        if (oldCap &gt;= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        // 新容量为旧容量的2倍，&amp;&amp; 旧容量 &gt;= 默认容量（16）
        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            // 新门槛也2倍
            newThr = oldThr &lt;&lt; 1; // double threshold
    }
    else if (oldThr &gt; 0) // initial capacity was placed in threshold
        // 如果在构造的时候，指定了初始值，那么 oldThr 就是初值的 tableSizeFor(cap) 大小，是一个2的指数倍，这个值被赋值给 newCap
        newCap = oldThr;
    else {               // zero initial threshold signifies using defaults
        // 如果是默认的构造，那么，就全部是初值
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    // 看到，在 上面第二个条件中 newThr 没有设值， newThr 将变成 newCap * loadFactor
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                    (int)ft : Integer.MAX_VALUE);
    }
    // 一般是两倍扩容，特例情况是直接制定了参数和超过最大容量,cap 除非超过 最大值，否则，都是 2 的指数倍
    threshold = newThr;
    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
    table = newTab;
    if (oldTab != null) {
        for (int j = 0; j &lt; oldCap; ++j) {
            Node&lt;K,V&gt; e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;
                // 如果原来的元素没有变成链表结构
                if (e.next == null)
                    newTab[e.hash &amp; (newCap - 1)] = e;
                // 如果节点是 红黑树的节点了
                else if (e instanceof TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                // 链表结构
                else { // preserve order
                    Node&lt;K,V&gt; loHead = null, loTail = null;
                    Node&lt;K,V&gt; hiHead = null, hiTail = null;
                    Node&lt;K,V&gt; next;
                    do {
                        next = e.next;
                        // 这里看起来，就是将链表，拆分，根据条件 e.hash &amp; oldCap == 0 来判断，其实就是hash中对应位是否为1
                        if ((e.hash &amp; oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    // 拆分后，分别放在低位 j 和 高位 j + oldCap
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}
</code></pre>
<p>getNode 是用来根据key找到对应节点的方法</p>
<pre><code class="lang-java">/**
 * get 方法
 */
/**
    * Implements Map.get and related methods
    *
    * @param hash hash for key
    * @param key the key
    * @return the node, or null if none
    */
final Node&lt;K,V&gt; getNode(int hash, Object key) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
    // 数组有值，并且hash 对应 index 位置有值
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (first = tab[(n - 1) &amp; hash]) != null) {
        // 判断 第一个 Node 的 hash，==，equals
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
            return first;
        // 第一个节点不满足，如果有后续节点继续判断
        if ((e = first.next) != null) {
            // 如果是红黑树节点，则在树里面查找
            if (first instanceof TreeNode)
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            do {
                // 否则就遍历链表了，判断 hash, ==, equals
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
</code></pre>
<p>removeNode 这个是根据key删除 节点的方法</p>
<pre><code class="lang-java">/**
* Implements Map.remove and related methods
*
* @param hash hash for key
* @param key the key
* @param value the value to match if matchValue, else ignored
* @param matchValue if true only remove if value is equal
* @param movable if false do not move other nodes while removing
* @return the node, or null if none
*/
final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,
                            boolean matchValue, boolean movable) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;
    // 根据 hash 找到对应 index，并且 index上有值
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (p = tab[index = (n - 1) &amp; hash]) != null) {
        Node&lt;K,V&gt; node = null, e; K k; V v;
        // 如果数组上的节点就是给定的key（hash，== 或者 equals）
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            node = p;
        else if ((e = p.next) != null) {
            // 如果第一个节点不是，并且有后续节点（链表）
            if (p instanceof TreeNode)
                // 红黑树的情况
                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);
            else {
                // 遍历链表，找到 key 对应的节点
                do {
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key ||
                            (key != null &amp;&amp; key.equals(k)))) {
                        node = e;
                        break;
                    }
                    p = e;
                } while ((e = e.next) != null);
            }
        }
        // 如果找到了，后面的条件是判断 节点对应的value ，是不是给定的 value（equals）
        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||
                                (value != null &amp;&amp; value.equals(v)))) {
            // 如果是红黑树，那就红黑树里面删除节点
            if (node instanceof TreeNode)
                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);
            // 如果是第一个节点
            else if (node == p)
                tab[index] = node.next;
            // p 是e的前一个节点
            else
                p.next = node.next;
            ++modCount;
            --size;
            afterNodeRemoval(node);
            return node;
        }
    }
    return null;
}
</code></pre>
<p>实现里面，只有红黑树的部分很难看懂（我也没有分析。）<br>还有就是 HashMap 空间浪费严重，可以看懂，当 cap 为 16 的时候 threshold = cap * loadFactor(默认 0.75)<br>当 size &gt; threshold 的时候就要双倍扩容。。  </p>
<h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><p>这个就不贴代码了，简单说一个下，很少用。<br>基本所有方法都有 synchronized 方法，所以线程安全（基本不用它），hash 方法跟 HashMap 不同，<br>扩容是双倍 + 1 扩容，并没有限定为2的指数，不能接受 key，value 为null    </p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>参考 <a href="https://blog.csdn.net/u012403290" target="_blank" rel="noopener">brickworkers的博客</a><br>利用 CAS 和 锁数组里头结点来提高并发性能<br>重点还是看看 put，get 和 扩容操作   </p>
<p>再看代码之前，先简单说一下PUT的具体操作： </p>
<ol>
<li>先传入一个k和v的键值对，不可为空（HashMap是可以为空的），如果为空就直接报错。 </li>
<li>接着去判断table是否为空，如果为空就进入初始化阶段。 </li>
<li>如果判断数组中某个指定的桶是空的，那就直接把键值对插入到这个桶中作为头节点，而且这个操作不用加锁。 </li>
<li>如果这个要插入的桶中的hash值为-1，也就是MOVED状态（也就是这个节点是forwordingNode），那就是说明有线程正在进行扩容操作，那么当前线程就进入协助扩容阶段。 </li>
<li>需要把数据插入到链表或者树中，如果这个节点是一个链表节点，那么就遍历这个链表，如果发现有相同的key值就更新value值，如果遍历完了都没有发现相同的key值，就需要在链表的尾部插入该数据。<br>插入结束之后判断该链表节点个数是否大于8，如果大于就需要把链表转化为红黑树存储。 </li>
<li>⑥如果这个节点是一个红黑树节点，那就需要按照树的插入规则进行插入。 </li>
<li>put结束之后，需要给map已存储的数量+1，在addCount方法中判断是否需要扩容   </li>
</ol>
<p>putVal 方法如下</p>
<pre><code class="lang-java">final V putVal(K key, V value, boolean onlyIfAbsent) {
    // key 和 value 不能为 null
    if (key == null || value == null) throw new NullPointerException();
    // hash spread 方法将hash再处理了一下，减少碰撞
    int hash = spread(key.hashCode());
    int binCount = 0;
    // 循环保证完成操作，完成后跳出去
    for (Node&lt;K,V&gt;[] tab = table;;) {
        Node&lt;K,V&gt; f; int n, i, fh;
        // 初始化table，也就是数组
        if (tab == null || (n = tab.length) == 0)
            tab = initTable();
        // 如果 index 上没有节点，这里的 tabAt 方法使用 Unsafe 里面的方法 getObjectVolatile 根据地址偏移取对象
        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
            // cas 设置新节点，如果设置成功，那就结束了
            if (casTabAt(tab, i, null,
                            new Node&lt;K,V&gt;(hash, key, value, null)))
                break;                   // no lock when adding to empty bin
        }
        //如果在插入的时候，节点是一个forwordingNode状态，表示正在扩容，那么当前线程进行帮助扩容
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        else {
            // 
            V oldVal = null;
            // 锁数组里面的单个元素
            synchronized (f) {
                // 再次确认一下，数组对应位置的节点变了没
                if (tabAt(tab, i) == f) {
                    // fh 是 f.hash
                    if (fh &gt;= 0) {
                        // 链表长度
                        binCount = 1;
                        for (Node&lt;K,V&gt; e = f;; ++binCount) {
                            K ek;
                            // 逻辑跟 HashMap 一样，如果存在相同的key，那就覆盖
                            if (e.hash == hash &amp;&amp;
                                ((ek = e.key) == key ||
                                    (ek != null &amp;&amp; key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            // 没有的话，就在链表后面添加
                            Node&lt;K,V&gt; pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node&lt;K,V&gt;(hash, key,
                                                            value, null);
                                break;
                            }
                        }
                    }
                    // 红黑树节点
                    else if (f instanceof TreeBin) {
                        Node&lt;K,V&gt; p;
                        binCount = 2;
                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                        value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }
            // 深度不为0
            if (binCount != 0) {
                // 深度超过要变化为 红黑树则变化
                if (binCount &gt;= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                // 返回旧值
                if (oldVal != null)
                    return oldVal;
                // 没有旧值，代表添加了新节点，需要在外面设置一下
                break;
            }
        }
    }
    //map已存储的数量+1,里面存在扩容
    addCount(1L, binCount);
    return null;
}
</code></pre>
<p>代码上面已经有注释了，里面需要注意的方法是 addCount 和 helpTransfer 方法，这里跟扩容有关    </p>
<pre><code class="lang-java">private final void addCount(long x, int check) {
    CounterCell[] as; long b, s;
    /**
        一般 counterCells 是空的，所以总是执行 后面的cas 操作，如果是true 就直接返回了
        如果是并发插入，其中一个线程cas 操作失败返回false ,则触发counterCells 的操作。
        这里的设计理念我的理解是分两级(毕竟并发的风险不高)的进行计算，保证效率，防止自旋 , 所以进入 fullAddCount() 里面是自旋的
        */
    if ((as = counterCells) != null ||
        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
        CounterCell a; long v; int m;
        boolean uncontended = true;
        // 当 as 为null 长度 &lt; 0 获取随机获取一个位置为null，不为null，cas 增加操作失败，任意一个条件满足 调用，fullAddCount
        if (as == null || (m = as.length - 1) &lt; 0 ||
            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||
            !(uncontended =
                U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {
            // 这个方法就是在并发添加的时候，里面自旋保证增加成功
            fullAddCount(x, uncontended);
            return;
        }
        if (check &lt;= 1)
            return;
        s = sumCount();
    }
    // 当check &gt;= 0 的时候，就是需要检查 size 并扩容
    if (check &gt;= 0) {
        Node&lt;K,V&gt;[] tab, nt; int n, sc;
        // sizeCtl 就是要扩容的阀值，默认是数组长度的 0.75
        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;
                (n = tab.length) &lt; MAXIMUM_CAPACITY) {

            int rs = resizeStamp(n);
            /**
                当 sizeCtl 小于 0 进入扩容状态后，其他线程只需要拿到 nextTable 进入transfer() 方法 ，就可以触发并发扩容
                */
            if (sc &lt; 0) {
                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                    transferIndex &lt;= 0)
                    break;
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                    /**
                        已经处于扩容状态下，直接传入 nextTable 进行触发 并发扩容 操作
                        */
                    transfer(tab, nt);
            }
            // 这里设置 sizeCtl 为负数了
            else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))
                // 设置成功，开始扩容
                transfer(tab, null);
            // sumCount 方法就是 遍历 counterCells 把value值相加,再加上baseCount  ，计算得long 值转成int 型输出
            s = sumCount();
        }
    }
}
</code></pre>
<p>addCount 不使用锁，cas 尝试添加，如果失败了，在 CounterCell 里面添加，循环加 cas 成功，count 就是 baseCount 加上 CounterCell 里面的和   </p>
<p>扩容方法 transfer 和 helpTransfer   </p>
<pre><code class="lang-java">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) {
    Node&lt;K,V&gt;[] nextTab; int sc;
    // 如果 table 不是空 且 node 节点是转移类型，数据检验
    // 且 node 节点的 nextTable（新 table） 不是空，同样也是数据校验
    // 尝试帮助扩容
    if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;
        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) {
        int rs = resizeStamp(tab.length);
        // 如果 nextTab 没有被并发修改 且 tab 也没有被并发修改
        // 且 sizeCtl  &lt; 0 （说明还在扩容）
        while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;
                (sc = sizeCtl) &lt; 0) {
        // 如果 sizeCtl 无符号右移  16 不等于 rs （ sc前 16 位如果不等于标识符，则标识符变化了）
        // 或者 sizeCtl == rs + 1  （扩容结束了，不再有线程进行扩容）（默认第一个线程设置 sc ==rs 左移 16 位 + 2，当第一个线程结束扩容了，就会将 sc 减一。这个时候，sc 就等于 rs + 1）
        // 或者 sizeCtl == rs + 65535  （如果达到最大帮助线程的数量，即 65535）
        // 或者转移下标正在调整 （扩容结束）
        // 结束循环，返回 table
            if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)
                break;
            // 如果以上都不是, 将 sizeCtl + 1, （表示增加了一个线程帮助其扩容）
            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) {
                // 进行转移
                transfer(tab, nextTab);
                // 结束循环
                break;
            }
        }
        return nextTab;
    }
    return table;
}
</code></pre>
<p>扩容的过程：首先有且只能由一个线程构建一个nextTable，这个nextTable主要是扩容后的数组（容量已经扩大），然后把原table复制到nextTable中，这个过程可以多线程共同操作。但是一定要清楚，这个复制并不是简单的把原table的数据直接移动到nextTable中，而是需要有一定的规律和算法操控的（不然怎么把树转化为链表呢）。</p>
<p>简单说下复制的过程：<br>数组中（桶中）总共分为3种存储情况：空，链表头，TreeBin头 </p>
<ol>
<li>遍历原来的数组（原table），如果数组中某个值为空，则直接放置一个forwordingNode（上篇博文介绍过）。 </li>
<li>如果数组中某个值不为空，而是一个链表头结点，那么就对这个链表进行拆分为两个链表，存储到nextTable对应的两个位置。 </li>
<li>如果数组中某个值不为空，而是一个TreeBin头结点，那么这个地方就存储的是红黑树的结构，这样一来，处理就会变得相对比较复杂，就需要先判断需不需要把树转换为链表，做完一系列的处理，然后把对应的结果存储在nextTable的对应两个位置。 </li>
</ol>
<pre><code class="lang-java">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) {
    int n = tab.length, stride;
    //主要是判断CPU处理的量，如果小于16则直接赋值16
    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)
        stride = MIN_TRANSFER_STRIDE; // subdivide range
    // initiating只能有一个线程进行构造nextTable，如果别的线程进入发现不为空就不用构造nextTable了
    if (nextTab == null) {            // initiating
        try {
            // 初始化新table ，原来的两倍

            @SuppressWarnings(&quot;unchecked&quot;)
            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];
            nextTab = nt;
        } catch (Throwable ex) {      // try to cope with OOME
            sizeCtl = Integer.MAX_VALUE;
            return;
        }
        nextTable = nextTab;
        transferIndex = n; //原先扩容大小
    }
    int nextn = nextTab.length;
    //构造一个ForwardingNode用于多线程之间的共同扩容情况
    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);
    boolean advance = true;//遍历的确认标志,这个标志是每个槽是否处理完毕的标记
    boolean finishing = false; // to ensure sweep before committing nextTab
    //遍历每个节点
    for (int i = 0, bound = 0;;) {
        //定义一个节点和一个节点状态判断标志fh
        Node&lt;K,V&gt; f; int fh;
        // 这个循环，是用来找本线程要处理哪一个槽（index）变量 i
        while (advance) {
            int nextIndex, nextBound;
            if (--i &gt;= bound || finishing)
                advance = false;
            else if ((nextIndex = transferIndex) &lt;= 0) {
                i = -1;
                advance = false;
            }
            //下面就是一个CAS计算
            else if (U.compareAndSwapInt
                        (this, TRANSFERINDEX, nextIndex,
                        nextBound = (nextIndex &gt; stride ?
                                    nextIndex - stride : 0))) {
                bound = nextBound;
                i = nextIndex - 1;
                advance = false;
            }
        }
        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) {
            int sc;
            //如果原table已经复制结束
            if (finishing) {
                //可以看出在扩容的时候nextTable只是类似于一个temp用完会丢掉
                nextTable = null;
                table = nextTab;
                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);//修改扩容后的阀值，应该是现在容量的0.75倍
                return;//结束循环
            }
            //采用CAS算法更新SizeCtl。
            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {
                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)
                    return;
                finishing = advance = true;
                i = n; // recheck before commit
            }
        }
        //CAS算法获取某一个数组的节点，为空就设为forwordingNode
        else if ((f = tabAt(tab, i)) == null)
            advance = casTabAt(tab, i, null, fwd);
        //如果这个节点的hash值是MOVED，就表示这个节点是forwordingNode节点，就表示这个节点已经被处理过了，直接跳过
        else if ((fh = f.hash) == MOVED)
            advance = true; // already processed
        else {
            //对头节点进行加锁，禁止别的线程进入
            synchronized (f) {
                //CAS校验这个节点是否在table对应的i处
                if (tabAt(tab, i) == f) {
                    Node&lt;K,V&gt; ln, hn;
                    //如果这个节点的确是链表节点
                    //把链表拆分成两个小列表并存储到nextTable对应的两个位置
                    if (fh &gt;= 0) {
                        // fh &amp; n 结果 为 0 或者 n （n 就是数组大小，是2 的指数倍，所以只有一位为1，其他为0）
                        int runBit = fh &amp; n;
                        Node&lt;K,V&gt; lastRun = f;
                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) {
                            int b = p.hash &amp; n;
                            if (b != runBit) {
                                runBit = b;
                                lastRun = p;
                            }
                        }
                        if (runBit == 0) {
                            ln = lastRun;
                            hn = null;
                        }
                        else {
                            hn = lastRun;
                            ln = null;
                        }
                        // 这里 Node 最后一个参数是 next，循环只到 lastRun，确保的是 lastRun 后面跟之前的顺序是一样的，前面都是倒叙
                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) {
                            int ph = p.hash; K pk = p.key; V pv = p.val;
                            if ((ph &amp; n) == 0)
                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);
                            else
                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);
                        }
                        //CAS存储在nextTable的i位置上
                        setTabAt(nextTab, i, ln);
                        //CAS存储在nextTable的i+n位置上
                        setTabAt(nextTab, i + n, hn);
                        //CAS在原table的i处设置forwordingNode节点，表示这个这个节点已经处理完毕
                        setTabAt(tab, i, fwd);
                        advance = true;
                    }
                    //如果这个节点是红黑树
                    else if (f instanceof TreeBin) {
                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;
                        TreeNode&lt;K,V&gt; lo = null, loTail = null;
                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;
                        int lc = 0, hc = 0;
                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) {
                            int h = e.hash;
                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;
                                (h, e.key, e.val, null, null);
                            if ((h &amp; n) == 0) {
                                if ((p.prev = loTail) == null)
                                    lo = p;
                                else
                                    loTail.next = p;
                                loTail = p;
                                ++lc;
                            }
                            else {
                                if ((p.prev = hiTail) == null)
                                    hi = p;
                                else
                                    hiTail.next = p;
                                hiTail = p;
                                ++hc;
                            }
                        }
                        //如果拆分后的树的节点数量已经少于6个就需要重新转化为链表
                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :
                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;
                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :
                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;
                        setTabAt(nextTab, i, ln);
                        setTabAt(nextTab, i + n, hn);
                        setTabAt(tab, i, fwd);
                        advance = true;
                    }
                }
            }
        }
    }
}
</code></pre>
<p>上面，链表拆分，写了个测试代码<br>可以将 n 设置为 8 和 16 看看</p>
<pre><code class="lang-java">public class NodeStudy {

    static class Node {
        private int hash;
        private int value;
        private Node next;

        public Node(int hash, int value, Node next) {
            this.hash = hash;
            this.value = value;
            this.next = next;
        }

        public int getHash() {
            return hash;
        }

        public int getValue() {
            return value;
        }

        public Node getNext() {
            return next;
        }
    }

    public static void main(String[] args) {
        int n = 16;
        Node head = null, c = null;
        for (int i = 0; i &lt; 30; i++) {
            Node node = new Node(i, i, null);
            if (Objects.isNull(c)) {
                c = head = node;
            } else {
                c.next = node;
                c = node;
            }
        }
        // 长度为 30 的单向链表
//        for (Node p = head; p != null; p = p.next) {
//            System.out.println(p.hash);
//        }

        int fh = head.hash;
        int runBit = head.hash &amp; n;
        Node ln, hn;
        Node lastRun = null;
        for (Node p = head.next; p != null; p = p.next) {
            int b = p.hash &amp; n;
            if (b != runBit) {
                runBit = b;
                lastRun = p;
            }
        }
        System.out.println(&quot;lastRun&quot;);
        System.out.println(lastRun.hash);
        if (runBit == 0) {
            ln = lastRun;
            hn = null;
        }
        else {
            hn = lastRun;
            ln = null;
        }

        for (Node p = head; p != lastRun; p = p.next) {
            int ph = p.hash;
            if ((ph &amp; n) == 0)
                ln = new Node(ph, p.value, ln);
            else
                hn = new Node(ph, p.value, hn);
        }

        System.out.println(&quot;======ln========&quot;);

        for (Node p = ln; p != null; p = p.next) {
            System.out.println(p.hash);
        }
        System.out.println(&quot;======hn========&quot;);
        for (Node p = hn; p != null; p = p.next) {
            System.out.println(p.hash);
        }
    }
}
</code></pre>
<p>get 方法就很简单了  </p>
<pre><code class="lang-java">public V get(Object key) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;
    int h = spread(key.hashCode());
    //数组已被初始化且指定桶中不为空
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (e = tabAt(tab, (n - 1) &amp; h)) != null) {
            //先判断头节点，如果头节点的hash值与入参key的hash值相同
        if ((eh = e.hash) == h) {
            //头节点的key就是传入的key
            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))
                return e.val;
        }
        //eh&lt;0表示这个节点是红黑树
        else if (eh &lt; 0)
            return (p = e.find(h, key)) != null ? p.val : null;//直接从树上进行查找返回结果，不存在就返回null
        //如果首节点不是查找对象且不是红黑树结构，那边就遍历这个列表
        while ((e = e.next) != null) {
            if (e.hash == h &amp;&amp;
                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))
                return e.val;
        }
    }
    //都没有找到就直接返回null值
    return null;
}
</code></pre>
<p>删除和替换操作基于以下方法  </p>
<pre><code class="lang-java">final V replaceNode(Object key, V value, Object cv) {
    int hash = spread(key.hashCode());
    // 循环 加 cas 保证成功
    for (Node&lt;K,V&gt;[] tab = table;;) {
        Node&lt;K,V&gt; f; int n, i, fh;
        // 没初始化，对应位置上没有节点，给定的key不存在
        if (tab == null || (n = tab.length) == 0 ||
            (f = tabAt(tab, i = (n - 1) &amp; hash)) == null)
            break;
        // 如果 位置的头结点 hash == MOVED，代表真正扩容，本线程也去辅助扩容 
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        else {
            // 否则，就正常读取
            V oldVal = null;
            boolean validated = false;
            // 锁住头结点
            synchronized (f) {
                // double check 判断锁住的节点没被替换
                if (tabAt(tab, i) == f) {
                    // 链表结构
                    if (fh &gt;= 0) {
                        validated = true;
                        for (Node&lt;K,V&gt; e = f, pred = null;;) {
                            K ek;
                            // 找到对应的 key了
                            if (e.hash == hash &amp;&amp;
                                ((ek = e.key) == key ||
                                    (ek != null &amp;&amp; key.equals(ek)))) {

                                V ev = e.val;
                                // 如果预期的 value 为null 或者 对应的value 就是预期的 value
                                if (cv == null || cv == ev ||
                                    (ev != null &amp;&amp; cv.equals(ev))) {
                                    // 获得旧值
                                    oldVal = ev;
                                    // 如果要替换的 value 不为null，如果为null，就是要删除
                                    if (value != null)
                                        e.val = value;
                                    else if (pred != null)
                                        pred.next = e.next;
                                    else
                                        setTabAt(tab, i, e.next);
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null)
                                break;
                        }
                    }
                    // 红黑树节点
                    else if (f instanceof TreeBin) {
                        validated = true;
                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;
                        TreeNode&lt;K,V&gt; r, p;
                        if ((r = t.root) != null &amp;&amp;
                            (p = r.findTreeNode(hash, key, null)) != null) {
                            V pv = p.val;
                            if (cv == null || cv == pv ||
                                (pv != null &amp;&amp; cv.equals(pv))) {
                                oldVal = pv;
                                if (value != null)
                                    p.val = value;
                                else if (t.removeTreeNode(p))
                                    setTabAt(tab, i, untreeify(t.first));
                            }
                        }
                    }
                }
            }
            // 如果是删除，数量 -1
            if (validated) {
                if (oldVal != null) {
                    if (value == null)
                        addCount(-1L, -1);
                    return oldVal;
                }
                break;
            }
        }
    }
    return null;
}
</code></pre>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>基于红黑树的map，key 有序   </p>
<h3 id="红黑树概述"><a href="#红黑树概述" class="headerlink" title="红黑树概述"></a>红黑树概述</h3><p>红黑树（Red Black Tree） 是一种自平衡二叉查找树<br>参考 <a href="http://www.cnblogs.com/skywang12345/p/3245399.html" target="_blank" rel="noopener">红黑树(一)之 原理和算法详细介绍</a><br>红黑树的特性:</p>
<ol>
<li>每个节点或者是黑色，或者是红色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</li>
<li>如果一个节点是红色的，则它的子节点必须是黑色的。</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。   </li>
</ol>
<p><strong>左旋，右旋</strong><br>左旋中的“左”，意味着“被旋转的节点将变成一个左节点”<br>右旋中的“右”，意味着“被旋转的节点将变成一个右节点”  </p>
<p><strong>添加</strong>    </p>
<ol>
<li>将红黑树当作一颗二叉查找树，将节点插入。<br>红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实<br>那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树</li>
<li><p>将插入的节点着色为”红色”<br>为什么着色成红色，而不是黑色呢？<br>将插入的节点着色为红色，不会违背”特性(5)”！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了</p>
</li>
<li><p>通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。<br>第二步中，将插入节点着色为”红色”之后，不会违背”特性(5)”。那它到底会违背哪些特性呢？<br>对于”特性(1)”，显然不会违背了。因为我们已经将它涂成红色了。<br>对于”特性(2)”，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。<br>对于”特性(3)”，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。<br>对于”特性(4)”，是有可能违背的！<br>那接下来，想办法使之”满足特性(4)”，就可以将树重新构造成红黑树了。</p>
</li>
</ol>
<p>添加的伪码  </p>
<pre><code class="lang-c">RB-INSERT(T, z)  
 y ← nil[T]                        // 新建节点“y”，将y设为空节点。
 x ← root[T]                       // 设“红黑树T”的根节点为“x”
 while x ≠ nil[T]                  // 找出要插入的节点“z”在二叉树T中的位置“y”
     do y ← x                      
        if key[z] &lt; key[x]  
           then x ← left[x]  
           else x ← right[x]  
 p[z] ← y                          // 设置 “z的父亲” 为 “y”
 if y = nil[T]                     
    then root[T] ← z               // 情况1：若y是空节点，则将z设为根
    else if key[z] &lt; key[y]        
            then left[y] ← z       // 情况2：若“z所包含的值” &lt; “y所包含的值”，则将z设为“y的左孩子”
            else right[y] ← z      // 情况3：(“z所包含的值” &gt;= “y所包含的值”)将z设为“y的右孩子” 
 left[z] ← nil[T]                  // z的左孩子设为空
 right[z] ← nil[T]                 // z的右孩子设为空。至此，已经完成将“节点z插入到二叉树”中了。
 color[z] ← RED                    // 将z着色为“红色”
 RB-INSERT-FIXUP(T, z)             // 通过RB-INSERT-FIXUP对红黑树的节点进行颜色修改以及旋转，让树T仍然是一颗红黑树

 RB-INSERT-FIXUP(T, z)
while color[p[z]] = RED                                                  // 若“当前节点(z)的父节点是红色”，则进行以下处理。
    do if p[z] = left[p[p[z]]]                                           // 若“z的父节点”是“z的祖父节点的左孩子”，则进行以下处理。
          then y ← right[p[p[z]]]                                        // 将y设置为“z的叔叔节点(z的祖父节点的右孩子)”
               if color[y] = RED                                         // Case 1条件：叔叔是红色
                  then color[p[z]] ← BLACK                    ▹ Case 1   //  (01) 将“父节点”设为黑色。
                       color[y] ← BLACK                       ▹ Case 1   //  (02) 将“叔叔节点”设为黑色。
                       color[p[p[z]]] ← RED                   ▹ Case 1   //  (03) 将“祖父节点”设为“红色”。
                       z ← p[p[z]]                            ▹ Case 1   //  (04) 将“祖父节点”设为“当前节点”(红色节点)
                  else if z = right[p[z]]                                // Case 2条件：叔叔是黑色，且当前节点是右孩子
                          then z ← p[z]                       ▹ Case 2   //  (01) 将“父节点”作为“新的当前节点”。
                               LEFT-ROTATE(T, z)              ▹ Case 2   //  (02) 以“新的当前节点”为支点进行左旋。
                          color[p[z]] ← BLACK                 ▹ Case 3   // Case 3条件：叔叔是黑色，且当前节点是左孩子。(01) 将“父节点”设为“黑色”。
                          color[p[p[z]]] ← RED                ▹ Case 3   //  (02) 将“祖父节点”设为“红色”。
                          RIGHT-ROTATE(T, p[p[z]])            ▹ Case 3   //  (03) 以“祖父节点”为支点进行右旋。
       else (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged)      // 若“z的父节点”是“z的祖父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。
color[root[T]] ← BLACK
</code></pre>
<p><strong>删除</strong><br>将红黑树内的某一个节点删除。需要执行的操作依次是：首先，将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；然后，通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。详细描述如下：</p>
<ol>
<li><p>将红黑树当作一颗二叉查找树，将节点删除。<br>这和”删除常规二叉查找树中删除节点的方法是一样的”。分3种情况：</p>
<ol>
<li>被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。</li>
<li>被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。</li>
<li>被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给”被删除节点”之后，再将后继节点删除。这样就巧妙的将问题转换为”删除后继节点”的情况了，下面就考虑后继节点。 在”被删除节点”有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然”的后继节点”不可能双子都非空，就意味着”该节点的后继节点”要么没有儿子，要么只有一个儿子。若没有儿子，则按”情况1 “进行处理；若只有一个儿子，则按”情况2 “进行处理。</li>
</ol>
</li>
<li><p>通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。<br>因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。</p>
</li>
</ol>
<pre><code class="lang-c">RB-DELETE(T, z)
if left[z] = nil[T] or right[z] = nil[T]         
   then y ← z                                  // 若“z的左孩子” 或 “z的右孩子”为空，则将“z”赋值给 “y”；
   else y ← TREE-SUCCESSOR(z)                  // 否则，将“z的后继节点”赋值给 “y”。
if left[y] ≠ nil[T]
   then x ← left[y]                            // 若“y的左孩子” 不为空，则将“y的左孩子” 赋值给 “x”；
   else x ← right[y]                           // 否则，“y的右孩子” 赋值给 “x”。
p[x] ← p[y]                                    // 将“y的父节点” 设置为 “x的父节点”
if p[y] = nil[T]                               
   then root[T] ← x                            // 情况1：若“y的父节点” 为空，则设置“x” 为 “根节点”。
   else if y = left[p[y]]                    
           then left[p[y]] ← x                 // 情况2：若“y是它父节点的左孩子”，则设置“x” 为 “y的父节点的左孩子”
           else right[p[y]] ← x                // 情况3：若“y是它父节点的右孩子”，则设置“x” 为 “y的父节点的右孩子”
if y ≠ z                                    
   then key[z] ← key[y]                        // 若“y的值” 赋值给 “z”。注意：这里只拷贝z的值给y，而没有拷贝z的颜色！！！
        copy y&#39;s satellite data into z         
if color[y] = BLACK                            
   then RB-DELETE-FIXUP(T, x)                  // 若“y为黑节点”，则调用
return y

RB-DELETE-FIXUP(T, x)
while x ≠ root[T] and color[x] = BLACK  
    do if x = left[p[x]]      
          then w ← right[p[x]]                                             // 若 “x”是“它父节点的左孩子”，则设置 “w”为“x的叔叔”(即x为它父节点的右孩子)                                          
               if color[w] = RED                                           // Case 1: x是“黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。
                  then color[w] ← BLACK                        ▹  Case 1   //   (01) 将x的兄弟节点设为“黑色”。
                       color[p[x]] ← RED                       ▹  Case 1   //   (02) 将x的父节点设为“红色”。
                       LEFT-ROTATE(T, p[x])                    ▹  Case 1   //   (03) 对x的父节点进行左旋。
                       w ← right[p[x]]                         ▹  Case 1   //   (04) 左旋后，重新设置x的兄弟节点。
               if color[left[w]] = BLACK and color[right[w]] = BLACK       // Case 2: x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。
                  then color[w] ← RED                          ▹  Case 2   //   (01) 将x的兄弟节点设为“红色”。
                       x ←  p[x]                               ▹  Case 2   //   (02) 设置“x的父节点”为“新的x节点”。
                  else if color[right[w]] = BLACK                          // Case 3: x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。
                          then color[left[w]] ← BLACK          ▹  Case 3   //   (01) 将x兄弟节点的左孩子设为“黑色”。
                               color[w] ← RED                  ▹  Case 3   //   (02) 将x兄弟节点设为“红色”。
                               RIGHT-ROTATE(T, w)              ▹  Case 3   //   (03) 对x的兄弟节点进行右旋。
                               w ← right[p[x]]                 ▹  Case 3   //   (04) 右旋后，重新设置x的兄弟节点。
                        color[w] ← color[p[x]]                 ▹  Case 4   // Case 4: x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的。(01) 将x父节点颜色 赋值给 x的兄弟节点。
                        color[p[x]] ← BLACK                    ▹  Case 4   //   (02) 将x父节点设为“黑色”。
                        color[right[w]] ← BLACK                ▹  Case 4   //   (03) 将x兄弟节点的右子节设为“黑色”。
                        LEFT-ROTATE(T, p[x])                   ▹  Case 4   //   (04) 对x的父节点进行左旋。
                        x ← root[T]                            ▹  Case 4   //   (05) 设置“x”为“根节点”。
       else (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged)        // 若 “x”是“它父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。
color[x] ← BLACK
</code></pre>
<p>TreeMap 完全基于红黑树结构，重要的只有 插入 和 删除（包含修正），没有扩容概念，get 也是 红黑树查找，Ologn。<br>其实代码不重要，重要是理解红黑树（挺难理解的），反正知道就行了。    </p>
<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><p>这个实现跟 HashMap 差不多，不过key使用了弱引用，当内存不足的时候，会被回收（回收时间不确定），可以通过一个queue，来搜集被回收的key<br>重点代码    </p>
<pre><code class="lang-java">private static class Entry&lt;K,V&gt; extends WeakReference&lt;Object&gt; implements Map.Entry&lt;K,V&gt; {
    V value;
    final int hash;
    Entry&lt;K,V&gt; next;

    /**
        * Creates new entry.
        */
    Entry(Object key, V value,
            ReferenceQueue&lt;Object&gt; queue,
            int hash, Entry&lt;K,V&gt; next) {
        super(key, queue);
        this.value = value;
        this.hash  = hash;
        this.next  = next;
    }
</code></pre>
<p>复制了一部分，看到 Entry 继承了 WeakReference，构造的时候传了key 和 queue   </p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>源码</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>Queue 源码阅读</title>
    <url>/2019/07/25/Queue-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<p>Queue 继承体系下，常用实现的分析<br>Queue 接口下面，还有 Deque 和 BlockingQueue 和 BlockingDeque    </p>
<p>我们先弄清楚队列的方法的含义<br>就说功能，方法太多，用的时候看说明就行了    </p>
<ol>
<li>从头获取并删除元素（如果为空抛异常）</li>
<li>从头获取并删除元素（如果为空返回null）</li>
<li>从头获取元素（如果为空抛异常）</li>
<li>从头获取元素（如果为空返回null）</li>
<li>从头添加元素（如果满了抛异常）</li>
<li>从头添加元素（如果满了返回false）    </li>
</ol>
<p>尾的操作跟上面类似。就不说了，具体用的时候看 api 的说明，完全记不住。</p>
<h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p>这个下面的实现类有 LinkedList ArrayDeque ConcurrentLinkedDeque<br>其中 LinkedList 就不说了，我们看看其他两个  </p>
<h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p>看名字就知道，这是一个基于数组的双向队列实现<br>ArrayDeque 的初始化容量一定是 2 的指数  </p>
<pre><code class="lang-java">public ArrayDeque(int numElements) {
    allocateElements(numElements);
}
private void allocateElements(int numElements) {
    int initialCapacity = MIN_INITIAL_CAPACITY;
    // Find the best power of two to hold elements.
    // Tests &quot;&lt;=&quot; because arrays aren&#39;t kept full.
    if (numElements &gt;= initialCapacity) {
        initialCapacity = numElements;
        initialCapacity |= (initialCapacity &gt;&gt;&gt;  1);
        initialCapacity |= (initialCapacity &gt;&gt;&gt;  2);
        initialCapacity |= (initialCapacity &gt;&gt;&gt;  4);
        initialCapacity |= (initialCapacity &gt;&gt;&gt;  8);
        initialCapacity |= (initialCapacity &gt;&gt;&gt; 16);
        initialCapacity++;

        if (initialCapacity &lt; 0)   // Too many elements, must back off
            initialCapacity &gt;&gt;&gt;= 1;// Good luck allocating 2 ^ 30 elements
    }
    elements = new Object[initialCapacity];
}
</code></pre>
<p>ArrayDeque 使用数组存储，但是，并不是 index = 0 的元素是头元素，如果这样设计，那么从队首插入的效率就非常低了（复制）<br>使用    </p>
<pre><code class="lang-java">transient int head;

transient int tail;
</code></pre>
<p>这个标记，来记录队首和队尾的下标    </p>
<p>根据注释上面说的，本类作为 栈，比 <code>Stack</code> 要快（队尾添加，队尾获取，这样使用就是栈了）<br>作为 队列，比 <code>LinkedList</code> 要快</p>
<p>ArrayDeque，每次扩容的时候都是双倍扩容    </p>
<pre><code class="lang-java">private void doubleCapacity() {
    assert head == tail;
    int p = head;
    int n = elements.length;
    int r = n - p; // number of elements to the right of p
    int newCapacity = n &lt;&lt; 1;
    if (newCapacity &lt; 0)
        throw new IllegalStateException(&quot;Sorry, deque too big&quot;);
    Object[] a = new Object[newCapacity];
    System.arraycopy(elements, p, a, 0, r);
    System.arraycopy(elements, 0, a, r, p);
    elements = a;
    head = 0;
    tail = n;
}
</code></pre>
<p>经过扩容后，head 将置为 0<br>我们先看一下 addFirst   </p>
<pre><code class="lang-java">public void addFirst(E e) {
    if (e == null)
        throw new NullPointerException();
    elements[head = (head - 1) &amp; (elements.length - 1)] = e;
    if (head == tail)
        doubleCapacity();
}
</code></pre>
<p>赋值语句比较复杂，我们拆开看<br>由于初始容量为2 的指数，每次扩容都是2倍扩容，所以 <code>(elements.length - 1)</code> 的结果就是低位全1<br>因为在队首插入，因此 <code>(head - 1)</code>,head 的新值是两个值 <code>&amp;</code> ，其实就是取余。<br>我们看一下，第一个调用 addFirst，那么 head 为 15 （默认容量为16），<br>如果 head == tail 了，那么代表数组满了，需要扩容了<br>反正注意从队首添加就是 head - 1 取余，从队首删除就是 head + 1 取余  </p>
<p>从队首获取的方法    </p>
<pre><code class="lang-java">public E pollFirst() {
    int h = head;
    @SuppressWarnings(&quot;unchecked&quot;)
    E result = (E) elements[h];
    // Element is null if deque empty
    if (result == null)
        return null;
    elements[h] = null;     // Must null out slot
    head = (h + 1) &amp; (elements.length - 1);
    return result;
}
</code></pre>
<p>这里结果为null，不抛异常，其他要抛异常的方法也是调用这个方法    </p>
<p>队尾的操作类似  </p>
<pre><code class="lang-java">public void addLast(E e) {
    if (e == null)
        throw new NullPointerException();
    elements[tail] = e;
    if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)
        doubleCapacity();
}
</code></pre>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>基于数组的阻塞队列，内部使用重入锁和两个条件实现阻塞<br>实现并不复杂，看一下代表性的方法 offer poll</p>
<pre><code class="lang-java">
public boolean offer(E e) {
    // 元素不能为null
    checkNotNull(e);
    final ReentrantLock lock = this.lock;
    // 重入锁，所以阻塞队列是线程安全的
    lock.lock();
    try {
        // 队列已满
        if (count == items.length)
            return false;
        else {
            // 没满，就入队，肯定成功，因为上锁了
            enqueue(e);
            return true;
        }
    } finally {
        lock.unlock();
    }
}

/**
 * 调用这个方法前，先上锁
 */
private void enqueue(E x) {
    // assert lock.getHoldCount() == 1;
    // assert items[putIndex] == null;
    final Object[] items = this.items;
    // putIndex 记录最后入队索引
    items[putIndex] = x;
    if (++putIndex == items.length)
        putIndex = 0;
    count++;
    // 入队后，代表有数据了，通知 notEmpty 条件， 如果有在 notEmpty 上等待的，其实就是想要在非空的时候得到通知
    notEmpty.signal();
}
</code></pre>
<p>太简单了，没啥说的。    </p>
<pre><code class="lang-java">/**
    出队
*/   
public E poll() {
    final ReentrantLock lock = this.lock;
    // 同样要上锁
    lock.lock();
    try {
        // 为空就返回null，否则出队操作
        return (count == 0) ? null : dequeue();
    } finally {
        lock.unlock();
    }
}

private E dequeue() {
    // assert lock.getHoldCount() == 1;
    // assert items[takeIndex] != null;
    final Object[] items = this.items;
    // takeIndex 记录出队索引
    @SuppressWarnings(&quot;unchecked&quot;)
    E x = (E) items[takeIndex];
    items[takeIndex] = null;
    if (++takeIndex == items.length)
        takeIndex = 0;
    count--;
    if (itrs != null)
        itrs.elementDequeued();
    // 出队了，肯定有空位，通知 notFull 条件，如果有在 notFull 上等待的，其实就是想要在非满的时候得到通知
    notFull.signal();
    return x;
}
</code></pre>
<p>基于数组，重入锁，两个条件，putIndex 和 takeIndex。</p>
<h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><p>看名字就知道基于双向链表的阻塞队列<br>内部实现跟 LinkedList 差不多，就是多了重入锁，两个条件。。 </p>
<h3 id="ConcurrentLinkedDeque"><a href="#ConcurrentLinkedDeque" class="headerlink" title="ConcurrentLinkedDeque"></a>ConcurrentLinkedDeque</h3><p>这个看名字，就能猜到线程安全的，基于链表实现的双端队列<br>里面使用循环加上 cas 操作，无锁化编程   </p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>源码</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2019/07/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h2><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
<p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p>
<h2 id="设计模式的使用"><a href="#设计模式的使用" class="headerlink" title="设计模式的使用"></a>设计模式的使用</h2><p>设计模式在软件开发中的两个主要用途。</p>
<ol>
<li><p>开发人员的共同平台<br>设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。</p>
</li>
<li><p>最佳的实践<br>设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。</p>
</li>
</ol>
<h2 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h2><ol>
<li><p>创建型模式<br>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p>
<ul>
<li>工厂模式（Factory Pattern）</li>
<li>抽象工厂模式（Abstract Factory Pattern）</li>
<li>单例模式（Singleton Pattern）</li>
<li>建造者模式（Builder Pattern）</li>
<li>原型模式（Prototype Pattern）</li>
</ul>
</li>
<li><p>结构型模式<br>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p>
<ul>
<li>适配器模式（Adapter Pattern）</li>
<li>桥接模式（Bridge Pattern）</li>
<li>过滤器模式（Filter、Criteria Pattern）</li>
<li>组合模式（Composite Pattern）</li>
<li>装饰器模式（Decorator Pattern）</li>
<li>外观模式（Facade Pattern）</li>
<li>享元模式（Flyweight Pattern）</li>
<li>代理模式（Proxy Pattern）</li>
</ul>
</li>
<li><p>行为型模式<br>这些设计模式特别关注对象之间的通信。</p>
<ul>
<li>责任链模式（Chain of Responsibility Pattern）</li>
<li>命令模式（Command Pattern）</li>
<li>解释器模式（Interpreter Pattern）</li>
<li>迭代器模式（Iterator Pattern）</li>
<li>中介者模式（Mediator Pattern）</li>
<li>备忘录模式（Memento Pattern）</li>
<li>观察者模式（Observer Pattern）</li>
<li>状态模式（State Pattern）</li>
<li>空对象模式（Null Object Pattern）</li>
<li>策略模式（Strategy Pattern）</li>
<li>模板模式（Template Pattern）</li>
<li>访问者模式（Visitor Pattern）</li>
</ul>
</li>
</ol>
<h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><ol>
<li>开闭原则（Open Close Principle）</li>
</ol>
<p>开闭原则的意思是：<em>对扩展开放，对修改关闭</em>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<ol>
<li>里氏代换原则（Liskov Substitution Principle）</li>
</ol>
<p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<ol>
<li>依赖倒转原则（Dependence Inversion Principle）</li>
</ol>
<p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<ol>
<li>接口隔离原则（Interface Segregation Principle）</li>
</ol>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<ol>
<li>迪米特法则，又称最少知道原则（Demeter Principle）</li>
</ol>
<p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<ol>
<li>合成复用原则（Composite Reuse Principle）</li>
</ol>
<p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
<p>代码参考:<a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">java-design-patterns</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>List 源码阅读</title>
    <url>/2019/07/24/List-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>List 体系下的部分源码实现阅读分析   </p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList 在平时用的很多，是基于数组的。可随机访问。里面值得注意的地方扩容 </p>
<pre><code class="lang-java">private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }

    ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // overflow-conscious code
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
}

private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}

private static int hugeCapacity(int minCapacity) {
    if (minCapacity &lt; 0) // overflow
        throw new OutOfMemoryError();
    return (minCapacity &gt; MAX_ARRAY_SIZE) ?
        Integer.MAX_VALUE :
        MAX_ARRAY_SIZE;
}
</code></pre>
<p>数组扩容<br>从上面可以看到默认是 1.5 倍扩容 <code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code><br>如果指定的最小容量比 1.5 倍大，那就用指定的值。数组的容量上限是 <code>Integer.MAX_VALUE</code><br>可以看到，扩容后，将有一次复制操作 <code>Arrays.copyOf(elementData, newCapacity)</code><br>内部的实现是 <code>System.arrayCopy</code> 方法    </p>
<pre><code class="lang-java">public static native void arraycopy(Object src,  int  srcPos,
                                        Object dest, int destPos,
                                        int length);
</code></pre>
<p>这是一个 native 方法    </p>
<p>需要注意的是，在 List 中间插入或者删除一个元素操作，都会有一次复制操作    </p>
<pre><code class="lang-java">public void add(int index, E element) {
    rangeCheckForAdd(index);

    ensureCapacityInternal(size + 1);  // Increments modCount!!
    System.arraycopy(elementData, index, elementData, index + 1,
                        size - index);
    elementData[index] = element;
    size++;
}

public E remove(int index) {
    rangeCheck(index);

    modCount++;
    E oldValue = elementData(index);

    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index,
                            numMoved);
    elementData[--size] = null; // clear to let GC do its work

    return oldValue;
}
</code></pre>
<p>因此，ArrayList 的优缺点就很清楚了</p>
<p>另外 <code>ArrayList</code> 是非线程安全的  </p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>基本跟 ArrayList 一样，不同的是，几乎所有方法都用 <code>synchronized</code> 关键字了，所以是线程安全的。<br>虽说是线程安全的，但是如果要在多线程情况下使用的话，效率非常差，就是串行访问了。    </p>
<p>不同的增长方式，在 <code>Vecotr</code> 中，在构造的时候可以指定每次增长的长度，如果不指定，那就双倍（最小）    </p>
<pre><code class="lang-java">public Vector(int initialCapacity, int capacityIncrement) {
    super();
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                            initialCapacity);
    this.elementData = new Object[initialCapacity];
    this.capacityIncrement = capacityIncrement;
}

public synchronized void ensureCapacity(int minCapacity) {
    if (minCapacity &gt; 0) {
        modCount++;
        ensureCapacityHelper(minCapacity);
    }
}

private void ensureCapacityHelper(int minCapacity) {
    // overflow-conscious code
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
}

private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?
                                        capacityIncrement : oldCapacity);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
}
</code></pre>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>内部的实现是双向链表    </p>
<pre><code class="lang-java">private static class Node&lt;E&gt; {
    E item;
    Node&lt;E&gt; next;
    Node&lt;E&gt; prev;

    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
</code></pre>
<p>不止是 List 的实现，还是 Deque 的实现<br>由于内部是双向链表实现的 List，所以就不存在扩容了。<br>双向列表，向链表中插入，重点在于找到位置，这个操作最耗时，LinkedList 是不支持随机访问的。<br>看看重点方法就知道了<br>内部根据 index 找到节点的方式 node</p>
<pre><code class="lang-java">Node&lt;E&gt; node(int index) {
    // assert isElementIndex(index);

    if (index &lt; (size &gt;&gt; 1)) {
        Node&lt;E&gt; x = first;
        for (int i = 0; i &lt; index; i++)
            x = x.next;
        return x;
    } else {
        Node&lt;E&gt; x = last;
        for (int i = size - 1; i &gt; index; i--)
            x = x.prev;
        return x;
    }
}
</code></pre>
<p>这里做了一个简单的优化，根据 index 更靠近 first 还是 last 来决定从 first 开始遍历，还是从 last 遍历<br>然后插入，删除操作，就是先用这个方法定位，然后使用下面的方法来操作  </p>
<pre><code class="lang-java">private void linkFirst(E e) {
    final Node&lt;E&gt; f = first;
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);
    first = newNode;
    if (f == null)
        last = newNode;
    else
        f.prev = newNode;
    size++;
    modCount++;
}

void linkLast(E e) {
    final Node&lt;E&gt; l = last;
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
    last = newNode;
    if (l == null)
        first = newNode;
    else
        l.next = newNode;
    size++;
    modCount++;
}

void linkBefore(E e, Node&lt;E&gt; succ) {
    // assert succ != null;
    final Node&lt;E&gt; pred = succ.prev;
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);
    succ.prev = newNode;
    if (pred == null)
        first = newNode;
    else
        pred.next = newNode;
    size++;
    modCount++;
}
</code></pre>
<p>上面 3 个方法是添加操作 </p>
<pre><code class="lang-java">private E unlinkFirst(Node&lt;E&gt; f) {
    // assert f == first &amp;&amp; f != null;
    final E element = f.item;
    final Node&lt;E&gt; next = f.next;
    f.item = null;
    f.next = null; // help GC
    first = next;
    if (next == null)
        last = null;
    else
        next.prev = null;
    size--;
    modCount++;
    return element;
}

private E unlinkLast(Node&lt;E&gt; l) {
    // assert l == last &amp;&amp; l != null;
    final E element = l.item;
    final Node&lt;E&gt; prev = l.prev;
    l.item = null;
    l.prev = null; // help GC
    last = prev;
    if (prev == null)
        first = null;
    else
        prev.next = null;
    size--;
    modCount++;
    return element;
}

E unlink(Node&lt;E&gt; x) {
    // assert x != null;
    final E element = x.item;
    final Node&lt;E&gt; next = x.next;
    final Node&lt;E&gt; prev = x.prev;

    if (prev == null) {
        first = next;
    } else {
        prev.next = next;
        x.prev = null;
    }

    if (next == null) {
        last = prev;
    } else {
        next.prev = prev;
        x.next = null;
    }

    x.item = null;
    size--;
    modCount++;
    return element;
}
</code></pre>
<p>上面3个操作是删除操作。基本上所有的公开方法就是基于上面的方法的。譬如   </p>
<pre><code class="lang-java">public void add(int index, E element) {
    checkPositionIndex(index);

    if (index == size)
        linkLast(element);
    else
        linkBefore(element, node(index));
}

public E remove(int index) {
    checkElementIndex(index);
    return unlink(node(index));
}

public E get(int index) {
    checkElementIndex(index);
    return node(index).item;
}
</code></pre>
<p>还有一个需要注意的地方是 iterator 方法， LinkedList 重写了 ListIterator 的实现，内部除了记录 index，还记录 节点，这个，就不用每次都用 index 来找上下节点了<br>所以，一个代码的细节就是，如果使用了 LinkedList， 就不要使用 <code>for(int i = 0; i &lt; list.size; i++)</code> 这样的循环了，应该使用 foreach 循环 <code>for(item : list)</code> 或者使用 iterator<br>LinkedList 是非线程安全的   </p>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>这个也不复杂，在写（删）的时候，加锁复制，赋值。    </p>
<pre><code class="lang-java">public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}

public void add(int index, E element) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        if (index &gt; len || index &lt; 0)
            throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+
                                                &quot;, Size: &quot;+len);
        Object[] newElements;
        int numMoved = len - index;
        if (numMoved == 0)
            newElements = Arrays.copyOf(elements, len + 1);
        else {
            newElements = new Object[len + 1];
            System.arraycopy(elements, 0, newElements, 0, index);
            System.arraycopy(elements, index, newElements, index + 1,
                                numMoved);
        }
        newElements[index] = element;
        setArray(newElements);
    } finally {
        lock.unlock();
    }
}

public E remove(int index) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        E oldValue = get(elements, index);
        int numMoved = len - index - 1;
        if (numMoved == 0)
            setArray(Arrays.copyOf(elements, len - 1));
        else {
            Object[] newElements = new Object[len - 1];
            System.arraycopy(elements, 0, newElements, 0, index);
            System.arraycopy(elements, index + 1, newElements, index,
                                numMoved);
            setArray(newElements);
        }
        return oldValue;
    } finally {
        lock.unlock();
    }
}
</code></pre>
<p>这些都没啥好说的，可以看到内存占用挺大的，适合读多写少的时候。<br>读的时候不需要加锁，写的时候，总是复制，然后赋值。当内容过多的时候，可能造成内存溢出<br>读的时候，如果有其他线程在写，读可能读到旧值。  </p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>源码</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/07/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h2 id="第一篇"><a href="#第一篇" class="headerlink" title="第一篇"></a>第一篇</h2><p>上面对内容就当是记录 hexo 当用法了<br>好久没想过要弄博客了，以前学习的时候，笔记要么是在印象笔记里面，要么是在 github 仓库中用 markdown 写的<br>但是，每次想要看自己以前的笔记的时候，都比较麻烦，而且由于是个人的笔记，没放在网上，因此对排版，以及语句是否通顺都不是很在意<br>这样都结果就是，连我自己都不想看以前都笔记了，感觉有些积累都浪费了<br>这次又一次捣鼓博客内容，需要专心专注博客内容，不捣鼓什么域名，评论，主题等一些东西<br>以前也玩过一些，主要注意力被分散了，很难坚持，希望这次能够坚持都时间长一些<br>先订一个小目标，至少要坚持个3个月，每周至少一篇总结，前两周先把以前都笔记整理一下</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
